<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Cet article est la suite de mon premier article sur l’implémentation SHA1 sur Gameboy.Ici nous allons voir comment créer une interface graphique afin d’utili...">
<link type="application/atom+xml" rel="alternate" href="https://elrindel.github.io/feed.xml" title="Elrindel/Flob Blog" />
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Suite SHA1 sur GameBoy : Interface graphique | Elrindel/Flob Blog</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Suite SHA1 sur GameBoy : Interface graphique" />
<meta property="og:locale" content="fr_FR" />
<meta name="description" content="Cet article est la suite de mon premier article sur l’implémentation SHA1 sur Gameboy. Ici nous allons voir comment créer une interface graphique afin d’utiliser l’algorithme SHA1. L’objectif est donc de permettre la saisie d’un texte et de réaliser l’affichage du hash SHA1 pour le texte renseigné. Ecrire un texte sur GameBoy On pourrait penser qu’il s’agit d’une fonctionnalité intégrée par défaut dans la GB mais ce n’est pas le cas ! Son écran de 160x144 pixels est divisé en 360 sections de 8x8 pixels qui font chacune référence à une tile, donc nous avons un affichage de 20x18 tiles. Une tile est une image de 8x8 pixels. Chaque pixel nécessitant 2 bits afin de correspondre à l’une des 4 couleurs possibles, on se retrouve donc avec 16 octets (128 bits) par tile. Ces tiles sont chargées en mémoire dans la partie VRAM, à partir de l’adresse 0x8000 ou 0x8800 suivant le bit 4 que vous aurez définit à l’adresse 0xFF40 : Voir les spécifications Vous l’aurez peut-être déjà compris, si on veut afficher du texte, il nous faut des tiles qui correspondent aux caractères qu’on souhaite afficher ! Choisir la police d’écriture Etrangement, il s’avère un peu compliqué de trouver des packs de tiles de caractères pour GB. Après quelque recherches je suis arrivé sur ce site : Pixel Font Edit Ne souhaitant pas installer l’application, j’ai simplement récupéré les fichiers .pf présents dans l’archive d’installation, ils sont disponibles sur mon GitHub à cette adresse : GameBoy Tiles Fonts Ces fichiers .pf contiennent 256 caractères mais sous un format différent des tiles pour la GameBoy. J’ai donc préparé un petit script de conversion : #!/usr/bin/env python3 import getopt, sys def usage(): print(&quot;&quot;&quot; Usage : font.py [OPTIONS] &lt;FontFile&gt; Options : -o Output file -s Start offset -l Limit tiles (number of tiles to export) &quot;&quot;&quot;) sys.exit(2) def main(): try: opts, args = getopt.getopt(sys.argv[1:],&quot;o:s:l:h&quot;,[&quot;output&quot;, &quot;start&quot;, &quot;limit&quot;, &quot;help&quot;]) except getopt.GetoptError as error: print(error) usage() if len(args) != 1: usage() start = 0 limit = -1 out = None for opt, arg in opts: if opt in (&quot;-h&quot;, &quot;--help&quot;): usage() elif opt in (&quot;-s&quot;, &quot;--start&quot;): start = int(arg) elif opt in (&quot;-l&quot;, &quot;--limit&quot;): limit = int(arg) elif opt in (&quot;-o&quot;, &quot;--output&quot;): out = arg else: usage() if not out: usage() reader = open(args[0], &quot;rb&quot;) writer = open(out, &quot;wb&quot;) if start &gt; 0: reader.seek(start*8) while True: if limit == 0: break fontChar = reader.read(8) if not fontChar or len(fontChar) &lt; 8: break tileChar = b&#39;&#39; for y in range(0, 8): tileCharCode = 0 for x in range(0, 8): tileCharCode &lt;&lt;= 1 if (fontChar[y]&gt;&gt;(7-x))&amp;1: tileCharCode |= 1 tileChar += bytes([tileCharCode&amp;0xFF, tileCharCode&amp;0xFF]) writer.write(tileChar) limit -= 1 reader.close() writer.close() if __name__ == &quot;__main__&quot;: main() J’ai fait en sorte de pouvoir sélectionner le caractères de départ (option -s) ainsi que le nombre de caractères (option -l) afin de générer facilement les tiles dont on a besoin sans pour autant convertir les 256 caractères. Exemple d’utilisation : pftotiles.py -s 24 -l 104 -o TINYTYPE.bin TINYTYPE.pf Permet de convertir 104 caractères à partir du 25ème caractères (l’offset commence à zéro). Ajouter les tiles au programme Maintenant qu’on a notre fichier de tiles, il faut l’insérer dans le code : .ORG $0800 tiles: .INCBIN &quot;TINYTYPE.bin&quot; On inclut ces données à l’adresse 0x0800. Je n’ai pas trouvé d’indications concernant cette adresse en particulier, je suppose donc qu’on peut l’inclure à n’importe quelle adresse libre dans la ROM (donc après le programme) : Répartition de la mémoire Pour ce projet, l’adresse 0x0800 est bien libre donc je vais l’utiliser. Désormais on peut charger ces tiles dans l’espace mémoire réservé aux tiles pour l’affichage (VRAM) : ld de,104*16 ;de = 1664 ld hl,$8000+$180 ;hl = $8180 ld bc,tiles ;bc = tiles loadTile: ld a,(bc) ;a = (bc) ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec de ;de -= 1 ld a,e ;a = e or d ;a |= b jr nz,loadTile ;Si a != 0 : Jump loadTile Lorsque j’ai généré mon fichier de tiles (voir le chapitre précédent) j’ai limité à 104 caractères, chaque tile faisant 16 octets, c’est pourquoi je charge 1664 octets. Concernant l’adresse de départ (0x8180), l’explication est très similaire. Lors de la génération des tiles j’ai décidé de commencer au 25ème caractère (donc un offset de 24), ce qui fait un décalage de 24x16 octets (384 = 0x180). Voir le chapitre suivant pour plus de détails sur ce placement ! Utiliser directement une chaine de caractères ! Comme on l’a vu, sur la GB les caractères sont des tiles qu’on doit charger nous même en mémoire. On peut donc les ranger comme on veut ! La meilleure solution pour faciliter au maximum l’utilisation de ces tiles est donc de les faire correspondre à l’ordre qu’on a l’habitude de manipuler en informatique, c’est à dire l’ASCII ! Ca tombe bien puisque c’est déjà l’ordre des caractères dans les polices d’écriture 8x8 que nous avons vu ci-dessus. Chaque tile possède un numéro, on peut donc faire coïncider ce numéro à la valeur ASCII du caractère. Mon caractère de référence (mon point de départ) est l’espace (\x20), les caractères précédents étants moins facilement identifiables. On doit donc placer la tile du caractère espace en position 0x20. Les tiles commencent à l’adresse 0x8000 et chaque tile occupe 16 octets. L’adresse de la tile 0x20 est donc 0x8000 + 16 * 0x20 ce qui fait 0x8200. On sait à quelle adresse placer le caractères espace, mais nous avons d’autres tiles avant l’espace dans le fichier que nous avons généré. Il suffit donc de soustraire ces tiles à l’adresse pour savoir à partir de quelle espace mémoire il faudra insérer nos tiles. J’ai 8 caractères avant l’espace dans mon fichier, je dois donc retirer 8 * 16 octets à l’adresse de l’espace : 0x8200 - 8 * 16 = 0x8180 Maintenant que nos tiles sont bien placées en mémoire, nous pouvons stocker nos chaines de caractères directement dans la ROM tout comme on l’a fait précédemment pour le fichier des tiles : .ORG $0800 tiles: .INCBIN &quot;TINYTYPE.bin&quot; strText: .DB &quot;Text :&quot; strHash: .DB &quot;SHA1 :&quot; strPressUpDown: .DB $18, &quot;/&quot;, $19, &quot; : Change char&quot; strPressA: .DB &quot;A : Select char&quot; strPressB: .DB &quot;B : Deselect char&quot; strPressStart: .DB &quot;Press START to hash&quot; J’utilise .DB pour définir mes textes, et dans le cas des caractères spéciaux j’ai préféré utiliser le code hexa directement (pour les flèches up et down dans strPressUpDown). Je peux désormais atteindre mes chaines de caractères facilement dans mon code en utilisant les labels ! Comment afficher les tiles à l’écran L’affichage est directement lié au contenu des espaces mémoire des 3 différentes couches graphiques (Background, Window, Sprites à voir ci-dessous). Seulement il n’est pas possible d’écrire des données n’importe quand dans ces espaces mémoire ! En effet, il faut attendre que l’écran soit éteint ou que l’affichage n’utilise plus la mémoire vidéo. L’interruption V-Blank est justement là pour ça ! D’ailleurs, si vous souhaitez éteindre l’écran, il faut absolument le faire durant le V-Blank sinon vous risquez de réduire la durée de vie de votre écran ! Interruption V-Blank L’interruption V-Blank permet donc de manipuler la mémoire vidéo des 3 couches mais il faut également prendre en compte une informations importante : Vous avez seulement 4560 cycles à partir du début du V-Blank Cette limitation de 4560 cycles vient du fait que l’affichage ne va pas attendre la fin des instructions pour s’actualiser ! Ce qui a pour effet de bloquer l’accès à la mémoire durant l’affichage et donc durant le V-Blank si vous dépassez cette limite. Donc si vous dépassez cette limite sans en tenir compte et que vous tentez d’écrire dans la mémoire vidéo, vos données ne seront pas écrites et donc pas affichées/actualisées, mais votre code continuera de s’exécuter, vous constaterez donc des trous dans votre affichage ! Pour éviter cela, il faut compter les cycles ! Chaque instruction assembleur nécessite un certain nombre de cycles pour être exécutée : Voir les instructions CPU Toutes les informations sont disponibles dans les spécifications : Accessing VRAM and OAM On remarque notamment un exemple permettant d’attendre l’accès à cette mémoire. Ce qui permet par exemple d’avoir un V-Blank de plus de 4560 cycles en découpant le code en plusieurs parties tout en attendant l’accès mémoire entre chaque partie (ou même permettre d’accéder à cette mémoire en dehors de l’interruption VBlank). Dans le cas présent, nous le verrons plus bas, j’ai compté les cycles pour segmenter mon affichage en plusieurs parties. Il existe donc 3 couches pour afficher des tiles, chacune a ses particularités : Background D’une dimension de 32x32 tiles, il est principalement utilisé pour afficher le niveau du jeu grâce à sa propriété qui est d’être scrollable, c’est à dire que la zone affichée à l’écran (20x18 tiles) peut se balader sur le background. De plus, le scroll dans le background est infini puisqu’il peut tourner en boucle ! Le bas est lié au haut tout comme le bord droit est lié au bord gauche. La background est stocké à partir de l’adresse 0x9800 ou 0x9C00 suivant le bit 3 définit à l’adresse 0xFF40 : Voir les spécifications Chaque octet du background correspond au numéro de la tile à afficher. Window Cette couche vient par dessus le background. Elle possède également une dimension de 32x32 tiles (1 octet par tile) mais n’est pas scrollable comme le background. Sa propriété est de pouvoir être déplacée sur l’écran, ce qui permet par exemple de créer une boite de dialogue, un menu etc… Tout comme le background, son adresse est soit 0x9800 soit 0x9C00 dépendamment du bit 6 définit à l’adresse 0xFF40. Sprites Les sprites ont la priorité d’affichage la plus haute (ils sont affichés au dessus des autres couches). Il est possible d’afficher un maximum de 40 sprites mais avec une limitation à 10 sprites par ligne. Un sprite est composé de 1 tile (8x8 ou 8x16 suivant le flag), de coordonnées X et Y pour le positionner sur l’écran, ainsi que d’un flag correspondant à quelques options : VRAM Sprite Attribute Table (OAM) Il y a donc 4 octets par sprite (Y, X, tile, flag). Ils sont stockés à partir de l’adresse 0xFE00. On peut utiliser les sprites pour un très petit texte ou pour afficher les personnages dans le jeu par exemple. Choix de l’affichage pour ce projet Vu la quantité d’informations à afficher, j’élimine les sprites. Il reste donc background ou window. Les deux peuvent répondre au besoin ! Le background est très simple à manipuler, j’ai donc décidé de l’utiliser. Exemple d’affichage d’un texte Voici un exemple pour afficher le texte Press START to hash sur la dernière ligne de l’écran : ld hl,$9A20 ld bc,strPressStart ld d,19 loopStrPressStart: ld a,(bc) ldi (hl),a inc bc dec d jr nz,loopStrPressStart L’adresse du background commence à 0x9800, chaque ligne du background possède 32 positions, le scroll est placé en 0,0 et l’écran a 18 lignes. On peut donc calculer l’emplacement de la dernière ligne affichée à l’écran : 0x9800 + 17 * 32 = 0x9A20 (17 car on veut le début de la 18ème ligne et non le début de la 19ème, tout comme il faudrait mettre 0 pour avoir le début de la première ligne) Il faut évidemment spécifier la longueur du texte (19 dans le cas présent). Sachant que l’écran permet d’afficher 20 caractères par ligne, si le texte est plus long il faudra donc l’afficher sur plusieurs lignes. Détection des touches La lecture de l’état des boutons n’est pas compliquée mais s’avère être potentiellement instable ! En effet, seuls 4 bits (0 à 3) du registre 0xFF00 permettent de récupérer l’état des boutons. Mais la GameBoy possède 8 boutons, donc ces 4 bits sont partagés suivant l’état des bits 4 et 5 comme spécifié dans la doc : Joypad Input Notez bien que les bits 4 et 5 sont sélectionnés lorsqu’ils sont à 0 et que les bits des boutons sont également à 0 lorsque ces derniers sont appuyés. Donc, pour lire l’état des boutons, il faut procéder en deux étapes : On définit les bits 4 et 5 dans le registre 0xFF00 afin de spécifier quelles touches on souhaite lire On récupère la valeur de ce même registre (0xFF00) pour lire l’état des bits 0 à 3 correspondants aux boutons Concernant l’instabilité que j’évoquais précédemment, elle est liée au fait que l’attribution des bits correspondants aux états des boutons n’est pas instantanée ! La lecture peut donc être faussée si elle est faite trop rapidement. Dans la pratique, il est donc recommandé de lire plusieurs fois le registre 0xFF00 pour être certain de récupérer les bonnes valeurs. On peut également définir les bits 4 et 5 en amont dans le code afin d’anticiper la future lecture ! Voici un exemple pour la touche Down : ld a,%00100000 ;a = 0b00100000 ldh ($00),a ;(FF00) = a ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) bit 3,a ;Test bit 3 du registre a jr nz,notKeyDown ;Si bit 3 != 0 : Jump notKeyDown ;TODO : action key down notKeyDown: On définit les bits 4 et 5 du registre 0xFF00 pour sélectionner les touches de direction (bit 4 à 0 et bit 5 à 1). Afin de bien lire la bonne valeur, on fait plusieurs lectures du registre 0xFF00. Je n’ai pas trouvé d’informations précises sur le nombre de cycles nécessaires avant d’être vraiment certain de la lecture … à l’occasion je procèderai à quelques tests pour déterminer cela. Et enfin, on test le bit de la touche souhaitée, si il n’est pas à 0 on saute après le traitement du bouton. Dans l’optique d’optimiser le nombre d’instructions dans l’interruption VBlank, je place la gestion des touches dans la boucle principale loop ! Saisie d’un texte depuis la GameBoy Maintenant qu’on sait comment afficher du texte à l’écran et comment détecter l’appui d’une touche, on va pouvoir mettre en place le système de saisie de caractères. L’écran pouvant afficher 20 tiles sur une ligne, j’ai décidé de limiter la saisie à 20 caractères, ce qui est déjà pas mal pour tester le SHA1 ! Espace mémoire nécessaire Voici les variables nécessaires pour réaliser la saisie d’un texte : VBlankTimer DB ;Compteur VBlank pour avoir un timer synchronisé sur l&#39;affichage KeyLastDir DB ;Dernière touche de direction appuyées KeyLastBut DB ;Dernier bouton appuyé CharTmp DB ;Caractère en cours CharCount DB ;Nombre de caractères déjà sélectionnés CharBuffer DS 20 ;Enregistrement des caractères sélectionnés VBlankTimer sera nécessaire pour gérer le clignotement du caractère en cours, voir ci-dessous. Les deux variables KeyLast permettent d’éviter l’exécution en boucle des boutons, voir ci-dessous. Défilement des caractères Le défilement des caractères sera géré par les touches Up et Down : ld a,%00100000 ;a = 0b00100000 ldh ($00),a ;(FF00) = a ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ld b,a ;b = a and %00001111 ;a &amp;= 0b00001111 xor %00001111 ;a ^= 0b00001111 jr nz,notKeyDirRefresh ;Si a != 0 : Jump notKeyDirRefresh xor a ;a = 0 ld (KeyLastDir),a ;(KeyLastDir) = a jr notKeyUp ;Jump notKeyUp notKeyDirRefresh: bit 3,b ;Test bit 3 de b : Down jr nz,notKeyDown ;Si bit 3 != 0 : Jump notKeyDown ld a,(KeyLastDir) ;a = (KeyLastDir) cp 4 jr z,notKeyDown ;Si a == 4 : Jump notKeyDown ld a,4 ;a = 4 ld (KeyLastDir),a ;(KeyLastDir) = a ld a,(CharTmp) ;a = (CharTmp) dec a ;a -= 1 cp $20 jr nc,processKeyDown ;Si a &gt;= 32 : Jump processKeyDown ld a,$7E ;a = 126 processKeyDown: ld (CharTmp),a ;(CharTmp) = a notKeyDown: bit 2,b ;Test bit 2 de b : Up jr nz,notKeyUp ;Si bit 2 != 0 : Jump notKeyUp ld a,(KeyLastDir) ;a = (KeyLastDir) cp 3 jr z,notKeyUp ;Si a == 3 : Jump notKeyUp ld a,3 ;a = 3 ld (KeyLastDir),a ;(KeyLastDir) = a ld a,(CharTmp) ;a = (CharTmp) inc a ;a += 1 cp $7F jr c,processKeyUp ;Si a &lt; 127 : Jump processKeyUp ld a,$20 ;a = 32 processKeyUp: ld (CharTmp),a ;(CharTmp) = a notKeyUp: Je commence par définir puis lire le registre 0xFF00 pour les touches directionnelles (voir le chapitre précédent sur la détection des touches). Si aucune touche est appuyée je réinitialise KeyLastDir et je saute à la fin du traitement des touches. Sinon je vérifie les deux touches (Up et Down) tout en m’assurant que KeyLastDir n’a pas la valeur de la touche en cours (valeur définie arbitrairement par moi même). Cette vérification a pour but d’éviter une exécution en boucle car le CPU est bien plus rapide que nos doigts, il aura le temps de passer plusieurs fois sur la détection de la touche avant qu’on ait relâché le bouton ! Puis j’incrémente ou décrémente la valeur de CharTmp tout en m’assurant de rester dans la limite des caractères que je souhaite utiliser (en l’occurrence entre 32 et 126, soit \x20 et \x7E). Validation/Suppression du caractère La touche A permettra de valider la sélection du caractère en cours, et la touche B supprimera le dernier caractère et permettra de le re-définir : ld a,%00010000 ;a = 0b00010000 ldh ($00),a ;(FF00) = a ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ld b,a ;b = a and %00001111 ;a &amp;= 0b00001111 xor %00001111 ;a ^= 0b00001111 jr nz,notKeyButRefresh ;Si a != 0 : Jump notKeyButRefresh xor a ;a = 0 ld (KeyLastBut),a ;(KeyLastBut) = a jr notKeyB ;Jump notKeyB notKeyButRefresh: bit 0,b ;Test bit 0 de b : A jr nz,notKeyA ;Si bit 0 != 0 : Jump notKeyA ld a,(KeyLastBut) ;a = (KeyLastBut) cp 1 jr z,notKeyA ;Si a == 1 : Jump notKeyA ld a,1 ;a = 1 ld (KeyLastBut),a ;(KeyLastBut) = a ld a,(CharCount) ;a = (CharCount) cp 20 jr z,notKeyA ;Si a == 20 : Jump notKeyA xor d ;d = 0 ld e,a ;e = a ld hl,CharBuffer ;hl = CharBuffer add hl,de ;hl += de inc a ;a += 1 ld (CharCount),a ;(CharCount) = a ld a,(CharTmp) ;a = (CharTmp) ld (hl),a ;(hl) = a notKeyA: bit 1,b ;Test bit 1 de b : B jr nz,notKeyB ;Si bit 1 != 0 : Jump notKeyB ld a,(KeyLastBut) ;a = (KeyLastBut) cp 2 jr z,notKeyB ;Si a == 2 : Jump notKeyB ld a,2 ;a = 2 ld (KeyLastBut),a ;(KeyLastBut) = a ld a,(CharCount) ;a = (CharCount) cp 0 jr z,notKeyB ;Si a == 0 : Jump notKeyB xor d ;d = 0 ld e,a ;e = a ld hl,CharBuffer ;hl = CharBuffer add hl,de ;hl += de dec a ;a -= 1 ld (CharCount),a ;(CharCount) = a ld a,$00 ;a = 0 ld (hl),a ;(hl) = a notKeyB: Le fonctionnement est très similaire aux touches Up et Down du chapitre précédent. La touche A va ajouter CharTmp dans CharBuffer en appliquant le décalage d’adresse pour le caractère en cours (en se basant sur CharCount), puis va incrémenter CharCount afin de passer au caractère suivant. La touche B va réinitialiser la valeur du caractère en cours dans CharBuffer puis décrémenter CharCount. Affichage et clignotement pour le caractère en cours Pour mettre en valeur le caractère en cours, une pratique courante est de le faire clignoter. Pour que le clignotement soit bien synchronisé avec la fréquence d’affichage, j’ai décidé d’ajouter un compteur qui est incrémenté à chaque exécution de VBlank. ld a,(VBlankTimer) ;a = (VBlankTimer) inc a ;a += 1 ld (VBlankTimer),a ;(VBlankTimer) = a ld e,a ;e = a ld hl,$9800 ;hl = $9800 ld d,20 ;d = 20 ld bc,CharBuffer ;bc = CharBuffer displayCharBuffer: ld a,(bc) ;a = (bc) ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec d ;d -= 1 jr nz,displayCharBuffer ;Si d != 0 : Jump displayCharBuffer ld hl,$9800 ;hl = $9800 ld a,(CharCount) ;a = (CharCount) ld b,0 ;b = 0 ld c,a ;c = a add hl,bc ;hl += bc xor a ;a = 0 bit 4,e ;Test bit 4 de e jr z,endBlink ;Si bit 4 == 0 : Jump endBlink ld a,(CharTmp) ;a = (CharTmp) endBlink: ld (hl),a ;(hl) = a A chaque passage dans VBlank j’incrémente VBlankTimer puis j’actualise l’affichage du contenu de CharBuffer. Afin d’afficher la tile au bon emplacement, j’utilise la variable CharCount pour décaler l’adresse mémoire du background au bon endroit. Après quelques tests, le bit 4 du compteur me semble être le meilleur compris pour la vitesse de clignotement. Si il est à 0 j’affiche une tile vide, sinon j’affiche le caractère en cours. Intégration du code SHA1 Il est temps d’intégrer l’algorithme SHA1 que j’ai réalisé dans mon précédent article : Implémentation SHA1 sur GameBoy Un simple copier coller des variables et du code nécessaire au fonctionnement de l’algo et c’est déjà quasiment fini. Construction du bloc SHA1 Un point que j’avais pas implémenté et qui est nécessaire ici, c’est la génération automatique du bloc SHA1. En effet, pour fonctionner, le SHA1 fait ses opérations sur des blocs de 64 octets, mais j’ai déjà expliqué cela dans mon précédent article : Construction de la chaine à hacher (blocs SHA1) Dans le cas présent, la saisie étant limitée à 20 caractères, le bloc SHA1 est très simple à générer : processSha1: ld hl,Block ;hl = Block ld bc,CharBuffer ;bc = CharBuffer ld a,(CharCount) ;a = (CharCount) cp 0 jr z,loopBufferBlockEnd ;Si a == 0 : Jump loopBufferBlockEnd ld e,a ;e = a loopBufferBlock: ld a,(bc) ;a = (bc) ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec e ;e -= 1 jr nz,loopBufferBlock ;Si e != 0 : Jump loopBufferBlock loopBufferBlockEnd: ld a,$80 ;a = $80 ldi (hl),a ;(hl) = a, hl += 1 ld a,(CharCount) ;a = (CharCount) ld e,a ;e = a ld a,62 ;a = 62 sub e ;a -= e ld e,a ;e = a xor a ;a = 0 loopInitBlock: ldi (hl),a ;(hl) = a, hl += 1 dec e ;e -= 1 jr nz,loopInitBlock ;Si e != 0 : Jump loopInitBlock ld a,(CharCount) ;a = (CharCount) sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 ldi (hl),a ;(hl) = a, hl += 1 call sha1 ld a,1 ;a = 1 ld (DisplayHash),a ;(DisplayHash) = a ret Je copie le contenu de CharBuffer dans Block en me basant sur CharCount pour savoir combien de caractères je dois copier (sachant qu’il peut aussi y avoir 0 caractères). Puis je fini la construction du bloc avec le caractère \x80 suivi du remplissage des null bytes et enfin le dernier caractère représentant la longueur de la chaine. Après avoir appelé le calcul du sha1 je définit ma variable DisplayHash à 1 afin de déclencher l’affichage lors du prochain VBlank. Affichage du hash On peut désormais passer à l’affichage du hash SHA1. Puisqu’on doit manipuler la mémoire vidéo il faut faire cela dans le VBlank, ce qui implique de prendre en compte la limitation de 4560 cycles comme expliqué dans le chapitre Interruption V-Blank. ld a,(DisplayHash) ;a = (DisplayHash) cp 1 jr nz,tryDisplayHash ;Si a != 1 : Jump tryDisplayHash inc a ;a += 1 ld (DisplayHash),a ;(DisplayHash) = a ld hl,$9860 ;hl = $9860 ld d,20 ;d = 20 xor a ;a = 0 loopCleanText: ldi (hl),a ;(hl) = a dec d ;d -= 1 jr nz,loopCleanText ld hl,$9860 ;hl = $9860 ld bc,CharBuffer ;bc = CharBuffer ld a,(CharCount) ;a = (CharCount) cp 0 jr z,displayHashEnd ;Si a == 0 : Jump displayHashEnd ld d,a ;d = a loopDisplayText: ld a,(bc) ;a = (bc) ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec d ;d -= 1 jr nz,loopDisplayText ;Si d != 0 : Jump loopDisplayText jr displayHashEnd ;Jump displayHashEnd tryDisplayHash: cp 2 jr nz,displayHashEnd ;Si a != 2 : Jump displayHashEnd ld hl,$98C0 ;hl = $98C0 ld bc,StateA ;bc = StateA ld d,4 ;d = 4 ld e,5 ;e = 5 jr loopDisplayHash ;Jump loopDisplayHash loopDisplayHash2: push bc ;Stack bc ld d,4 ;d = 4 ld bc,24 ;bc = 24 add hl,bc ;hl += bc pop bc ;UnStack bc loopDisplayHash: ld a,(bc) ;a = (bc) srl a ;a &gt;&gt;= 1 srl a ;a &gt;&gt;= 1 srl a ;a &gt;&gt;= 1 srl a ;a &gt;&gt;= 1 cp 10 jr c,displayHashHex1 ;Si a &lt; 10 : Jump displayHashHex1 add 7 ;a += 7 displayHashHex1: add $30 ;a += 48 ldi (hl),a ;(hl) = a, hl += 1 ld a,(bc) ;a = (bc) and $0F ;a &amp;= 15 cp 10 jr c,displayHashHex2 ;Si a &lt; 10 : Jump displayHashHex2 add 7 ;a += 7 displayHashHex2: add $30 ;a += 48 ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec d ;d -= 1 jr nz,loopDisplayHash ;Si d != 0 : Jump loopDisplayHash dec e ;e -= 1 jr nz,loopDisplayHash2 ;Si e != 0 : Jump loopDisplayHash2 xor a ;a = 0 ld (DisplayHash),a ;(DisplayHash) = a jr endVBlank ;Jump endVBlank displayHashEnd: Afin de séparer l’affichage en plusieurs parties (pour ne pas dépasser le nombre de cycles) j’utilise la variable DisplayHash pour savoir quelle partie je dois afficher. Si mes calculs sont bons, je dépasse jamais la limite des 4560 cycles ! Si DisplayHash est égal à 1 j’incrémente sa valeur (pour le prochain passage dans VBlank) puis je génère l’affichage du texte en commençant par remettre toutes les tiles de la ligne à 0 puis en affichant le contenu de CharBuffer. Si DisplayHash est égal à 2 alors je procède à l’affichage du hash sur 5 lignes de 4 * 2 caractères (pour une représentation hexadécimale). Je parcours donc les octets en commençant par StateA, puis tous les 4 octets je passe à la ligne suivante (les 5 variables State se suivent dans la mémoire, il suffit donc juste d’incrémenter l’adresse depuis le point de départ StateA). Pour avoir l’affichage en hexadécimal, je récupère dans un premier temps les 4 bits de poids fort (via 4 décalages vers la droite). Si la valeur est supérieure à 9 c’est qu’il s’agit d’une lettre auquel cas j’ajoute 7 en plus de 48, ainsi je fais correspondre avec le bon caractère (le décalage de 7 vient des 7 caractères entre les chiffres et les lettres dans la table ASCII). Le principe est identique pour les 4 bits de poids faible, je les récupère avec un and 0b00001111 puis je fais exactement les mêmes opérations que pour les 4 bits précédents. Pour finir, je repasse DisplayHash à 0 afin de permettre de relancer un nouveau calcul SHA1 et donc un nouvel affichage. Conclusion Au début j’avais un doute sur la nécessité de faire un article sur ce sujet. Puis quand j’ai commencé à me renseigner et à faire mes tests, j’ai trouvé ça vraiment très intéressant et il aurait été dommage de ne pas partager tout ça ! Même si ça semble très simple, il y a assez de possibilités et de subtilités pour justifier la rédaction d’un article. Comme d’habitude, il y a encore pas mal d’optimisations possibles et je suis preneur de vos propositions ! Et encore une fois, un grand merci à entropyQueen pour l’idée du projet et pour le test de mon code en conditions réelles sur sa GameBoy ! (Hé oui, je n’ai pas encore le matériel pour tester sur ma GB, je me contente de l’émulateur) Sources et inspirations Code du projet Polices d’écriture GB Mon premier article Spécifications GameBoy Blog d’entropyQueen Article de Furrtek Suite d’articles de FLOZz" />
<meta property="og:description" content="Cet article est la suite de mon premier article sur l’implémentation SHA1 sur Gameboy. Ici nous allons voir comment créer une interface graphique afin d’utiliser l’algorithme SHA1. L’objectif est donc de permettre la saisie d’un texte et de réaliser l’affichage du hash SHA1 pour le texte renseigné. Ecrire un texte sur GameBoy On pourrait penser qu’il s’agit d’une fonctionnalité intégrée par défaut dans la GB mais ce n’est pas le cas ! Son écran de 160x144 pixels est divisé en 360 sections de 8x8 pixels qui font chacune référence à une tile, donc nous avons un affichage de 20x18 tiles. Une tile est une image de 8x8 pixels. Chaque pixel nécessitant 2 bits afin de correspondre à l’une des 4 couleurs possibles, on se retrouve donc avec 16 octets (128 bits) par tile. Ces tiles sont chargées en mémoire dans la partie VRAM, à partir de l’adresse 0x8000 ou 0x8800 suivant le bit 4 que vous aurez définit à l’adresse 0xFF40 : Voir les spécifications Vous l’aurez peut-être déjà compris, si on veut afficher du texte, il nous faut des tiles qui correspondent aux caractères qu’on souhaite afficher ! Choisir la police d’écriture Etrangement, il s’avère un peu compliqué de trouver des packs de tiles de caractères pour GB. Après quelque recherches je suis arrivé sur ce site : Pixel Font Edit Ne souhaitant pas installer l’application, j’ai simplement récupéré les fichiers .pf présents dans l’archive d’installation, ils sont disponibles sur mon GitHub à cette adresse : GameBoy Tiles Fonts Ces fichiers .pf contiennent 256 caractères mais sous un format différent des tiles pour la GameBoy. J’ai donc préparé un petit script de conversion : #!/usr/bin/env python3 import getopt, sys def usage(): print(&quot;&quot;&quot; Usage : font.py [OPTIONS] &lt;FontFile&gt; Options : -o Output file -s Start offset -l Limit tiles (number of tiles to export) &quot;&quot;&quot;) sys.exit(2) def main(): try: opts, args = getopt.getopt(sys.argv[1:],&quot;o:s:l:h&quot;,[&quot;output&quot;, &quot;start&quot;, &quot;limit&quot;, &quot;help&quot;]) except getopt.GetoptError as error: print(error) usage() if len(args) != 1: usage() start = 0 limit = -1 out = None for opt, arg in opts: if opt in (&quot;-h&quot;, &quot;--help&quot;): usage() elif opt in (&quot;-s&quot;, &quot;--start&quot;): start = int(arg) elif opt in (&quot;-l&quot;, &quot;--limit&quot;): limit = int(arg) elif opt in (&quot;-o&quot;, &quot;--output&quot;): out = arg else: usage() if not out: usage() reader = open(args[0], &quot;rb&quot;) writer = open(out, &quot;wb&quot;) if start &gt; 0: reader.seek(start*8) while True: if limit == 0: break fontChar = reader.read(8) if not fontChar or len(fontChar) &lt; 8: break tileChar = b&#39;&#39; for y in range(0, 8): tileCharCode = 0 for x in range(0, 8): tileCharCode &lt;&lt;= 1 if (fontChar[y]&gt;&gt;(7-x))&amp;1: tileCharCode |= 1 tileChar += bytes([tileCharCode&amp;0xFF, tileCharCode&amp;0xFF]) writer.write(tileChar) limit -= 1 reader.close() writer.close() if __name__ == &quot;__main__&quot;: main() J’ai fait en sorte de pouvoir sélectionner le caractères de départ (option -s) ainsi que le nombre de caractères (option -l) afin de générer facilement les tiles dont on a besoin sans pour autant convertir les 256 caractères. Exemple d’utilisation : pftotiles.py -s 24 -l 104 -o TINYTYPE.bin TINYTYPE.pf Permet de convertir 104 caractères à partir du 25ème caractères (l’offset commence à zéro). Ajouter les tiles au programme Maintenant qu’on a notre fichier de tiles, il faut l’insérer dans le code : .ORG $0800 tiles: .INCBIN &quot;TINYTYPE.bin&quot; On inclut ces données à l’adresse 0x0800. Je n’ai pas trouvé d’indications concernant cette adresse en particulier, je suppose donc qu’on peut l’inclure à n’importe quelle adresse libre dans la ROM (donc après le programme) : Répartition de la mémoire Pour ce projet, l’adresse 0x0800 est bien libre donc je vais l’utiliser. Désormais on peut charger ces tiles dans l’espace mémoire réservé aux tiles pour l’affichage (VRAM) : ld de,104*16 ;de = 1664 ld hl,$8000+$180 ;hl = $8180 ld bc,tiles ;bc = tiles loadTile: ld a,(bc) ;a = (bc) ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec de ;de -= 1 ld a,e ;a = e or d ;a |= b jr nz,loadTile ;Si a != 0 : Jump loadTile Lorsque j’ai généré mon fichier de tiles (voir le chapitre précédent) j’ai limité à 104 caractères, chaque tile faisant 16 octets, c’est pourquoi je charge 1664 octets. Concernant l’adresse de départ (0x8180), l’explication est très similaire. Lors de la génération des tiles j’ai décidé de commencer au 25ème caractère (donc un offset de 24), ce qui fait un décalage de 24x16 octets (384 = 0x180). Voir le chapitre suivant pour plus de détails sur ce placement ! Utiliser directement une chaine de caractères ! Comme on l’a vu, sur la GB les caractères sont des tiles qu’on doit charger nous même en mémoire. On peut donc les ranger comme on veut ! La meilleure solution pour faciliter au maximum l’utilisation de ces tiles est donc de les faire correspondre à l’ordre qu’on a l’habitude de manipuler en informatique, c’est à dire l’ASCII ! Ca tombe bien puisque c’est déjà l’ordre des caractères dans les polices d’écriture 8x8 que nous avons vu ci-dessus. Chaque tile possède un numéro, on peut donc faire coïncider ce numéro à la valeur ASCII du caractère. Mon caractère de référence (mon point de départ) est l’espace (\x20), les caractères précédents étants moins facilement identifiables. On doit donc placer la tile du caractère espace en position 0x20. Les tiles commencent à l’adresse 0x8000 et chaque tile occupe 16 octets. L’adresse de la tile 0x20 est donc 0x8000 + 16 * 0x20 ce qui fait 0x8200. On sait à quelle adresse placer le caractères espace, mais nous avons d’autres tiles avant l’espace dans le fichier que nous avons généré. Il suffit donc de soustraire ces tiles à l’adresse pour savoir à partir de quelle espace mémoire il faudra insérer nos tiles. J’ai 8 caractères avant l’espace dans mon fichier, je dois donc retirer 8 * 16 octets à l’adresse de l’espace : 0x8200 - 8 * 16 = 0x8180 Maintenant que nos tiles sont bien placées en mémoire, nous pouvons stocker nos chaines de caractères directement dans la ROM tout comme on l’a fait précédemment pour le fichier des tiles : .ORG $0800 tiles: .INCBIN &quot;TINYTYPE.bin&quot; strText: .DB &quot;Text :&quot; strHash: .DB &quot;SHA1 :&quot; strPressUpDown: .DB $18, &quot;/&quot;, $19, &quot; : Change char&quot; strPressA: .DB &quot;A : Select char&quot; strPressB: .DB &quot;B : Deselect char&quot; strPressStart: .DB &quot;Press START to hash&quot; J’utilise .DB pour définir mes textes, et dans le cas des caractères spéciaux j’ai préféré utiliser le code hexa directement (pour les flèches up et down dans strPressUpDown). Je peux désormais atteindre mes chaines de caractères facilement dans mon code en utilisant les labels ! Comment afficher les tiles à l’écran L’affichage est directement lié au contenu des espaces mémoire des 3 différentes couches graphiques (Background, Window, Sprites à voir ci-dessous). Seulement il n’est pas possible d’écrire des données n’importe quand dans ces espaces mémoire ! En effet, il faut attendre que l’écran soit éteint ou que l’affichage n’utilise plus la mémoire vidéo. L’interruption V-Blank est justement là pour ça ! D’ailleurs, si vous souhaitez éteindre l’écran, il faut absolument le faire durant le V-Blank sinon vous risquez de réduire la durée de vie de votre écran ! Interruption V-Blank L’interruption V-Blank permet donc de manipuler la mémoire vidéo des 3 couches mais il faut également prendre en compte une informations importante : Vous avez seulement 4560 cycles à partir du début du V-Blank Cette limitation de 4560 cycles vient du fait que l’affichage ne va pas attendre la fin des instructions pour s’actualiser ! Ce qui a pour effet de bloquer l’accès à la mémoire durant l’affichage et donc durant le V-Blank si vous dépassez cette limite. Donc si vous dépassez cette limite sans en tenir compte et que vous tentez d’écrire dans la mémoire vidéo, vos données ne seront pas écrites et donc pas affichées/actualisées, mais votre code continuera de s’exécuter, vous constaterez donc des trous dans votre affichage ! Pour éviter cela, il faut compter les cycles ! Chaque instruction assembleur nécessite un certain nombre de cycles pour être exécutée : Voir les instructions CPU Toutes les informations sont disponibles dans les spécifications : Accessing VRAM and OAM On remarque notamment un exemple permettant d’attendre l’accès à cette mémoire. Ce qui permet par exemple d’avoir un V-Blank de plus de 4560 cycles en découpant le code en plusieurs parties tout en attendant l’accès mémoire entre chaque partie (ou même permettre d’accéder à cette mémoire en dehors de l’interruption VBlank). Dans le cas présent, nous le verrons plus bas, j’ai compté les cycles pour segmenter mon affichage en plusieurs parties. Il existe donc 3 couches pour afficher des tiles, chacune a ses particularités : Background D’une dimension de 32x32 tiles, il est principalement utilisé pour afficher le niveau du jeu grâce à sa propriété qui est d’être scrollable, c’est à dire que la zone affichée à l’écran (20x18 tiles) peut se balader sur le background. De plus, le scroll dans le background est infini puisqu’il peut tourner en boucle ! Le bas est lié au haut tout comme le bord droit est lié au bord gauche. La background est stocké à partir de l’adresse 0x9800 ou 0x9C00 suivant le bit 3 définit à l’adresse 0xFF40 : Voir les spécifications Chaque octet du background correspond au numéro de la tile à afficher. Window Cette couche vient par dessus le background. Elle possède également une dimension de 32x32 tiles (1 octet par tile) mais n’est pas scrollable comme le background. Sa propriété est de pouvoir être déplacée sur l’écran, ce qui permet par exemple de créer une boite de dialogue, un menu etc… Tout comme le background, son adresse est soit 0x9800 soit 0x9C00 dépendamment du bit 6 définit à l’adresse 0xFF40. Sprites Les sprites ont la priorité d’affichage la plus haute (ils sont affichés au dessus des autres couches). Il est possible d’afficher un maximum de 40 sprites mais avec une limitation à 10 sprites par ligne. Un sprite est composé de 1 tile (8x8 ou 8x16 suivant le flag), de coordonnées X et Y pour le positionner sur l’écran, ainsi que d’un flag correspondant à quelques options : VRAM Sprite Attribute Table (OAM) Il y a donc 4 octets par sprite (Y, X, tile, flag). Ils sont stockés à partir de l’adresse 0xFE00. On peut utiliser les sprites pour un très petit texte ou pour afficher les personnages dans le jeu par exemple. Choix de l’affichage pour ce projet Vu la quantité d’informations à afficher, j’élimine les sprites. Il reste donc background ou window. Les deux peuvent répondre au besoin ! Le background est très simple à manipuler, j’ai donc décidé de l’utiliser. Exemple d’affichage d’un texte Voici un exemple pour afficher le texte Press START to hash sur la dernière ligne de l’écran : ld hl,$9A20 ld bc,strPressStart ld d,19 loopStrPressStart: ld a,(bc) ldi (hl),a inc bc dec d jr nz,loopStrPressStart L’adresse du background commence à 0x9800, chaque ligne du background possède 32 positions, le scroll est placé en 0,0 et l’écran a 18 lignes. On peut donc calculer l’emplacement de la dernière ligne affichée à l’écran : 0x9800 + 17 * 32 = 0x9A20 (17 car on veut le début de la 18ème ligne et non le début de la 19ème, tout comme il faudrait mettre 0 pour avoir le début de la première ligne) Il faut évidemment spécifier la longueur du texte (19 dans le cas présent). Sachant que l’écran permet d’afficher 20 caractères par ligne, si le texte est plus long il faudra donc l’afficher sur plusieurs lignes. Détection des touches La lecture de l’état des boutons n’est pas compliquée mais s’avère être potentiellement instable ! En effet, seuls 4 bits (0 à 3) du registre 0xFF00 permettent de récupérer l’état des boutons. Mais la GameBoy possède 8 boutons, donc ces 4 bits sont partagés suivant l’état des bits 4 et 5 comme spécifié dans la doc : Joypad Input Notez bien que les bits 4 et 5 sont sélectionnés lorsqu’ils sont à 0 et que les bits des boutons sont également à 0 lorsque ces derniers sont appuyés. Donc, pour lire l’état des boutons, il faut procéder en deux étapes : On définit les bits 4 et 5 dans le registre 0xFF00 afin de spécifier quelles touches on souhaite lire On récupère la valeur de ce même registre (0xFF00) pour lire l’état des bits 0 à 3 correspondants aux boutons Concernant l’instabilité que j’évoquais précédemment, elle est liée au fait que l’attribution des bits correspondants aux états des boutons n’est pas instantanée ! La lecture peut donc être faussée si elle est faite trop rapidement. Dans la pratique, il est donc recommandé de lire plusieurs fois le registre 0xFF00 pour être certain de récupérer les bonnes valeurs. On peut également définir les bits 4 et 5 en amont dans le code afin d’anticiper la future lecture ! Voici un exemple pour la touche Down : ld a,%00100000 ;a = 0b00100000 ldh ($00),a ;(FF00) = a ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) bit 3,a ;Test bit 3 du registre a jr nz,notKeyDown ;Si bit 3 != 0 : Jump notKeyDown ;TODO : action key down notKeyDown: On définit les bits 4 et 5 du registre 0xFF00 pour sélectionner les touches de direction (bit 4 à 0 et bit 5 à 1). Afin de bien lire la bonne valeur, on fait plusieurs lectures du registre 0xFF00. Je n’ai pas trouvé d’informations précises sur le nombre de cycles nécessaires avant d’être vraiment certain de la lecture … à l’occasion je procèderai à quelques tests pour déterminer cela. Et enfin, on test le bit de la touche souhaitée, si il n’est pas à 0 on saute après le traitement du bouton. Dans l’optique d’optimiser le nombre d’instructions dans l’interruption VBlank, je place la gestion des touches dans la boucle principale loop ! Saisie d’un texte depuis la GameBoy Maintenant qu’on sait comment afficher du texte à l’écran et comment détecter l’appui d’une touche, on va pouvoir mettre en place le système de saisie de caractères. L’écran pouvant afficher 20 tiles sur une ligne, j’ai décidé de limiter la saisie à 20 caractères, ce qui est déjà pas mal pour tester le SHA1 ! Espace mémoire nécessaire Voici les variables nécessaires pour réaliser la saisie d’un texte : VBlankTimer DB ;Compteur VBlank pour avoir un timer synchronisé sur l&#39;affichage KeyLastDir DB ;Dernière touche de direction appuyées KeyLastBut DB ;Dernier bouton appuyé CharTmp DB ;Caractère en cours CharCount DB ;Nombre de caractères déjà sélectionnés CharBuffer DS 20 ;Enregistrement des caractères sélectionnés VBlankTimer sera nécessaire pour gérer le clignotement du caractère en cours, voir ci-dessous. Les deux variables KeyLast permettent d’éviter l’exécution en boucle des boutons, voir ci-dessous. Défilement des caractères Le défilement des caractères sera géré par les touches Up et Down : ld a,%00100000 ;a = 0b00100000 ldh ($00),a ;(FF00) = a ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ld b,a ;b = a and %00001111 ;a &amp;= 0b00001111 xor %00001111 ;a ^= 0b00001111 jr nz,notKeyDirRefresh ;Si a != 0 : Jump notKeyDirRefresh xor a ;a = 0 ld (KeyLastDir),a ;(KeyLastDir) = a jr notKeyUp ;Jump notKeyUp notKeyDirRefresh: bit 3,b ;Test bit 3 de b : Down jr nz,notKeyDown ;Si bit 3 != 0 : Jump notKeyDown ld a,(KeyLastDir) ;a = (KeyLastDir) cp 4 jr z,notKeyDown ;Si a == 4 : Jump notKeyDown ld a,4 ;a = 4 ld (KeyLastDir),a ;(KeyLastDir) = a ld a,(CharTmp) ;a = (CharTmp) dec a ;a -= 1 cp $20 jr nc,processKeyDown ;Si a &gt;= 32 : Jump processKeyDown ld a,$7E ;a = 126 processKeyDown: ld (CharTmp),a ;(CharTmp) = a notKeyDown: bit 2,b ;Test bit 2 de b : Up jr nz,notKeyUp ;Si bit 2 != 0 : Jump notKeyUp ld a,(KeyLastDir) ;a = (KeyLastDir) cp 3 jr z,notKeyUp ;Si a == 3 : Jump notKeyUp ld a,3 ;a = 3 ld (KeyLastDir),a ;(KeyLastDir) = a ld a,(CharTmp) ;a = (CharTmp) inc a ;a += 1 cp $7F jr c,processKeyUp ;Si a &lt; 127 : Jump processKeyUp ld a,$20 ;a = 32 processKeyUp: ld (CharTmp),a ;(CharTmp) = a notKeyUp: Je commence par définir puis lire le registre 0xFF00 pour les touches directionnelles (voir le chapitre précédent sur la détection des touches). Si aucune touche est appuyée je réinitialise KeyLastDir et je saute à la fin du traitement des touches. Sinon je vérifie les deux touches (Up et Down) tout en m’assurant que KeyLastDir n’a pas la valeur de la touche en cours (valeur définie arbitrairement par moi même). Cette vérification a pour but d’éviter une exécution en boucle car le CPU est bien plus rapide que nos doigts, il aura le temps de passer plusieurs fois sur la détection de la touche avant qu’on ait relâché le bouton ! Puis j’incrémente ou décrémente la valeur de CharTmp tout en m’assurant de rester dans la limite des caractères que je souhaite utiliser (en l’occurrence entre 32 et 126, soit \x20 et \x7E). Validation/Suppression du caractère La touche A permettra de valider la sélection du caractère en cours, et la touche B supprimera le dernier caractère et permettra de le re-définir : ld a,%00010000 ;a = 0b00010000 ldh ($00),a ;(FF00) = a ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ld b,a ;b = a and %00001111 ;a &amp;= 0b00001111 xor %00001111 ;a ^= 0b00001111 jr nz,notKeyButRefresh ;Si a != 0 : Jump notKeyButRefresh xor a ;a = 0 ld (KeyLastBut),a ;(KeyLastBut) = a jr notKeyB ;Jump notKeyB notKeyButRefresh: bit 0,b ;Test bit 0 de b : A jr nz,notKeyA ;Si bit 0 != 0 : Jump notKeyA ld a,(KeyLastBut) ;a = (KeyLastBut) cp 1 jr z,notKeyA ;Si a == 1 : Jump notKeyA ld a,1 ;a = 1 ld (KeyLastBut),a ;(KeyLastBut) = a ld a,(CharCount) ;a = (CharCount) cp 20 jr z,notKeyA ;Si a == 20 : Jump notKeyA xor d ;d = 0 ld e,a ;e = a ld hl,CharBuffer ;hl = CharBuffer add hl,de ;hl += de inc a ;a += 1 ld (CharCount),a ;(CharCount) = a ld a,(CharTmp) ;a = (CharTmp) ld (hl),a ;(hl) = a notKeyA: bit 1,b ;Test bit 1 de b : B jr nz,notKeyB ;Si bit 1 != 0 : Jump notKeyB ld a,(KeyLastBut) ;a = (KeyLastBut) cp 2 jr z,notKeyB ;Si a == 2 : Jump notKeyB ld a,2 ;a = 2 ld (KeyLastBut),a ;(KeyLastBut) = a ld a,(CharCount) ;a = (CharCount) cp 0 jr z,notKeyB ;Si a == 0 : Jump notKeyB xor d ;d = 0 ld e,a ;e = a ld hl,CharBuffer ;hl = CharBuffer add hl,de ;hl += de dec a ;a -= 1 ld (CharCount),a ;(CharCount) = a ld a,$00 ;a = 0 ld (hl),a ;(hl) = a notKeyB: Le fonctionnement est très similaire aux touches Up et Down du chapitre précédent. La touche A va ajouter CharTmp dans CharBuffer en appliquant le décalage d’adresse pour le caractère en cours (en se basant sur CharCount), puis va incrémenter CharCount afin de passer au caractère suivant. La touche B va réinitialiser la valeur du caractère en cours dans CharBuffer puis décrémenter CharCount. Affichage et clignotement pour le caractère en cours Pour mettre en valeur le caractère en cours, une pratique courante est de le faire clignoter. Pour que le clignotement soit bien synchronisé avec la fréquence d’affichage, j’ai décidé d’ajouter un compteur qui est incrémenté à chaque exécution de VBlank. ld a,(VBlankTimer) ;a = (VBlankTimer) inc a ;a += 1 ld (VBlankTimer),a ;(VBlankTimer) = a ld e,a ;e = a ld hl,$9800 ;hl = $9800 ld d,20 ;d = 20 ld bc,CharBuffer ;bc = CharBuffer displayCharBuffer: ld a,(bc) ;a = (bc) ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec d ;d -= 1 jr nz,displayCharBuffer ;Si d != 0 : Jump displayCharBuffer ld hl,$9800 ;hl = $9800 ld a,(CharCount) ;a = (CharCount) ld b,0 ;b = 0 ld c,a ;c = a add hl,bc ;hl += bc xor a ;a = 0 bit 4,e ;Test bit 4 de e jr z,endBlink ;Si bit 4 == 0 : Jump endBlink ld a,(CharTmp) ;a = (CharTmp) endBlink: ld (hl),a ;(hl) = a A chaque passage dans VBlank j’incrémente VBlankTimer puis j’actualise l’affichage du contenu de CharBuffer. Afin d’afficher la tile au bon emplacement, j’utilise la variable CharCount pour décaler l’adresse mémoire du background au bon endroit. Après quelques tests, le bit 4 du compteur me semble être le meilleur compris pour la vitesse de clignotement. Si il est à 0 j’affiche une tile vide, sinon j’affiche le caractère en cours. Intégration du code SHA1 Il est temps d’intégrer l’algorithme SHA1 que j’ai réalisé dans mon précédent article : Implémentation SHA1 sur GameBoy Un simple copier coller des variables et du code nécessaire au fonctionnement de l’algo et c’est déjà quasiment fini. Construction du bloc SHA1 Un point que j’avais pas implémenté et qui est nécessaire ici, c’est la génération automatique du bloc SHA1. En effet, pour fonctionner, le SHA1 fait ses opérations sur des blocs de 64 octets, mais j’ai déjà expliqué cela dans mon précédent article : Construction de la chaine à hacher (blocs SHA1) Dans le cas présent, la saisie étant limitée à 20 caractères, le bloc SHA1 est très simple à générer : processSha1: ld hl,Block ;hl = Block ld bc,CharBuffer ;bc = CharBuffer ld a,(CharCount) ;a = (CharCount) cp 0 jr z,loopBufferBlockEnd ;Si a == 0 : Jump loopBufferBlockEnd ld e,a ;e = a loopBufferBlock: ld a,(bc) ;a = (bc) ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec e ;e -= 1 jr nz,loopBufferBlock ;Si e != 0 : Jump loopBufferBlock loopBufferBlockEnd: ld a,$80 ;a = $80 ldi (hl),a ;(hl) = a, hl += 1 ld a,(CharCount) ;a = (CharCount) ld e,a ;e = a ld a,62 ;a = 62 sub e ;a -= e ld e,a ;e = a xor a ;a = 0 loopInitBlock: ldi (hl),a ;(hl) = a, hl += 1 dec e ;e -= 1 jr nz,loopInitBlock ;Si e != 0 : Jump loopInitBlock ld a,(CharCount) ;a = (CharCount) sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 ldi (hl),a ;(hl) = a, hl += 1 call sha1 ld a,1 ;a = 1 ld (DisplayHash),a ;(DisplayHash) = a ret Je copie le contenu de CharBuffer dans Block en me basant sur CharCount pour savoir combien de caractères je dois copier (sachant qu’il peut aussi y avoir 0 caractères). Puis je fini la construction du bloc avec le caractère \x80 suivi du remplissage des null bytes et enfin le dernier caractère représentant la longueur de la chaine. Après avoir appelé le calcul du sha1 je définit ma variable DisplayHash à 1 afin de déclencher l’affichage lors du prochain VBlank. Affichage du hash On peut désormais passer à l’affichage du hash SHA1. Puisqu’on doit manipuler la mémoire vidéo il faut faire cela dans le VBlank, ce qui implique de prendre en compte la limitation de 4560 cycles comme expliqué dans le chapitre Interruption V-Blank. ld a,(DisplayHash) ;a = (DisplayHash) cp 1 jr nz,tryDisplayHash ;Si a != 1 : Jump tryDisplayHash inc a ;a += 1 ld (DisplayHash),a ;(DisplayHash) = a ld hl,$9860 ;hl = $9860 ld d,20 ;d = 20 xor a ;a = 0 loopCleanText: ldi (hl),a ;(hl) = a dec d ;d -= 1 jr nz,loopCleanText ld hl,$9860 ;hl = $9860 ld bc,CharBuffer ;bc = CharBuffer ld a,(CharCount) ;a = (CharCount) cp 0 jr z,displayHashEnd ;Si a == 0 : Jump displayHashEnd ld d,a ;d = a loopDisplayText: ld a,(bc) ;a = (bc) ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec d ;d -= 1 jr nz,loopDisplayText ;Si d != 0 : Jump loopDisplayText jr displayHashEnd ;Jump displayHashEnd tryDisplayHash: cp 2 jr nz,displayHashEnd ;Si a != 2 : Jump displayHashEnd ld hl,$98C0 ;hl = $98C0 ld bc,StateA ;bc = StateA ld d,4 ;d = 4 ld e,5 ;e = 5 jr loopDisplayHash ;Jump loopDisplayHash loopDisplayHash2: push bc ;Stack bc ld d,4 ;d = 4 ld bc,24 ;bc = 24 add hl,bc ;hl += bc pop bc ;UnStack bc loopDisplayHash: ld a,(bc) ;a = (bc) srl a ;a &gt;&gt;= 1 srl a ;a &gt;&gt;= 1 srl a ;a &gt;&gt;= 1 srl a ;a &gt;&gt;= 1 cp 10 jr c,displayHashHex1 ;Si a &lt; 10 : Jump displayHashHex1 add 7 ;a += 7 displayHashHex1: add $30 ;a += 48 ldi (hl),a ;(hl) = a, hl += 1 ld a,(bc) ;a = (bc) and $0F ;a &amp;= 15 cp 10 jr c,displayHashHex2 ;Si a &lt; 10 : Jump displayHashHex2 add 7 ;a += 7 displayHashHex2: add $30 ;a += 48 ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec d ;d -= 1 jr nz,loopDisplayHash ;Si d != 0 : Jump loopDisplayHash dec e ;e -= 1 jr nz,loopDisplayHash2 ;Si e != 0 : Jump loopDisplayHash2 xor a ;a = 0 ld (DisplayHash),a ;(DisplayHash) = a jr endVBlank ;Jump endVBlank displayHashEnd: Afin de séparer l’affichage en plusieurs parties (pour ne pas dépasser le nombre de cycles) j’utilise la variable DisplayHash pour savoir quelle partie je dois afficher. Si mes calculs sont bons, je dépasse jamais la limite des 4560 cycles ! Si DisplayHash est égal à 1 j’incrémente sa valeur (pour le prochain passage dans VBlank) puis je génère l’affichage du texte en commençant par remettre toutes les tiles de la ligne à 0 puis en affichant le contenu de CharBuffer. Si DisplayHash est égal à 2 alors je procède à l’affichage du hash sur 5 lignes de 4 * 2 caractères (pour une représentation hexadécimale). Je parcours donc les octets en commençant par StateA, puis tous les 4 octets je passe à la ligne suivante (les 5 variables State se suivent dans la mémoire, il suffit donc juste d’incrémenter l’adresse depuis le point de départ StateA). Pour avoir l’affichage en hexadécimal, je récupère dans un premier temps les 4 bits de poids fort (via 4 décalages vers la droite). Si la valeur est supérieure à 9 c’est qu’il s’agit d’une lettre auquel cas j’ajoute 7 en plus de 48, ainsi je fais correspondre avec le bon caractère (le décalage de 7 vient des 7 caractères entre les chiffres et les lettres dans la table ASCII). Le principe est identique pour les 4 bits de poids faible, je les récupère avec un and 0b00001111 puis je fais exactement les mêmes opérations que pour les 4 bits précédents. Pour finir, je repasse DisplayHash à 0 afin de permettre de relancer un nouveau calcul SHA1 et donc un nouvel affichage. Conclusion Au début j’avais un doute sur la nécessité de faire un article sur ce sujet. Puis quand j’ai commencé à me renseigner et à faire mes tests, j’ai trouvé ça vraiment très intéressant et il aurait été dommage de ne pas partager tout ça ! Même si ça semble très simple, il y a assez de possibilités et de subtilités pour justifier la rédaction d’un article. Comme d’habitude, il y a encore pas mal d’optimisations possibles et je suis preneur de vos propositions ! Et encore une fois, un grand merci à entropyQueen pour l’idée du projet et pour le test de mon code en conditions réelles sur sa GameBoy ! (Hé oui, je n’ai pas encore le matériel pour tester sur ma GB, je me contente de l’émulateur) Sources et inspirations Code du projet Polices d’écriture GB Mon premier article Spécifications GameBoy Blog d’entropyQueen Article de Furrtek Suite d’articles de FLOZz" />
<link rel="canonical" href="https://elrindel.github.io/suite-sha1-sur-gameboy-interface-graphique" />
<meta property="og:url" content="https://elrindel.github.io/suite-sha1-sur-gameboy-interface-graphique" />
<meta property="og:site_name" content="Elrindel/Flob Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-05-02T14:45:45+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Suite SHA1 sur GameBoy : Interface graphique" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"https://elrindel.github.io/suite-sha1-sur-gameboy-interface-graphique","headline":"Suite SHA1 sur GameBoy : Interface graphique","dateModified":"2020-05-02T14:45:45+02:00","datePublished":"2020-05-02T14:45:45+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://elrindel.github.io/suite-sha1-sur-gameboy-interface-graphique"},"description":"Cet article est la suite de mon premier article sur l’implémentation SHA1 sur Gameboy. Ici nous allons voir comment créer une interface graphique afin d’utiliser l’algorithme SHA1. L’objectif est donc de permettre la saisie d’un texte et de réaliser l’affichage du hash SHA1 pour le texte renseigné. Ecrire un texte sur GameBoy On pourrait penser qu’il s’agit d’une fonctionnalité intégrée par défaut dans la GB mais ce n’est pas le cas ! Son écran de 160x144 pixels est divisé en 360 sections de 8x8 pixels qui font chacune référence à une tile, donc nous avons un affichage de 20x18 tiles. Une tile est une image de 8x8 pixels. Chaque pixel nécessitant 2 bits afin de correspondre à l’une des 4 couleurs possibles, on se retrouve donc avec 16 octets (128 bits) par tile. Ces tiles sont chargées en mémoire dans la partie VRAM, à partir de l’adresse 0x8000 ou 0x8800 suivant le bit 4 que vous aurez définit à l’adresse 0xFF40 : Voir les spécifications Vous l’aurez peut-être déjà compris, si on veut afficher du texte, il nous faut des tiles qui correspondent aux caractères qu’on souhaite afficher ! Choisir la police d’écriture Etrangement, il s’avère un peu compliqué de trouver des packs de tiles de caractères pour GB. Après quelque recherches je suis arrivé sur ce site : Pixel Font Edit Ne souhaitant pas installer l’application, j’ai simplement récupéré les fichiers .pf présents dans l’archive d’installation, ils sont disponibles sur mon GitHub à cette adresse : GameBoy Tiles Fonts Ces fichiers .pf contiennent 256 caractères mais sous un format différent des tiles pour la GameBoy. J’ai donc préparé un petit script de conversion : #!/usr/bin/env python3 import getopt, sys def usage(): print(&quot;&quot;&quot; Usage : font.py [OPTIONS] &lt;FontFile&gt; Options : -o Output file -s Start offset -l Limit tiles (number of tiles to export) &quot;&quot;&quot;) sys.exit(2) def main(): try: opts, args = getopt.getopt(sys.argv[1:],&quot;o:s:l:h&quot;,[&quot;output&quot;, &quot;start&quot;, &quot;limit&quot;, &quot;help&quot;]) except getopt.GetoptError as error: print(error) usage() if len(args) != 1: usage() start = 0 limit = -1 out = None for opt, arg in opts: if opt in (&quot;-h&quot;, &quot;--help&quot;): usage() elif opt in (&quot;-s&quot;, &quot;--start&quot;): start = int(arg) elif opt in (&quot;-l&quot;, &quot;--limit&quot;): limit = int(arg) elif opt in (&quot;-o&quot;, &quot;--output&quot;): out = arg else: usage() if not out: usage() reader = open(args[0], &quot;rb&quot;) writer = open(out, &quot;wb&quot;) if start &gt; 0: reader.seek(start*8) while True: if limit == 0: break fontChar = reader.read(8) if not fontChar or len(fontChar) &lt; 8: break tileChar = b&#39;&#39; for y in range(0, 8): tileCharCode = 0 for x in range(0, 8): tileCharCode &lt;&lt;= 1 if (fontChar[y]&gt;&gt;(7-x))&amp;1: tileCharCode |= 1 tileChar += bytes([tileCharCode&amp;0xFF, tileCharCode&amp;0xFF]) writer.write(tileChar) limit -= 1 reader.close() writer.close() if __name__ == &quot;__main__&quot;: main() J’ai fait en sorte de pouvoir sélectionner le caractères de départ (option -s) ainsi que le nombre de caractères (option -l) afin de générer facilement les tiles dont on a besoin sans pour autant convertir les 256 caractères. Exemple d’utilisation : pftotiles.py -s 24 -l 104 -o TINYTYPE.bin TINYTYPE.pf Permet de convertir 104 caractères à partir du 25ème caractères (l’offset commence à zéro). Ajouter les tiles au programme Maintenant qu’on a notre fichier de tiles, il faut l’insérer dans le code : .ORG $0800 tiles: .INCBIN &quot;TINYTYPE.bin&quot; On inclut ces données à l’adresse 0x0800. Je n’ai pas trouvé d’indications concernant cette adresse en particulier, je suppose donc qu’on peut l’inclure à n’importe quelle adresse libre dans la ROM (donc après le programme) : Répartition de la mémoire Pour ce projet, l’adresse 0x0800 est bien libre donc je vais l’utiliser. Désormais on peut charger ces tiles dans l’espace mémoire réservé aux tiles pour l’affichage (VRAM) : ld de,104*16 ;de = 1664 ld hl,$8000+$180 ;hl = $8180 ld bc,tiles ;bc = tiles loadTile: ld a,(bc) ;a = (bc) ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec de ;de -= 1 ld a,e ;a = e or d ;a |= b jr nz,loadTile ;Si a != 0 : Jump loadTile Lorsque j’ai généré mon fichier de tiles (voir le chapitre précédent) j’ai limité à 104 caractères, chaque tile faisant 16 octets, c’est pourquoi je charge 1664 octets. Concernant l’adresse de départ (0x8180), l’explication est très similaire. Lors de la génération des tiles j’ai décidé de commencer au 25ème caractère (donc un offset de 24), ce qui fait un décalage de 24x16 octets (384 = 0x180). Voir le chapitre suivant pour plus de détails sur ce placement ! Utiliser directement une chaine de caractères ! Comme on l’a vu, sur la GB les caractères sont des tiles qu’on doit charger nous même en mémoire. On peut donc les ranger comme on veut ! La meilleure solution pour faciliter au maximum l’utilisation de ces tiles est donc de les faire correspondre à l’ordre qu’on a l’habitude de manipuler en informatique, c’est à dire l’ASCII ! Ca tombe bien puisque c’est déjà l’ordre des caractères dans les polices d’écriture 8x8 que nous avons vu ci-dessus. Chaque tile possède un numéro, on peut donc faire coïncider ce numéro à la valeur ASCII du caractère. Mon caractère de référence (mon point de départ) est l’espace (\\x20), les caractères précédents étants moins facilement identifiables. On doit donc placer la tile du caractère espace en position 0x20. Les tiles commencent à l’adresse 0x8000 et chaque tile occupe 16 octets. L’adresse de la tile 0x20 est donc 0x8000 + 16 * 0x20 ce qui fait 0x8200. On sait à quelle adresse placer le caractères espace, mais nous avons d’autres tiles avant l’espace dans le fichier que nous avons généré. Il suffit donc de soustraire ces tiles à l’adresse pour savoir à partir de quelle espace mémoire il faudra insérer nos tiles. J’ai 8 caractères avant l’espace dans mon fichier, je dois donc retirer 8 * 16 octets à l’adresse de l’espace : 0x8200 - 8 * 16 = 0x8180 Maintenant que nos tiles sont bien placées en mémoire, nous pouvons stocker nos chaines de caractères directement dans la ROM tout comme on l’a fait précédemment pour le fichier des tiles : .ORG $0800 tiles: .INCBIN &quot;TINYTYPE.bin&quot; strText: .DB &quot;Text :&quot; strHash: .DB &quot;SHA1 :&quot; strPressUpDown: .DB $18, &quot;/&quot;, $19, &quot; : Change char&quot; strPressA: .DB &quot;A : Select char&quot; strPressB: .DB &quot;B : Deselect char&quot; strPressStart: .DB &quot;Press START to hash&quot; J’utilise .DB pour définir mes textes, et dans le cas des caractères spéciaux j’ai préféré utiliser le code hexa directement (pour les flèches up et down dans strPressUpDown). Je peux désormais atteindre mes chaines de caractères facilement dans mon code en utilisant les labels ! Comment afficher les tiles à l’écran L’affichage est directement lié au contenu des espaces mémoire des 3 différentes couches graphiques (Background, Window, Sprites à voir ci-dessous). Seulement il n’est pas possible d’écrire des données n’importe quand dans ces espaces mémoire ! En effet, il faut attendre que l’écran soit éteint ou que l’affichage n’utilise plus la mémoire vidéo. L’interruption V-Blank est justement là pour ça ! D’ailleurs, si vous souhaitez éteindre l’écran, il faut absolument le faire durant le V-Blank sinon vous risquez de réduire la durée de vie de votre écran ! Interruption V-Blank L’interruption V-Blank permet donc de manipuler la mémoire vidéo des 3 couches mais il faut également prendre en compte une informations importante : Vous avez seulement 4560 cycles à partir du début du V-Blank Cette limitation de 4560 cycles vient du fait que l’affichage ne va pas attendre la fin des instructions pour s’actualiser ! Ce qui a pour effet de bloquer l’accès à la mémoire durant l’affichage et donc durant le V-Blank si vous dépassez cette limite. Donc si vous dépassez cette limite sans en tenir compte et que vous tentez d’écrire dans la mémoire vidéo, vos données ne seront pas écrites et donc pas affichées/actualisées, mais votre code continuera de s’exécuter, vous constaterez donc des trous dans votre affichage ! Pour éviter cela, il faut compter les cycles ! Chaque instruction assembleur nécessite un certain nombre de cycles pour être exécutée : Voir les instructions CPU Toutes les informations sont disponibles dans les spécifications : Accessing VRAM and OAM On remarque notamment un exemple permettant d’attendre l’accès à cette mémoire. Ce qui permet par exemple d’avoir un V-Blank de plus de 4560 cycles en découpant le code en plusieurs parties tout en attendant l’accès mémoire entre chaque partie (ou même permettre d’accéder à cette mémoire en dehors de l’interruption VBlank). Dans le cas présent, nous le verrons plus bas, j’ai compté les cycles pour segmenter mon affichage en plusieurs parties. Il existe donc 3 couches pour afficher des tiles, chacune a ses particularités : Background D’une dimension de 32x32 tiles, il est principalement utilisé pour afficher le niveau du jeu grâce à sa propriété qui est d’être scrollable, c’est à dire que la zone affichée à l’écran (20x18 tiles) peut se balader sur le background. De plus, le scroll dans le background est infini puisqu’il peut tourner en boucle ! Le bas est lié au haut tout comme le bord droit est lié au bord gauche. La background est stocké à partir de l’adresse 0x9800 ou 0x9C00 suivant le bit 3 définit à l’adresse 0xFF40 : Voir les spécifications Chaque octet du background correspond au numéro de la tile à afficher. Window Cette couche vient par dessus le background. Elle possède également une dimension de 32x32 tiles (1 octet par tile) mais n’est pas scrollable comme le background. Sa propriété est de pouvoir être déplacée sur l’écran, ce qui permet par exemple de créer une boite de dialogue, un menu etc… Tout comme le background, son adresse est soit 0x9800 soit 0x9C00 dépendamment du bit 6 définit à l’adresse 0xFF40. Sprites Les sprites ont la priorité d’affichage la plus haute (ils sont affichés au dessus des autres couches). Il est possible d’afficher un maximum de 40 sprites mais avec une limitation à 10 sprites par ligne. Un sprite est composé de 1 tile (8x8 ou 8x16 suivant le flag), de coordonnées X et Y pour le positionner sur l’écran, ainsi que d’un flag correspondant à quelques options : VRAM Sprite Attribute Table (OAM) Il y a donc 4 octets par sprite (Y, X, tile, flag). Ils sont stockés à partir de l’adresse 0xFE00. On peut utiliser les sprites pour un très petit texte ou pour afficher les personnages dans le jeu par exemple. Choix de l’affichage pour ce projet Vu la quantité d’informations à afficher, j’élimine les sprites. Il reste donc background ou window. Les deux peuvent répondre au besoin ! Le background est très simple à manipuler, j’ai donc décidé de l’utiliser. Exemple d’affichage d’un texte Voici un exemple pour afficher le texte Press START to hash sur la dernière ligne de l’écran : ld hl,$9A20 ld bc,strPressStart ld d,19 loopStrPressStart: ld a,(bc) ldi (hl),a inc bc dec d jr nz,loopStrPressStart L’adresse du background commence à 0x9800, chaque ligne du background possède 32 positions, le scroll est placé en 0,0 et l’écran a 18 lignes. On peut donc calculer l’emplacement de la dernière ligne affichée à l’écran : 0x9800 + 17 * 32 = 0x9A20 (17 car on veut le début de la 18ème ligne et non le début de la 19ème, tout comme il faudrait mettre 0 pour avoir le début de la première ligne) Il faut évidemment spécifier la longueur du texte (19 dans le cas présent). Sachant que l’écran permet d’afficher 20 caractères par ligne, si le texte est plus long il faudra donc l’afficher sur plusieurs lignes. Détection des touches La lecture de l’état des boutons n’est pas compliquée mais s’avère être potentiellement instable ! En effet, seuls 4 bits (0 à 3) du registre 0xFF00 permettent de récupérer l’état des boutons. Mais la GameBoy possède 8 boutons, donc ces 4 bits sont partagés suivant l’état des bits 4 et 5 comme spécifié dans la doc : Joypad Input Notez bien que les bits 4 et 5 sont sélectionnés lorsqu’ils sont à 0 et que les bits des boutons sont également à 0 lorsque ces derniers sont appuyés. Donc, pour lire l’état des boutons, il faut procéder en deux étapes : On définit les bits 4 et 5 dans le registre 0xFF00 afin de spécifier quelles touches on souhaite lire On récupère la valeur de ce même registre (0xFF00) pour lire l’état des bits 0 à 3 correspondants aux boutons Concernant l’instabilité que j’évoquais précédemment, elle est liée au fait que l’attribution des bits correspondants aux états des boutons n’est pas instantanée ! La lecture peut donc être faussée si elle est faite trop rapidement. Dans la pratique, il est donc recommandé de lire plusieurs fois le registre 0xFF00 pour être certain de récupérer les bonnes valeurs. On peut également définir les bits 4 et 5 en amont dans le code afin d’anticiper la future lecture ! Voici un exemple pour la touche Down : ld a,%00100000 ;a = 0b00100000 ldh ($00),a ;(FF00) = a ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) bit 3,a ;Test bit 3 du registre a jr nz,notKeyDown ;Si bit 3 != 0 : Jump notKeyDown ;TODO : action key down notKeyDown: On définit les bits 4 et 5 du registre 0xFF00 pour sélectionner les touches de direction (bit 4 à 0 et bit 5 à 1). Afin de bien lire la bonne valeur, on fait plusieurs lectures du registre 0xFF00. Je n’ai pas trouvé d’informations précises sur le nombre de cycles nécessaires avant d’être vraiment certain de la lecture … à l’occasion je procèderai à quelques tests pour déterminer cela. Et enfin, on test le bit de la touche souhaitée, si il n’est pas à 0 on saute après le traitement du bouton. Dans l’optique d’optimiser le nombre d’instructions dans l’interruption VBlank, je place la gestion des touches dans la boucle principale loop ! Saisie d’un texte depuis la GameBoy Maintenant qu’on sait comment afficher du texte à l’écran et comment détecter l’appui d’une touche, on va pouvoir mettre en place le système de saisie de caractères. L’écran pouvant afficher 20 tiles sur une ligne, j’ai décidé de limiter la saisie à 20 caractères, ce qui est déjà pas mal pour tester le SHA1 ! Espace mémoire nécessaire Voici les variables nécessaires pour réaliser la saisie d’un texte : VBlankTimer DB ;Compteur VBlank pour avoir un timer synchronisé sur l&#39;affichage KeyLastDir DB ;Dernière touche de direction appuyées KeyLastBut DB ;Dernier bouton appuyé CharTmp DB ;Caractère en cours CharCount DB ;Nombre de caractères déjà sélectionnés CharBuffer DS 20 ;Enregistrement des caractères sélectionnés VBlankTimer sera nécessaire pour gérer le clignotement du caractère en cours, voir ci-dessous. Les deux variables KeyLast permettent d’éviter l’exécution en boucle des boutons, voir ci-dessous. Défilement des caractères Le défilement des caractères sera géré par les touches Up et Down : ld a,%00100000 ;a = 0b00100000 ldh ($00),a ;(FF00) = a ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ld b,a ;b = a and %00001111 ;a &amp;= 0b00001111 xor %00001111 ;a ^= 0b00001111 jr nz,notKeyDirRefresh ;Si a != 0 : Jump notKeyDirRefresh xor a ;a = 0 ld (KeyLastDir),a ;(KeyLastDir) = a jr notKeyUp ;Jump notKeyUp notKeyDirRefresh: bit 3,b ;Test bit 3 de b : Down jr nz,notKeyDown ;Si bit 3 != 0 : Jump notKeyDown ld a,(KeyLastDir) ;a = (KeyLastDir) cp 4 jr z,notKeyDown ;Si a == 4 : Jump notKeyDown ld a,4 ;a = 4 ld (KeyLastDir),a ;(KeyLastDir) = a ld a,(CharTmp) ;a = (CharTmp) dec a ;a -= 1 cp $20 jr nc,processKeyDown ;Si a &gt;= 32 : Jump processKeyDown ld a,$7E ;a = 126 processKeyDown: ld (CharTmp),a ;(CharTmp) = a notKeyDown: bit 2,b ;Test bit 2 de b : Up jr nz,notKeyUp ;Si bit 2 != 0 : Jump notKeyUp ld a,(KeyLastDir) ;a = (KeyLastDir) cp 3 jr z,notKeyUp ;Si a == 3 : Jump notKeyUp ld a,3 ;a = 3 ld (KeyLastDir),a ;(KeyLastDir) = a ld a,(CharTmp) ;a = (CharTmp) inc a ;a += 1 cp $7F jr c,processKeyUp ;Si a &lt; 127 : Jump processKeyUp ld a,$20 ;a = 32 processKeyUp: ld (CharTmp),a ;(CharTmp) = a notKeyUp: Je commence par définir puis lire le registre 0xFF00 pour les touches directionnelles (voir le chapitre précédent sur la détection des touches). Si aucune touche est appuyée je réinitialise KeyLastDir et je saute à la fin du traitement des touches. Sinon je vérifie les deux touches (Up et Down) tout en m’assurant que KeyLastDir n’a pas la valeur de la touche en cours (valeur définie arbitrairement par moi même). Cette vérification a pour but d’éviter une exécution en boucle car le CPU est bien plus rapide que nos doigts, il aura le temps de passer plusieurs fois sur la détection de la touche avant qu’on ait relâché le bouton ! Puis j’incrémente ou décrémente la valeur de CharTmp tout en m’assurant de rester dans la limite des caractères que je souhaite utiliser (en l’occurrence entre 32 et 126, soit \\x20 et \\x7E). Validation/Suppression du caractère La touche A permettra de valider la sélection du caractère en cours, et la touche B supprimera le dernier caractère et permettra de le re-définir : ld a,%00010000 ;a = 0b00010000 ldh ($00),a ;(FF00) = a ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ldh a,($00) ;a = (FF00) ld b,a ;b = a and %00001111 ;a &amp;= 0b00001111 xor %00001111 ;a ^= 0b00001111 jr nz,notKeyButRefresh ;Si a != 0 : Jump notKeyButRefresh xor a ;a = 0 ld (KeyLastBut),a ;(KeyLastBut) = a jr notKeyB ;Jump notKeyB notKeyButRefresh: bit 0,b ;Test bit 0 de b : A jr nz,notKeyA ;Si bit 0 != 0 : Jump notKeyA ld a,(KeyLastBut) ;a = (KeyLastBut) cp 1 jr z,notKeyA ;Si a == 1 : Jump notKeyA ld a,1 ;a = 1 ld (KeyLastBut),a ;(KeyLastBut) = a ld a,(CharCount) ;a = (CharCount) cp 20 jr z,notKeyA ;Si a == 20 : Jump notKeyA xor d ;d = 0 ld e,a ;e = a ld hl,CharBuffer ;hl = CharBuffer add hl,de ;hl += de inc a ;a += 1 ld (CharCount),a ;(CharCount) = a ld a,(CharTmp) ;a = (CharTmp) ld (hl),a ;(hl) = a notKeyA: bit 1,b ;Test bit 1 de b : B jr nz,notKeyB ;Si bit 1 != 0 : Jump notKeyB ld a,(KeyLastBut) ;a = (KeyLastBut) cp 2 jr z,notKeyB ;Si a == 2 : Jump notKeyB ld a,2 ;a = 2 ld (KeyLastBut),a ;(KeyLastBut) = a ld a,(CharCount) ;a = (CharCount) cp 0 jr z,notKeyB ;Si a == 0 : Jump notKeyB xor d ;d = 0 ld e,a ;e = a ld hl,CharBuffer ;hl = CharBuffer add hl,de ;hl += de dec a ;a -= 1 ld (CharCount),a ;(CharCount) = a ld a,$00 ;a = 0 ld (hl),a ;(hl) = a notKeyB: Le fonctionnement est très similaire aux touches Up et Down du chapitre précédent. La touche A va ajouter CharTmp dans CharBuffer en appliquant le décalage d’adresse pour le caractère en cours (en se basant sur CharCount), puis va incrémenter CharCount afin de passer au caractère suivant. La touche B va réinitialiser la valeur du caractère en cours dans CharBuffer puis décrémenter CharCount. Affichage et clignotement pour le caractère en cours Pour mettre en valeur le caractère en cours, une pratique courante est de le faire clignoter. Pour que le clignotement soit bien synchronisé avec la fréquence d’affichage, j’ai décidé d’ajouter un compteur qui est incrémenté à chaque exécution de VBlank. ld a,(VBlankTimer) ;a = (VBlankTimer) inc a ;a += 1 ld (VBlankTimer),a ;(VBlankTimer) = a ld e,a ;e = a ld hl,$9800 ;hl = $9800 ld d,20 ;d = 20 ld bc,CharBuffer ;bc = CharBuffer displayCharBuffer: ld a,(bc) ;a = (bc) ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec d ;d -= 1 jr nz,displayCharBuffer ;Si d != 0 : Jump displayCharBuffer ld hl,$9800 ;hl = $9800 ld a,(CharCount) ;a = (CharCount) ld b,0 ;b = 0 ld c,a ;c = a add hl,bc ;hl += bc xor a ;a = 0 bit 4,e ;Test bit 4 de e jr z,endBlink ;Si bit 4 == 0 : Jump endBlink ld a,(CharTmp) ;a = (CharTmp) endBlink: ld (hl),a ;(hl) = a A chaque passage dans VBlank j’incrémente VBlankTimer puis j’actualise l’affichage du contenu de CharBuffer. Afin d’afficher la tile au bon emplacement, j’utilise la variable CharCount pour décaler l’adresse mémoire du background au bon endroit. Après quelques tests, le bit 4 du compteur me semble être le meilleur compris pour la vitesse de clignotement. Si il est à 0 j’affiche une tile vide, sinon j’affiche le caractère en cours. Intégration du code SHA1 Il est temps d’intégrer l’algorithme SHA1 que j’ai réalisé dans mon précédent article : Implémentation SHA1 sur GameBoy Un simple copier coller des variables et du code nécessaire au fonctionnement de l’algo et c’est déjà quasiment fini. Construction du bloc SHA1 Un point que j’avais pas implémenté et qui est nécessaire ici, c’est la génération automatique du bloc SHA1. En effet, pour fonctionner, le SHA1 fait ses opérations sur des blocs de 64 octets, mais j’ai déjà expliqué cela dans mon précédent article : Construction de la chaine à hacher (blocs SHA1) Dans le cas présent, la saisie étant limitée à 20 caractères, le bloc SHA1 est très simple à générer : processSha1: ld hl,Block ;hl = Block ld bc,CharBuffer ;bc = CharBuffer ld a,(CharCount) ;a = (CharCount) cp 0 jr z,loopBufferBlockEnd ;Si a == 0 : Jump loopBufferBlockEnd ld e,a ;e = a loopBufferBlock: ld a,(bc) ;a = (bc) ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec e ;e -= 1 jr nz,loopBufferBlock ;Si e != 0 : Jump loopBufferBlock loopBufferBlockEnd: ld a,$80 ;a = $80 ldi (hl),a ;(hl) = a, hl += 1 ld a,(CharCount) ;a = (CharCount) ld e,a ;e = a ld a,62 ;a = 62 sub e ;a -= e ld e,a ;e = a xor a ;a = 0 loopInitBlock: ldi (hl),a ;(hl) = a, hl += 1 dec e ;e -= 1 jr nz,loopInitBlock ;Si e != 0 : Jump loopInitBlock ld a,(CharCount) ;a = (CharCount) sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 ldi (hl),a ;(hl) = a, hl += 1 call sha1 ld a,1 ;a = 1 ld (DisplayHash),a ;(DisplayHash) = a ret Je copie le contenu de CharBuffer dans Block en me basant sur CharCount pour savoir combien de caractères je dois copier (sachant qu’il peut aussi y avoir 0 caractères). Puis je fini la construction du bloc avec le caractère \\x80 suivi du remplissage des null bytes et enfin le dernier caractère représentant la longueur de la chaine. Après avoir appelé le calcul du sha1 je définit ma variable DisplayHash à 1 afin de déclencher l’affichage lors du prochain VBlank. Affichage du hash On peut désormais passer à l’affichage du hash SHA1. Puisqu’on doit manipuler la mémoire vidéo il faut faire cela dans le VBlank, ce qui implique de prendre en compte la limitation de 4560 cycles comme expliqué dans le chapitre Interruption V-Blank. ld a,(DisplayHash) ;a = (DisplayHash) cp 1 jr nz,tryDisplayHash ;Si a != 1 : Jump tryDisplayHash inc a ;a += 1 ld (DisplayHash),a ;(DisplayHash) = a ld hl,$9860 ;hl = $9860 ld d,20 ;d = 20 xor a ;a = 0 loopCleanText: ldi (hl),a ;(hl) = a dec d ;d -= 1 jr nz,loopCleanText ld hl,$9860 ;hl = $9860 ld bc,CharBuffer ;bc = CharBuffer ld a,(CharCount) ;a = (CharCount) cp 0 jr z,displayHashEnd ;Si a == 0 : Jump displayHashEnd ld d,a ;d = a loopDisplayText: ld a,(bc) ;a = (bc) ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec d ;d -= 1 jr nz,loopDisplayText ;Si d != 0 : Jump loopDisplayText jr displayHashEnd ;Jump displayHashEnd tryDisplayHash: cp 2 jr nz,displayHashEnd ;Si a != 2 : Jump displayHashEnd ld hl,$98C0 ;hl = $98C0 ld bc,StateA ;bc = StateA ld d,4 ;d = 4 ld e,5 ;e = 5 jr loopDisplayHash ;Jump loopDisplayHash loopDisplayHash2: push bc ;Stack bc ld d,4 ;d = 4 ld bc,24 ;bc = 24 add hl,bc ;hl += bc pop bc ;UnStack bc loopDisplayHash: ld a,(bc) ;a = (bc) srl a ;a &gt;&gt;= 1 srl a ;a &gt;&gt;= 1 srl a ;a &gt;&gt;= 1 srl a ;a &gt;&gt;= 1 cp 10 jr c,displayHashHex1 ;Si a &lt; 10 : Jump displayHashHex1 add 7 ;a += 7 displayHashHex1: add $30 ;a += 48 ldi (hl),a ;(hl) = a, hl += 1 ld a,(bc) ;a = (bc) and $0F ;a &amp;= 15 cp 10 jr c,displayHashHex2 ;Si a &lt; 10 : Jump displayHashHex2 add 7 ;a += 7 displayHashHex2: add $30 ;a += 48 ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec d ;d -= 1 jr nz,loopDisplayHash ;Si d != 0 : Jump loopDisplayHash dec e ;e -= 1 jr nz,loopDisplayHash2 ;Si e != 0 : Jump loopDisplayHash2 xor a ;a = 0 ld (DisplayHash),a ;(DisplayHash) = a jr endVBlank ;Jump endVBlank displayHashEnd: Afin de séparer l’affichage en plusieurs parties (pour ne pas dépasser le nombre de cycles) j’utilise la variable DisplayHash pour savoir quelle partie je dois afficher. Si mes calculs sont bons, je dépasse jamais la limite des 4560 cycles ! Si DisplayHash est égal à 1 j’incrémente sa valeur (pour le prochain passage dans VBlank) puis je génère l’affichage du texte en commençant par remettre toutes les tiles de la ligne à 0 puis en affichant le contenu de CharBuffer. Si DisplayHash est égal à 2 alors je procède à l’affichage du hash sur 5 lignes de 4 * 2 caractères (pour une représentation hexadécimale). Je parcours donc les octets en commençant par StateA, puis tous les 4 octets je passe à la ligne suivante (les 5 variables State se suivent dans la mémoire, il suffit donc juste d’incrémenter l’adresse depuis le point de départ StateA). Pour avoir l’affichage en hexadécimal, je récupère dans un premier temps les 4 bits de poids fort (via 4 décalages vers la droite). Si la valeur est supérieure à 9 c’est qu’il s’agit d’une lettre auquel cas j’ajoute 7 en plus de 48, ainsi je fais correspondre avec le bon caractère (le décalage de 7 vient des 7 caractères entre les chiffres et les lettres dans la table ASCII). Le principe est identique pour les 4 bits de poids faible, je les récupère avec un and 0b00001111 puis je fais exactement les mêmes opérations que pour les 4 bits précédents. Pour finir, je repasse DisplayHash à 0 afin de permettre de relancer un nouveau calcul SHA1 et donc un nouvel affichage. Conclusion Au début j’avais un doute sur la nécessité de faire un article sur ce sujet. Puis quand j’ai commencé à me renseigner et à faire mes tests, j’ai trouvé ça vraiment très intéressant et il aurait été dommage de ne pas partager tout ça ! Même si ça semble très simple, il y a assez de possibilités et de subtilités pour justifier la rédaction d’un article. Comme d’habitude, il y a encore pas mal d’optimisations possibles et je suis preneur de vos propositions ! Et encore une fois, un grand merci à entropyQueen pour l’idée du projet et pour le test de mon code en conditions réelles sur sa GameBoy ! (Hé oui, je n’ai pas encore le matériel pour tester sur ma GB, je me contente de l’émulateur) Sources et inspirations Code du projet Polices d’écriture GB Mon premier article Spécifications GameBoy Blog d’entropyQueen Article de Furrtek Suite d’articles de FLOZz","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

<link rel="shortcut icon" href="/favicon.ico" type="image/icon">
<link rel="icon" href="/favicon.ico" type="image/icon">
<!-- stylesheets -->
<link rel="stylesheet" type="text/css" href="/assets/css/base.css?v=1.0.4">
<link rel="stylesheet" type="text/css" href="/assets/css/simpleLightbox.min.css">

  <link rel="stylesheet" type="text/css" href="/assets/css/highlight-theme.css">
  <link rel="stylesheet" type="text/css" href="/assets/css/rouge-code.css">


  <link rel="stylesheet" type="text/css" href="/assets/css/post.css?v=1.0.4">

<!--[if lt IE 9]>
<script src="/assets/js/html5shiv.js"></script>
<![endif]-->

</head>

  <body>
    <header id="l-header">
    <div class="container">
        <div class="row logo">
            <div class="col-lg-7">
                <div class="blog-title"><a href="/">Elrindel/Flob</a></div>
            </div>
            <div class="col-lg-5">
              
            </div>
        </div>
        <div class="navicon">
            <i class="gg-menu"></i>
        </div>
        <div class="row navbar">
            <nav class="col-md-12">
                <ul class="row">
                    <li class="col-lg-3"><a href="/">Accueil</a></li>
                    <li class="col-lg-3"><a href="https://github.com/Elrindel/" target="_blank">Github</a></li>
                    <li class="col-lg-3"><a href="/liens">Liens</a></li>
                </ul>
            </nav>
        </div>
    </div>
</header>
    <section id="l-main">
      <div class="container">
        <div class="row">
  <div id="markdown-container" class="col-lg-9">
    <header>
      <h1 id="post-title">Suite SHA1 sur GameBoy : Interface graphique</h1>
      
      <ul class="tags clearfix">
        
      </ul>
      
      <p id="post-meta">Publié le : <b>02 May 2020</b>
        
        Catégories : <b>gameboy</b>
        
      </p>
    </header>
    <p><img src="/assets/images/sha1-gui-gb.png" alt="SHA1 GUI GameBoy" title="SHA1 GUI GameBoy" class="center" /></p>

<p>Cet article est la suite de mon premier article sur <a href="implementation-sha1-sur-gameboy" target="_blank">l’implémentation SHA1 sur Gameboy</a>.</p>

<p>Ici nous allons voir comment créer une interface graphique afin d’utiliser l’algorithme SHA1.</p>

<p>L’objectif est donc de permettre la saisie d’un texte et de réaliser l’affichage du hash SHA1 pour le texte renseigné.</p>

<h2 id="ecrire-un-texte-sur-gameboy">Ecrire un texte sur GameBoy</h2>

<p>On pourrait penser qu’il s’agit d’une fonctionnalité intégrée par défaut dans la GB mais ce n’est pas le cas !</p>

<p>Son écran de <strong>160x144 pixels</strong> est divisé en <strong>360</strong> sections de <strong>8x8 pixels</strong> qui font chacune référence à une <strong>tile</strong>, donc nous avons un affichage de <strong>20x18 tiles</strong>.</p>

<p>Une <strong>tile</strong> est une image de <strong>8x8 pixels</strong>. Chaque pixel nécessitant <strong>2 bits</strong> afin de correspondre à l’une des 4 couleurs possibles, on se retrouve donc avec <strong>16 octets (128 bits)</strong> par tile.</p>

<p>Ces <strong>tiles</strong> sont chargées en mémoire dans la partie VRAM, à partir de l’adresse <code class="language-plaintext highlighter-rouge">0x8000</code> ou <code class="language-plaintext highlighter-rouge">0x8800</code> suivant le <strong>bit 4</strong> que vous aurez définit à l’adresse <code class="language-plaintext highlighter-rouge">0xFF40</code> : <a href="specifications-gameboy#lcdcontrolregister" target="_blank">Voir les spécifications</a></p>

<p>Vous l’aurez peut-être déjà compris, si on veut afficher du texte, il nous faut des <strong>tiles</strong> qui correspondent aux caractères qu’on souhaite afficher !</p>

<h2 id="choisir-la-police-décriture">Choisir la police d’écriture</h2>

<p>Etrangement, il s’avère un peu compliqué de trouver des <strong>packs de tiles de caractères pour GB</strong>.</p>

<p>Après quelque recherches je suis arrivé sur ce site : <a href="https://www.min.at/prinz/o/software/pixelfont/" target="_blank">Pixel Font Edit</a><br />
Ne souhaitant pas installer l’application, j’ai simplement récupéré les fichiers <code class="language-plaintext highlighter-rouge">.pf</code> présents dans l’archive d’installation, ils sont disponibles sur mon GitHub à cette adresse : <a href="https://github.com/Elrindel/GameBoy-Tiles-Fonts" target="_blank">GameBoy Tiles Fonts</a></p>

<p>Ces fichiers <code class="language-plaintext highlighter-rouge">.pf</code> contiennent 256 caractères mais sous un format différent des <strong>tiles</strong> pour la GameBoy.<br />
J’ai donc préparé un petit script de conversion :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
</span>
<span class="kn">import</span> <span class="nn">getopt</span><span class="p">,</span> <span class="n">sys</span>

<span class="k">def</span> <span class="nf">usage</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"""
Usage : font.py [OPTIONS] &lt;FontFile&gt;

Options :
-o  Output file
-s  Start offset
-l  Limit tiles (number of tiles to export)
"""</span><span class="p">)</span>
    <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">opts</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">getopt</span><span class="p">.</span><span class="n">getopt</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="s">"o:s:l:h"</span><span class="p">,[</span><span class="s">"output"</span><span class="p">,</span> <span class="s">"start"</span><span class="p">,</span> <span class="s">"limit"</span><span class="p">,</span> <span class="s">"help"</span><span class="p">])</span>
    <span class="k">except</span> <span class="n">getopt</span><span class="p">.</span><span class="n">GetoptError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="n">usage</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">usage</span><span class="p">()</span>

    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">limit</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">out</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">for</span> <span class="n">opt</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">(</span><span class="s">"-h"</span><span class="p">,</span> <span class="s">"--help"</span><span class="p">):</span>
            <span class="n">usage</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">(</span><span class="s">"-s"</span><span class="p">,</span> <span class="s">"--start"</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">(</span><span class="s">"-l"</span><span class="p">,</span> <span class="s">"--limit"</span><span class="p">):</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">(</span><span class="s">"-o"</span><span class="p">,</span> <span class="s">"--output"</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">usage</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">out</span><span class="p">:</span>
        <span class="n">usage</span><span class="p">()</span>

    <span class="n">reader</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">"rb"</span><span class="p">)</span>
    <span class="n">writer</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">"wb"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">reader</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="n">start</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">fontChar</span> <span class="o">=</span> <span class="n">reader</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fontChar</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">fontChar</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">:</span>
            <span class="k">break</span>
        
        <span class="n">tileChar</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
            <span class="n">tileCharCode</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
                <span class="n">tileCharCode</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">fontChar</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">7</span><span class="o">-</span><span class="n">x</span><span class="p">))</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">tileCharCode</span> <span class="o">|=</span> <span class="mi">1</span>
            <span class="n">tileChar</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">tileCharCode</span><span class="o">&amp;</span><span class="mh">0xFF</span><span class="p">,</span> <span class="n">tileCharCode</span><span class="o">&amp;</span><span class="mh">0xFF</span><span class="p">])</span>
        <span class="n">writer</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">tileChar</span><span class="p">)</span>
        <span class="n">limit</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="n">reader</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">writer</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div></div>

<p>J’ai fait en sorte de pouvoir sélectionner le caractères de départ (option <code class="language-plaintext highlighter-rouge">-s</code>) ainsi que le nombre de caractères (option <code class="language-plaintext highlighter-rouge">-l</code>) afin de générer facilement les tiles dont on a besoin sans pour autant convertir les 256 caractères.</p>

<p>Exemple d’utilisation : <code class="language-plaintext highlighter-rouge">pftotiles.py -s 24 -l 104 -o TINYTYPE.bin TINYTYPE.pf</code><br />
<em>Permet de convertir 104 caractères à partir du 25ème caractères (l’offset commence à zéro).</em></p>

<h2 id="ajouter-les-tiles-au-programme">Ajouter les tiles au programme</h2>

<p>Maintenant qu’on a notre fichier de <strong>tiles</strong>, il faut l’insérer dans le code :</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="no">ORG</span> <span class="vg">$0800</span>
<span class="ss">tiles:
  </span><span class="o">.</span><span class="no">INCBIN</span> <span class="s2">"TINYTYPE.bin"</span>
</code></pre></div></div>

<p>On inclut ces données à l’adresse <code class="language-plaintext highlighter-rouge">0x0800</code>.<br />
Je n’ai pas trouvé d’indications concernant cette adresse en particulier, je suppose donc qu’on peut l’inclure à n’importe quelle adresse libre dans la ROM (donc après le programme) : <a href="specifications-gameboy#memorymap" target="_blank">Répartition de la mémoire</a></p>

<p>Pour ce projet, l’adresse <code class="language-plaintext highlighter-rouge">0x0800</code> est bien libre donc je vais l’utiliser.</p>

<p>Désormais on peut charger ces <strong>tiles</strong> dans l’espace mémoire réservé aux <strong>tiles</strong> pour l’affichage (VRAM) :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nf">ld</span> <span class="nv">de</span><span class="p">,</span><span class="mi">104</span><span class="o">*</span><span class="mi">16</span>                <span class="c1">;de = 1664</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="kc">$</span><span class="mi">8000</span><span class="o">+</span><span class="kc">$</span><span class="mi">180</span>            <span class="c1">;hl = $8180</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">tiles</span>                 <span class="c1">;bc = tiles</span>
<span class="nl">loadTile:</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">bc</span><span class="p">)</span>                   <span class="c1">;a = (bc)</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>                  <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">inc</span> <span class="nv">bc</span>                      <span class="c1">;bc += 1</span>
  <span class="nf">dec</span> <span class="nv">de</span>                      <span class="c1">;de -= 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="nv">e</span>                      <span class="c1">;a = e</span>
  <span class="nf">or</span> <span class="nv">d</span>                        <span class="c1">;a |= b</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">loadTile</span>              <span class="c1">;Si a != 0 : Jump loadTile</span>
</code></pre></div></div>

<p>Lorsque j’ai généré mon fichier de <strong>tiles</strong> (voir le chapitre précédent) j’ai limité à 104 caractères, chaque <strong>tile</strong> faisant 16 octets, c’est pourquoi je charge <code class="language-plaintext highlighter-rouge">1664 octets</code>.</p>

<p>Concernant l’adresse de départ (<code class="language-plaintext highlighter-rouge">0x8180</code>), l’explication est très similaire.<br />
Lors de la génération des <strong>tiles</strong> j’ai décidé de commencer au 25ème caractère (donc un offset de 24), ce qui fait un décalage de 24x16 octets (384 = <code class="language-plaintext highlighter-rouge">0x180</code>).<br />
Voir le chapitre suivant pour plus de détails sur ce placement !</p>

<h2 id="utiliser-directement-une-chaine-de-caractères-">Utiliser directement une chaine de caractères !</h2>

<p>Comme on l’a vu, sur la GB les caractères sont des <strong>tiles</strong> qu’on doit charger nous même en mémoire. On peut donc les ranger comme on veut !</p>

<p>La meilleure solution pour faciliter au maximum l’utilisation de ces <strong>tiles</strong> est donc de les faire correspondre à l’ordre qu’on a l’habitude de manipuler en informatique, c’est à dire l’<a href="https://fr.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange" target="_blank">ASCII</a> !<br />
Ca tombe bien puisque c’est déjà l’ordre des caractères dans les polices d’écriture 8x8 que nous avons vu ci-dessus.</p>

<p>Chaque <strong>tile</strong> possède un numéro, on peut donc faire coïncider ce numéro à la valeur ASCII du caractère.</p>

<p>Mon caractère de référence (mon point de départ) est l’espace (<code class="language-plaintext highlighter-rouge">\x20</code>), les caractères précédents étants moins facilement identifiables. On doit donc placer la <strong>tile</strong> du caractère espace en position <code class="language-plaintext highlighter-rouge">0x20</code>.<br />
Les <strong>tiles</strong> commencent à l’adresse <code class="language-plaintext highlighter-rouge">0x8000</code> et chaque <strong>tile</strong> occupe 16 octets. L’adresse de la <strong>tile</strong> <code class="language-plaintext highlighter-rouge">0x20</code> est donc <code class="language-plaintext highlighter-rouge">0x8000 + 16 * 0x20</code> ce qui fait <code class="language-plaintext highlighter-rouge">0x8200</code>.</p>

<p>On sait à quelle adresse placer le caractères espace, mais nous avons d’autres <strong>tiles</strong> avant l’espace dans le fichier que nous avons généré.<br />
Il suffit donc de soustraire ces <strong>tiles</strong> à l’adresse pour savoir à partir de quelle espace mémoire il faudra insérer nos <strong>tiles</strong>.</p>

<p>J’ai 8 caractères avant l’espace dans mon fichier, je dois donc retirer 8 * 16 octets à l’adresse de l’espace : <code class="language-plaintext highlighter-rouge">0x8200 - 8 * 16</code> = <code class="language-plaintext highlighter-rouge">0x8180</code></p>

<p>Maintenant que nos <strong>tiles</strong> sont bien placées en mémoire, nous pouvons stocker nos chaines de caractères directement dans la ROM tout comme on l’a fait précédemment pour le fichier des <strong>tiles</strong> :</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="no">ORG</span> <span class="vg">$0800</span>
<span class="ss">tiles:
  </span><span class="o">.</span><span class="no">INCBIN</span> <span class="s2">"TINYTYPE.bin"</span>
<span class="ss">strText:
  </span><span class="o">.</span><span class="no">DB</span> <span class="s2">"Text :"</span>
<span class="ss">strHash:
  </span><span class="o">.</span><span class="no">DB</span> <span class="s2">"SHA1 :"</span>
<span class="ss">strPressUpDown:
  </span><span class="o">.</span><span class="no">DB</span> <span class="vg">$18</span><span class="p">,</span> <span class="s2">"/"</span><span class="p">,</span> <span class="vg">$19</span><span class="p">,</span> <span class="s2">" : Change char"</span>
<span class="ss">strPressA:
  </span><span class="o">.</span><span class="no">DB</span> <span class="s2">"A   : Select char"</span>
<span class="ss">strPressB:
  </span><span class="o">.</span><span class="no">DB</span> <span class="s2">"B   : Deselect char"</span>
<span class="ss">strPressStart:
  </span><span class="o">.</span><span class="no">DB</span> <span class="s2">"Press START to hash"</span>
</code></pre></div></div>

<p>J’utilise <code class="language-plaintext highlighter-rouge">.DB</code> pour définir mes textes, et dans le cas des caractères spéciaux j’ai préféré utiliser le code hexa directement (pour les flèches up et down dans <code class="language-plaintext highlighter-rouge">strPressUpDown</code>).</p>

<p>Je peux désormais atteindre mes chaines de caractères facilement dans mon code en utilisant les labels !</p>

<h2 id="comment-afficher-les-tiles-à-lécran">Comment afficher les tiles à l’écran</h2>

<p>L’affichage est directement lié au contenu des espaces mémoire des 3 différentes couches graphiques (<a href="#background">Background</a>, <a href="#window">Window</a>, <a href="#sprites">Sprites</a> à voir ci-dessous).</p>

<p>Seulement il n’est pas possible d’écrire des données n’importe quand dans ces espaces mémoire !<br />
En effet, il faut attendre que l’écran soit éteint ou que l’affichage n’utilise plus la mémoire vidéo.<br />
L’interruption V-Blank est justement là pour ça !<br />
<strong>D’ailleurs, si vous souhaitez éteindre l’écran, il faut absolument le faire durant le V-Blank sinon vous risquez de réduire la durée de vie de votre écran !</strong></p>

<h3 id="interruption-v-blank">Interruption V-Blank</h3>

<p>L’interruption V-Blank permet donc de manipuler la mémoire vidéo des 3 couches mais il faut également prendre en compte une informations importante : <strong>Vous avez seulement 4560 cycles à partir du début du V-Blank</strong></p>

<p>Cette limitation de <strong>4560 cycles</strong> vient du fait que l’affichage ne va pas attendre la fin des instructions pour s’actualiser ! Ce qui a pour effet de bloquer l’accès à la mémoire durant l’affichage et donc durant le V-Blank si vous dépassez cette limite.<br />
Donc si vous dépassez cette limite sans en tenir compte et que vous tentez d’écrire dans la mémoire vidéo, vos données ne seront pas écrites et donc pas affichées/actualisées, mais votre code continuera de s’exécuter, vous constaterez donc des trous dans votre affichage !</p>

<p>Pour éviter cela, il faut compter les cycles ! Chaque instruction assembleur nécessite un certain nombre de cycles pour être exécutée : <a href="specifications-gameboy#cpuinstructionset" target="_blank">Voir les instructions CPU</a></p>

<p>Toutes les informations sont disponibles dans les spécifications : <a href="specifications-gameboy#accessingvramandoam" target="_blank">Accessing VRAM and OAM</a><br />
On remarque notamment un exemple permettant d’attendre l’accès à cette mémoire. Ce qui permet par exemple d’avoir un V-Blank de plus de <strong>4560 cycles</strong> en découpant le code en plusieurs parties tout en attendant l’accès mémoire entre chaque partie (ou même permettre d’accéder à cette mémoire en dehors de l’interruption VBlank).<br />
Dans le cas présent, nous le verrons plus bas, j’ai compté les cycles pour segmenter mon affichage en plusieurs parties.</p>

<p>Il existe donc 3 couches pour afficher des <strong>tiles</strong>, chacune a ses particularités :</p>

<h3 id="background">Background</h3>

<p>D’une dimension de <strong>32x32 tiles</strong>, il est principalement utilisé pour afficher le niveau du jeu grâce à sa propriété qui est d’être scrollable, c’est à dire que la zone affichée à l’écran (20x18 tiles) peut se balader sur le background.<br />
De plus, le scroll dans le background est infini puisqu’il peut tourner en boucle ! Le bas est lié au haut tout comme le bord droit est lié au bord gauche.</p>

<p>La background est stocké à partir de l’adresse <code class="language-plaintext highlighter-rouge">0x9800</code> ou <code class="language-plaintext highlighter-rouge">0x9C00</code> suivant le <strong>bit 3</strong> définit à l’adresse <code class="language-plaintext highlighter-rouge">0xFF40</code> : <a href="specifications-gameboy#lcdcontrolregister" target="_blank">Voir les spécifications</a></p>

<p>Chaque octet du background correspond au numéro de la tile à afficher.</p>

<h3 id="window">Window</h3>

<p>Cette couche vient par dessus le background. Elle possède également une dimension de <strong>32x32 tiles</strong> (1 octet par tile) mais n’est pas scrollable comme le background.<br />
Sa propriété est de pouvoir être déplacée sur l’écran, ce qui permet par exemple de créer une boite de dialogue, un menu etc…</p>

<p>Tout comme le background, son adresse est soit <code class="language-plaintext highlighter-rouge">0x9800</code> soit <code class="language-plaintext highlighter-rouge">0x9C00</code> dépendamment du <strong>bit 6</strong> définit à l’adresse <code class="language-plaintext highlighter-rouge">0xFF40</code>.</p>

<h3 id="sprites">Sprites</h3>

<p>Les <strong>sprites</strong> ont la priorité d’affichage la plus haute (ils sont affichés au dessus des autres couches).<br />
Il est possible d’afficher un maximum de 40 <strong>sprites</strong> mais avec une limitation à 10 <strong>sprites</strong> par ligne.</p>

<p>Un <strong>sprite</strong> est composé de 1 <strong>tile</strong> (8x8 ou 8x16 suivant le flag), de coordonnées X et Y pour le positionner sur l’écran, ainsi que d’un flag correspondant à quelques options : <a href="specifications-gameboy#vramspriteattributetableoam" target="_blank">VRAM Sprite Attribute Table (OAM)</a></p>

<p>Il y a donc 4 octets par <strong>sprite</strong> (Y, X, tile, flag).
Ils sont stockés à partir de l’adresse <code class="language-plaintext highlighter-rouge">0xFE00</code>.</p>

<p>On peut utiliser les sprites pour un très petit texte ou pour afficher les personnages dans le jeu par exemple.</p>

<h3 id="choix-de-laffichage-pour-ce-projet">Choix de l’affichage pour ce projet</h3>

<p>Vu la quantité d’informations à afficher, j’élimine les <strong>sprites</strong>.</p>

<p>Il reste donc <strong>background</strong> ou <strong>window</strong>. Les deux peuvent répondre au besoin !</p>

<p>Le <strong>background</strong> est très simple à manipuler, j’ai donc décidé de l’utiliser.</p>

<h3 id="exemple-daffichage-dun-texte">Exemple d’affichage d’un texte</h3>

<p>Voici un exemple pour afficher le texte <code class="language-plaintext highlighter-rouge">Press START to hash</code> sur la dernière ligne de l’écran :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="kc">$</span><span class="mi">9</span><span class="nv">A20</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">strPressStart</span>
  <span class="nf">ld</span> <span class="nv">d</span><span class="p">,</span><span class="mi">19</span>
<span class="nl">loopStrPressStart:</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">bc</span><span class="p">)</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">inc</span> <span class="nv">bc</span>
  <span class="nf">dec</span> <span class="nv">d</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">loopStrPressStart</span>
</code></pre></div></div>

<p>L’adresse du background commence à <code class="language-plaintext highlighter-rouge">0x9800</code>, chaque ligne du background possède <code class="language-plaintext highlighter-rouge">32</code> positions, le scroll est placé en <code class="language-plaintext highlighter-rouge">0,0</code> et l’écran a <code class="language-plaintext highlighter-rouge">18</code> lignes. On peut donc calculer l’emplacement de la dernière ligne affichée à l’écran : <code class="language-plaintext highlighter-rouge">0x9800 + 17 * 32</code> = <code class="language-plaintext highlighter-rouge">0x9A20</code><br />
<em>(<strong>17</strong> car on veut le début de la 18ème ligne et non le début de la 19ème, tout comme il faudrait mettre <strong>0</strong> pour avoir le début de la première ligne)</em></p>

<p>Il faut évidemment spécifier la longueur du texte (<strong>19</strong> dans le cas présent).<br />
Sachant que l’écran permet d’afficher <strong>20</strong> caractères par ligne, si le texte est plus long il faudra donc l’afficher sur plusieurs lignes.</p>

<h2 id="détection-des-touches">Détection des touches</h2>

<p>La lecture de l’état des boutons n’est pas compliquée mais s’avère être potentiellement instable !</p>

<p>En effet, seuls <strong>4 bits</strong> (0 à 3) du registre <code class="language-plaintext highlighter-rouge">0xFF00</code> permettent de récupérer l’état des boutons.<br />
Mais la GameBoy possède 8 boutons, donc ces <strong>4 bits</strong> sont partagés suivant l’état des <strong>bits 4 et 5</strong> comme spécifié dans la doc : <a href="specifications-gameboy#joypadinput" target="_blank">Joypad Input</a></p>

<p>Notez bien que les <strong>bits 4 et 5</strong> sont sélectionnés lorsqu’ils sont à <strong>0</strong> et que les bits des boutons sont également à <strong>0</strong> lorsque ces derniers sont appuyés.</p>

<p>Donc, pour lire l’état des boutons, il faut procéder en deux étapes :</p>

<ol>
  <li>On définit les bits 4 et 5 dans le registre <code class="language-plaintext highlighter-rouge">0xFF00</code> afin de spécifier quelles touches on souhaite lire</li>
  <li>On récupère la valeur de ce même registre (<code class="language-plaintext highlighter-rouge">0xFF00</code>) pour lire l’état des bits 0 à 3 correspondants aux boutons</li>
</ol>

<p>Concernant l’instabilité que j’évoquais précédemment, elle est liée au fait que l’attribution des bits correspondants aux états des boutons n’est pas instantanée !<br />
La lecture peut donc être faussée si elle est faite trop rapidement.</p>

<p>Dans la pratique, il est donc recommandé de lire plusieurs fois le registre <code class="language-plaintext highlighter-rouge">0xFF00</code> pour être certain de récupérer les bonnes valeurs. On peut également définir les bits 4 et 5 en amont dans le code afin d’anticiper la future lecture !</p>

<p>Voici un exemple pour la touche <code class="language-plaintext highlighter-rouge">Down</code> :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="o">%</span><span class="mi">00100000</span>            <span class="c1">;a = 0b00100000</span>
  <span class="nf">ldh</span> <span class="p">(</span><span class="kc">$</span><span class="mi">00</span><span class="p">),</span><span class="nv">a</span>               <span class="c1">;(FF00) = a</span>
  
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  
  <span class="nf">bit</span> <span class="mi">3</span><span class="p">,</span><span class="nv">a</span>                   <span class="c1">;Test bit 3 du registre a</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">notKeyDown</span>          <span class="c1">;Si bit 3 != 0 : Jump notKeyDown</span>
  <span class="c1">;TODO : action key down</span>
<span class="nl">notKeyDown:</span>
</code></pre></div></div>

<p>On définit les bits 4 et 5 du registre <code class="language-plaintext highlighter-rouge">0xFF00</code> pour sélectionner les touches de direction (bit 4 à 0 et bit 5 à 1).</p>

<p>Afin de bien lire la bonne valeur, on fait plusieurs lectures du registre <code class="language-plaintext highlighter-rouge">0xFF00</code>.<br />
Je n’ai pas trouvé d’informations précises sur le nombre de cycles nécessaires avant d’être vraiment certain de la lecture … à l’occasion je procèderai à quelques tests pour déterminer cela.</p>

<p>Et enfin, on test le bit de la touche souhaitée, si il n’est pas à 0 on saute après le traitement du bouton.</p>

<p><strong>Dans l’optique d’optimiser le nombre d’instructions dans l’interruption VBlank, je place la gestion des touches dans la boucle principale <code class="language-plaintext highlighter-rouge">loop</code> !</strong></p>

<h2 id="saisie-dun-texte-depuis-la-gameboy">Saisie d’un texte depuis la GameBoy</h2>

<p>Maintenant qu’on sait comment afficher du texte à l’écran et comment détecter l’appui d’une touche, on va pouvoir mettre en place le système de saisie de caractères.</p>

<p>L’écran pouvant afficher 20 tiles sur une ligne, j’ai décidé de limiter la saisie à 20 caractères, ce qui est déjà pas mal pour tester le SHA1 !</p>

<h3 id="espace-mémoire-nécessaire">Espace mémoire nécessaire</h3>

<p>Voici les variables nécessaires pour réaliser la saisie d’un texte :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">VBlankTimer</span>  <span class="nv">DB</span>         <span class="c1">;Compteur VBlank pour avoir un timer synchronisé sur l'affichage</span>
<span class="nf">KeyLastDir</span>   <span class="nv">DB</span>         <span class="c1">;Dernière touche de direction appuyées</span>
<span class="nf">KeyLastBut</span>   <span class="nv">DB</span>         <span class="c1">;Dernier bouton appuyé</span>
<span class="nf">CharTmp</span>      <span class="nv">DB</span>         <span class="c1">;Caractère en cours</span>
<span class="nf">CharCount</span>    <span class="nv">DB</span>         <span class="c1">;Nombre de caractères déjà sélectionnés</span>
<span class="nf">CharBuffer</span>   <span class="nb">DS</span> <span class="mi">20</span>      <span class="c1">;Enregistrement des caractères sélectionnés</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">VBlankTimer</code> sera nécessaire pour gérer le clignotement du caractère en cours, voir ci-dessous.</p>

<p>Les deux variables <code class="language-plaintext highlighter-rouge">KeyLast</code> permettent d’éviter l’exécution en boucle des boutons, voir ci-dessous.</p>

<h3 id="défilement-des-caractères">Défilement des caractères</h3>

<p>Le défilement des caractères sera géré par les touches <code class="language-plaintext highlighter-rouge">Up</code> et <code class="language-plaintext highlighter-rouge">Down</code> :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="o">%</span><span class="mi">00100000</span>            <span class="c1">;a = 0b00100000</span>
  <span class="nf">ldh</span> <span class="p">(</span><span class="kc">$</span><span class="mi">00</span><span class="p">),</span><span class="nv">a</span>               <span class="c1">;(FF00) = a</span>
  
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="nv">a</span>                    <span class="c1">;b = a</span>

  <span class="nf">and</span> <span class="o">%</span><span class="mi">00001111</span>             <span class="c1">;a &amp;= 0b00001111</span>
  <span class="nf">xor</span> <span class="o">%</span><span class="mi">00001111</span>             <span class="c1">;a ^= 0b00001111</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">notKeyDirRefresh</span>    <span class="c1">;Si a != 0 : Jump notKeyDirRefresh</span>
  <span class="nf">xor</span> <span class="nv">a</span>                     <span class="c1">;a = 0</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">KeyLastDir</span><span class="p">),</span><span class="nv">a</span>         <span class="c1">;(KeyLastDir) = a</span>
  <span class="nf">jr</span> <span class="nv">notKeyUp</span>               <span class="c1">;Jump notKeyUp</span>
<span class="nl">notKeyDirRefresh:</span>

  <span class="nf">bit</span> <span class="mi">3</span><span class="p">,</span><span class="nv">b</span>                   <span class="c1">;Test bit 3 de b : Down</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">notKeyDown</span>          <span class="c1">;Si bit 3 != 0 : Jump notKeyDown</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">KeyLastDir</span><span class="p">)</span>         <span class="c1">;a = (KeyLastDir)</span>
  <span class="nf">cp</span> <span class="mi">4</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nv">notKeyDown</span>           <span class="c1">;Si a == 4 : Jump notKeyDown</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="mi">4</span>                    <span class="c1">;a = 4</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">KeyLastDir</span><span class="p">),</span><span class="nv">a</span>         <span class="c1">;(KeyLastDir) = a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nb">Ch</span><span class="nv">arTmp</span><span class="p">)</span>            <span class="c1">;a = (CharTmp)</span>
  <span class="nf">dec</span> <span class="nv">a</span>                     <span class="c1">;a -= 1</span>
  <span class="nf">cp</span> <span class="kc">$</span><span class="mi">20</span>
  <span class="nf">jr</span> <span class="nv">nc</span><span class="p">,</span><span class="nv">processKeyDown</span>      <span class="c1">;Si a &gt;= 32 : Jump processKeyDown</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">7</span><span class="nv">E</span>                  <span class="c1">;a = 126</span>
<span class="nl">processKeyDown:</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nb">Ch</span><span class="nv">arTmp</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(CharTmp) = a</span>
<span class="nl">notKeyDown:</span>

  <span class="nf">bit</span> <span class="mi">2</span><span class="p">,</span><span class="nv">b</span>                   <span class="c1">;Test bit 2 de b : Up</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">notKeyUp</span>            <span class="c1">;Si bit 2 != 0 : Jump notKeyUp</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">KeyLastDir</span><span class="p">)</span>         <span class="c1">;a = (KeyLastDir)</span>
  <span class="nf">cp</span> <span class="mi">3</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nv">notKeyUp</span>             <span class="c1">;Si a == 3 : Jump notKeyUp</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="mi">3</span>                    <span class="c1">;a = 3</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">KeyLastDir</span><span class="p">),</span><span class="nv">a</span>         <span class="c1">;(KeyLastDir) = a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nb">Ch</span><span class="nv">arTmp</span><span class="p">)</span>            <span class="c1">;a = (CharTmp)</span>
  <span class="nf">inc</span> <span class="nv">a</span>                     <span class="c1">;a += 1</span>
  <span class="nf">cp</span> <span class="kc">$</span><span class="mi">7</span><span class="nv">F</span>
  <span class="nf">jr</span> <span class="nv">c</span><span class="p">,</span><span class="nv">processKeyUp</span>         <span class="c1">;Si a &lt; 127 : Jump processKeyUp</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">20</span>                  <span class="c1">;a = 32</span>
<span class="nl">processKeyUp:</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nb">Ch</span><span class="nv">arTmp</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(CharTmp) = a</span>
<span class="nl">notKeyUp:</span>
</code></pre></div></div>

<p>Je commence par définir puis lire le registre <code class="language-plaintext highlighter-rouge">0xFF00</code> pour les touches directionnelles (voir le chapitre précédent sur la détection des touches).</p>

<p>Si aucune touche est appuyée je réinitialise <code class="language-plaintext highlighter-rouge">KeyLastDir</code> et je saute à la fin du traitement des touches.<br />
Sinon je vérifie les deux touches (Up et Down) tout en m’assurant que <code class="language-plaintext highlighter-rouge">KeyLastDir</code> n’a pas la valeur de la touche en cours (valeur définie arbitrairement par moi même).<br />
Cette vérification a pour but d’éviter une exécution en boucle car le CPU est bien plus rapide que nos doigts, il aura le temps de passer plusieurs fois sur la détection de la touche avant qu’on ait relâché le bouton !</p>

<p>Puis j’incrémente ou décrémente la valeur de <code class="language-plaintext highlighter-rouge">CharTmp</code> tout en m’assurant de rester dans la limite des caractères que je souhaite utiliser (en l’occurrence entre 32 et 126, soit <code class="language-plaintext highlighter-rouge">\x20</code> et <code class="language-plaintext highlighter-rouge">\x7E</code>).</p>

<h3 id="validationsuppression-du-caractère">Validation/Suppression du caractère</h3>

<p>La touche <code class="language-plaintext highlighter-rouge">A</code> permettra de valider la sélection du caractère en cours, et la touche <code class="language-plaintext highlighter-rouge">B</code> supprimera le dernier caractère et permettra de le re-définir :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="o">%</span><span class="mi">00010000</span>            <span class="c1">;a = 0b00010000</span>
  <span class="nf">ldh</span> <span class="p">(</span><span class="kc">$</span><span class="mi">00</span><span class="p">),</span><span class="nv">a</span>               <span class="c1">;(FF00) = a</span>
  
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ldh</span> <span class="nv">a</span><span class="p">,(</span><span class="kc">$</span><span class="mi">00</span><span class="p">)</span>               <span class="c1">;a = (FF00)</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="nv">a</span>                    <span class="c1">;b = a</span>

  <span class="nf">and</span> <span class="o">%</span><span class="mi">00001111</span>             <span class="c1">;a &amp;= 0b00001111</span>
  <span class="nf">xor</span> <span class="o">%</span><span class="mi">00001111</span>             <span class="c1">;a ^= 0b00001111</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">notKeyButRefresh</span>    <span class="c1">;Si a != 0 : Jump notKeyButRefresh</span>
  <span class="nf">xor</span> <span class="nv">a</span>                     <span class="c1">;a = 0</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">KeyLastBut</span><span class="p">),</span><span class="nv">a</span>         <span class="c1">;(KeyLastBut) = a</span>
  <span class="nf">jr</span> <span class="nv">notKeyB</span>                <span class="c1">;Jump notKeyB</span>
<span class="nl">notKeyButRefresh:</span>

  <span class="nf">bit</span> <span class="mi">0</span><span class="p">,</span><span class="nv">b</span>                   <span class="c1">;Test bit 0 de b : A</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">notKeyA</span>             <span class="c1">;Si bit 0 != 0 : Jump notKeyA</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">KeyLastBut</span><span class="p">)</span>         <span class="c1">;a = (KeyLastBut)</span>
  <span class="nf">cp</span> <span class="mi">1</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nv">notKeyA</span>              <span class="c1">;Si a == 1 : Jump notKeyA</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="mi">1</span>                    <span class="c1">;a = 1</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">KeyLastBut</span><span class="p">),</span><span class="nv">a</span>         <span class="c1">;(KeyLastBut) = a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nb">Ch</span><span class="nv">arCount</span><span class="p">)</span>          <span class="c1">;a = (CharCount)</span>
  <span class="nf">cp</span> <span class="mi">20</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nv">notKeyA</span>              <span class="c1">;Si a == 20 : Jump notKeyA</span>
  <span class="nf">xor</span> <span class="nv">d</span>                     <span class="c1">;d = 0</span>
  <span class="nf">ld</span> <span class="nv">e</span><span class="p">,</span><span class="nv">a</span>                    <span class="c1">;e = a</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">Ch</span><span class="nv">arBuffer</span>          <span class="c1">;hl = CharBuffer</span>
  <span class="nf">add</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">de</span>                 <span class="c1">;hl += de</span>
  <span class="nf">inc</span> <span class="nv">a</span>                     <span class="c1">;a += 1</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nb">Ch</span><span class="nv">arCount</span><span class="p">),</span><span class="nv">a</span>          <span class="c1">;(CharCount) = a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nb">Ch</span><span class="nv">arTmp</span><span class="p">)</span>            <span class="c1">;a = (CharTmp)</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>                 <span class="c1">;(hl) = a</span>
<span class="nl">notKeyA:</span>

  <span class="nf">bit</span> <span class="mi">1</span><span class="p">,</span><span class="nv">b</span>                   <span class="c1">;Test bit 1 de b : B</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">notKeyB</span>             <span class="c1">;Si bit 1 != 0 : Jump notKeyB</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">KeyLastBut</span><span class="p">)</span>         <span class="c1">;a = (KeyLastBut)</span>
  <span class="nf">cp</span> <span class="mi">2</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nv">notKeyB</span>              <span class="c1">;Si a == 2 : Jump notKeyB</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="mi">2</span>                    <span class="c1">;a = 2</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">KeyLastBut</span><span class="p">),</span><span class="nv">a</span>         <span class="c1">;(KeyLastBut) = a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nb">Ch</span><span class="nv">arCount</span><span class="p">)</span>          <span class="c1">;a = (CharCount)</span>
  <span class="nf">cp</span> <span class="mi">0</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nv">notKeyB</span>              <span class="c1">;Si a == 0 : Jump notKeyB</span>
  <span class="nf">xor</span> <span class="nv">d</span>                     <span class="c1">;d = 0</span>
  <span class="nf">ld</span> <span class="nv">e</span><span class="p">,</span><span class="nv">a</span>                    <span class="c1">;e = a</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">Ch</span><span class="nv">arBuffer</span>          <span class="c1">;hl = CharBuffer</span>
  <span class="nf">add</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">de</span>                 <span class="c1">;hl += de</span>
  <span class="nf">dec</span> <span class="nv">a</span>                     <span class="c1">;a -= 1</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nb">Ch</span><span class="nv">arCount</span><span class="p">),</span><span class="nv">a</span>          <span class="c1">;(CharCount) = a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">00</span>                  <span class="c1">;a = 0</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>                 <span class="c1">;(hl) = a</span>
<span class="nl">notKeyB:</span>
</code></pre></div></div>

<p>Le fonctionnement est très similaire aux touches <code class="language-plaintext highlighter-rouge">Up</code> et <code class="language-plaintext highlighter-rouge">Down</code> du chapitre précédent.</p>

<p>La touche <code class="language-plaintext highlighter-rouge">A</code> va ajouter <code class="language-plaintext highlighter-rouge">CharTmp</code> dans <code class="language-plaintext highlighter-rouge">CharBuffer</code> en appliquant le décalage d’adresse pour le caractère en cours (en se basant sur <code class="language-plaintext highlighter-rouge">CharCount</code>), puis va incrémenter <code class="language-plaintext highlighter-rouge">CharCount</code> afin de passer au caractère suivant.</p>

<p>La touche <code class="language-plaintext highlighter-rouge">B</code> va réinitialiser la valeur du caractère en cours dans <code class="language-plaintext highlighter-rouge">CharBuffer</code> puis décrémenter <code class="language-plaintext highlighter-rouge">CharCount</code>.</p>

<h3 id="affichage-et-clignotement-pour-le-caractère-en-cours">Affichage et clignotement pour le caractère en cours</h3>

<p>Pour mettre en valeur le caractère en cours, une pratique courante est de le faire clignoter.<br />
Pour que le clignotement soit bien synchronisé avec la fréquence d’affichage, j’ai décidé d’ajouter un compteur qui est incrémenté à chaque exécution de VBlank.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">VBlankTimer</span><span class="p">)</span>        <span class="c1">;a = (VBlankTimer)</span>
  <span class="nf">inc</span> <span class="nv">a</span>                     <span class="c1">;a += 1</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">VBlankTimer</span><span class="p">),</span><span class="nv">a</span>        <span class="c1">;(VBlankTimer) = a</span>
  <span class="nf">ld</span> <span class="nv">e</span><span class="p">,</span><span class="nv">a</span>                    <span class="c1">;e = a</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="kc">$</span><span class="mi">9800</span>               <span class="c1">;hl = $9800</span>
  <span class="nf">ld</span> <span class="nv">d</span><span class="p">,</span><span class="mi">20</span>                   <span class="c1">;d = 20</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nb">Ch</span><span class="nv">arBuffer</span>          <span class="c1">;bc = CharBuffer</span>
<span class="nl">displayCharBuffer:</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">bc</span><span class="p">)</span>                 <span class="c1">;a = (bc)</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>                <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">inc</span> <span class="nv">bc</span>                    <span class="c1">;bc += 1</span>
  <span class="nf">dec</span> <span class="nv">d</span>                     <span class="c1">;d -= 1</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nb">disp</span><span class="nv">layCharBuffer</span>   <span class="c1">;Si d != 0 : Jump displayCharBuffer</span>

  
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="kc">$</span><span class="mi">9800</span>               <span class="c1">;hl = $9800</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nb">Ch</span><span class="nv">arCount</span><span class="p">)</span>          <span class="c1">;a = (CharCount)</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="mi">0</span>                    <span class="c1">;b = 0</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,</span><span class="nv">a</span>                    <span class="c1">;c = a</span>
  <span class="nf">add</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">bc</span>                 <span class="c1">;hl += bc</span>

  <span class="nf">xor</span> <span class="nv">a</span>                     <span class="c1">;a = 0</span>
  <span class="nf">bit</span> <span class="mi">4</span><span class="p">,</span><span class="nv">e</span>                   <span class="c1">;Test bit 4 de e</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nv">endBlink</span>             <span class="c1">;Si bit 4 == 0 : Jump endBlink</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nb">Ch</span><span class="nv">arTmp</span><span class="p">)</span>            <span class="c1">;a = (CharTmp)</span>
<span class="nl">endBlink:</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>                 <span class="c1">;(hl) = a</span>
</code></pre></div></div>

<p>A chaque passage dans VBlank j’incrémente <code class="language-plaintext highlighter-rouge">VBlankTimer</code> puis j’actualise l’affichage du contenu de <code class="language-plaintext highlighter-rouge">CharBuffer</code>.</p>

<p>Afin d’afficher la <strong>tile</strong> au bon emplacement, j’utilise la variable <code class="language-plaintext highlighter-rouge">CharCount</code> pour décaler l’adresse mémoire du background au bon endroit.</p>

<p>Après quelques tests, le bit 4 du compteur me semble être le meilleur compris pour la vitesse de clignotement. Si il est à 0 j’affiche une <strong>tile</strong> vide, sinon j’affiche le caractère en cours.</p>

<h2 id="intégration-du-code-sha1">Intégration du code SHA1</h2>

<p>Il est temps d’intégrer l’algorithme SHA1 que j’ai réalisé dans mon précédent article : <a href="implementation-sha1-sur-gameboy" target="_blank">Implémentation SHA1 sur GameBoy</a></p>

<p>Un simple copier coller des variables et du code nécessaire au fonctionnement de l’algo et c’est déjà quasiment fini.</p>

<h3 id="construction-du-bloc-sha1">Construction du bloc SHA1</h3>

<p>Un point que j’avais pas implémenté et qui est nécessaire ici, c’est la génération automatique du bloc SHA1.<br />
En effet, pour fonctionner, le SHA1 fait ses opérations sur des blocs de 64 octets, mais j’ai déjà expliqué cela dans mon précédent article : <a href="implementation-sha1-sur-gameboy#construction-de-la-chaine-à-hacher-blocs-sha1" target="_blank">Construction de la chaine à hacher (blocs SHA1)</a></p>

<p>Dans le cas présent, la saisie étant limitée à 20 caractères, le bloc SHA1 est très simple à générer :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">processSha1:</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">Bl</span><span class="nv">ock</span>               <span class="c1">;hl = Block</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nb">Ch</span><span class="nv">arBuffer</span>          <span class="c1">;bc = CharBuffer</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nb">Ch</span><span class="nv">arCount</span><span class="p">)</span>          <span class="c1">;a = (CharCount)</span>
  <span class="nf">cp</span> <span class="mi">0</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nv">loopBufferBlockEnd</span>   <span class="c1">;Si a == 0 : Jump loopBufferBlockEnd</span>
  <span class="nf">ld</span> <span class="nv">e</span><span class="p">,</span><span class="nv">a</span>                    <span class="c1">;e = a</span>
<span class="nl">loopBufferBlock:</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">bc</span><span class="p">)</span>                 <span class="c1">;a = (bc)</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>                <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">inc</span> <span class="nv">bc</span>                    <span class="c1">;bc += 1</span>
  <span class="nf">dec</span> <span class="nv">e</span>                     <span class="c1">;e -= 1</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">loopBufferBlock</span>     <span class="c1">;Si e != 0 : Jump loopBufferBlock</span>
<span class="nl">loopBufferBlockEnd:</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">80</span>                  <span class="c1">;a = $80</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>                <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nb">Ch</span><span class="nv">arCount</span><span class="p">)</span>          <span class="c1">;a = (CharCount)</span>
  <span class="nf">ld</span> <span class="nv">e</span><span class="p">,</span><span class="nv">a</span>                    <span class="c1">;e = a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="mi">62</span>                   <span class="c1">;a = 62</span>
  <span class="nf">sub</span> <span class="nv">e</span>                     <span class="c1">;a -= e</span>
  <span class="nf">ld</span> <span class="nv">e</span><span class="p">,</span><span class="nv">a</span>                    <span class="c1">;e = a</span>
  <span class="nf">xor</span> <span class="nv">a</span>                     <span class="c1">;a = 0</span>
<span class="nl">loopInitBlock:</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>                <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">dec</span> <span class="nv">e</span>                     <span class="c1">;e -= 1</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">loopInitBlock</span>       <span class="c1">;Si e != 0 : Jump loopInitBlock</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nb">Ch</span><span class="nv">arCount</span><span class="p">)</span>          <span class="c1">;a = (CharCount)</span>
  <span class="nf">sla</span> <span class="nv">a</span>                     <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                     <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                     <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>                <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">call</span> <span class="nv">sha1</span>

  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="mi">1</span>                    <span class="c1">;a = 1</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nb">Disp</span><span class="nv">layHash</span><span class="p">),</span><span class="nv">a</span>        <span class="c1">;(DisplayHash) = a</span>

  <span class="nf">ret</span>
</code></pre></div></div>

<p>Je copie le contenu de <code class="language-plaintext highlighter-rouge">CharBuffer</code> dans <code class="language-plaintext highlighter-rouge">Block</code> en me basant sur <code class="language-plaintext highlighter-rouge">CharCount</code> pour savoir combien de caractères je dois copier (sachant qu’il peut aussi y avoir 0 caractères).</p>

<p>Puis je fini la construction du bloc avec le caractère <code class="language-plaintext highlighter-rouge">\x80</code> suivi du remplissage des <strong>null bytes</strong> et enfin le dernier caractère représentant la longueur de la chaine.</p>

<p>Après avoir appelé le calcul du <code class="language-plaintext highlighter-rouge">sha1</code> je définit ma variable <code class="language-plaintext highlighter-rouge">DisplayHash</code> à <strong>1</strong> afin de déclencher l’affichage lors du prochain VBlank.</p>

<h3 id="affichage-du-hash">Affichage du hash</h3>

<p>On peut désormais passer à l’affichage du hash SHA1.<br />
Puisqu’on doit manipuler la mémoire vidéo il faut faire cela dans le VBlank, ce qui implique de prendre en compte la limitation de <strong>4560 cycles</strong> comme expliqué dans le chapitre <a href="#interruption-v-blank">Interruption V-Blank</a>.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nb">Disp</span><span class="nv">layHash</span><span class="p">)</span>        <span class="c1">;a = (DisplayHash)</span>
  <span class="nf">cp</span> <span class="mi">1</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">tryDisplayHash</span>      <span class="c1">;Si a != 1 : Jump tryDisplayHash</span>
  <span class="nf">inc</span> <span class="nv">a</span>                     <span class="c1">;a += 1</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nb">Disp</span><span class="nv">layHash</span><span class="p">),</span><span class="nv">a</span>        <span class="c1">;(DisplayHash) = a</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="kc">$</span><span class="mi">9860</span>               <span class="c1">;hl = $9860</span>
  <span class="nf">ld</span> <span class="nv">d</span><span class="p">,</span><span class="mi">20</span>                   <span class="c1">;d = 20</span>
  <span class="nf">xor</span> <span class="nv">a</span>                     <span class="c1">;a = 0</span>
<span class="nl">loopCleanText:</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>                <span class="c1">;(hl) = a</span>
  <span class="nf">dec</span> <span class="nv">d</span>                     <span class="c1">;d -= 1</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">loopCleanText</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="kc">$</span><span class="mi">9860</span>               <span class="c1">;hl = $9860</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nb">Ch</span><span class="nv">arBuffer</span>          <span class="c1">;bc = CharBuffer</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nb">Ch</span><span class="nv">arCount</span><span class="p">)</span>          <span class="c1">;a = (CharCount)</span>
  <span class="nf">cp</span> <span class="mi">0</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nb">disp</span><span class="nv">layHashEnd</span>       <span class="c1">;Si a == 0 : Jump displayHashEnd</span>
  <span class="nf">ld</span> <span class="nv">d</span><span class="p">,</span><span class="nv">a</span>                    <span class="c1">;d = a</span>
<span class="nl">loopDisplayText:</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">bc</span><span class="p">)</span>                 <span class="c1">;a = (bc)</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>                <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">inc</span> <span class="nv">bc</span>                    <span class="c1">;bc += 1</span>
  <span class="nf">dec</span> <span class="nv">d</span>                     <span class="c1">;d -= 1</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">loopDisplayText</span>     <span class="c1">;Si d != 0 : Jump loopDisplayText</span>
  <span class="nf">jr</span> <span class="nb">disp</span><span class="nv">layHashEnd</span>         <span class="c1">;Jump displayHashEnd</span>

<span class="nl">tryDisplayHash:</span>
  <span class="nf">cp</span> <span class="mi">2</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nb">disp</span><span class="nv">layHashEnd</span>      <span class="c1">;Si a != 2 : Jump displayHashEnd</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="kc">$</span><span class="mi">98</span><span class="nv">C0</span>               <span class="c1">;hl = $98C0</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateA</span>              <span class="c1">;bc = StateA</span>
  <span class="nf">ld</span> <span class="nv">d</span><span class="p">,</span><span class="mi">4</span>                    <span class="c1">;d = 4</span>
  <span class="nf">ld</span> <span class="nv">e</span><span class="p">,</span><span class="mi">5</span>                    <span class="c1">;e = 5</span>
  <span class="nf">jr</span> <span class="nv">loopDisplayHash</span>        <span class="c1">;Jump loopDisplayHash</span>
<span class="nl">loopDisplayHash2:</span>
  <span class="nf">push</span> <span class="nv">bc</span>                   <span class="c1">;Stack bc</span>
  <span class="nf">ld</span> <span class="nv">d</span><span class="p">,</span><span class="mi">4</span>                    <span class="c1">;d = 4</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="mi">24</span>                  <span class="c1">;bc = 24</span>
  <span class="nf">add</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">bc</span>                 <span class="c1">;hl += bc</span>
  <span class="nf">pop</span> <span class="nv">bc</span>                    <span class="c1">;UnStack bc</span>
<span class="nl">loopDisplayHash:</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">bc</span><span class="p">)</span>                 <span class="c1">;a = (bc)</span>
  <span class="nf">srl</span> <span class="nv">a</span>                     <span class="c1">;a &gt;&gt;= 1</span>
  <span class="nf">srl</span> <span class="nv">a</span>                     <span class="c1">;a &gt;&gt;= 1</span>
  <span class="nf">srl</span> <span class="nv">a</span>                     <span class="c1">;a &gt;&gt;= 1</span>
  <span class="nf">srl</span> <span class="nv">a</span>                     <span class="c1">;a &gt;&gt;= 1</span>
  <span class="nf">cp</span> <span class="mi">10</span>
  <span class="nf">jr</span> <span class="nv">c</span><span class="p">,</span><span class="nb">disp</span><span class="nv">layHashHex1</span>      <span class="c1">;Si a &lt; 10 : Jump displayHashHex1</span>
  <span class="nf">add</span> <span class="mi">7</span>                     <span class="c1">;a += 7</span>
<span class="nl">displayHashHex1:</span>
  <span class="nf">add</span> <span class="kc">$</span><span class="mi">30</span>                   <span class="c1">;a += 48</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>                <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">bc</span><span class="p">)</span>                 <span class="c1">;a = (bc)</span>
  <span class="nf">and</span> <span class="kc">$</span><span class="mi">0</span><span class="nv">F</span>                   <span class="c1">;a &amp;= 15</span>
  <span class="nf">cp</span> <span class="mi">10</span>
  <span class="nf">jr</span> <span class="nv">c</span><span class="p">,</span><span class="nb">disp</span><span class="nv">layHashHex2</span>      <span class="c1">;Si a &lt; 10 : Jump displayHashHex2</span>
  <span class="nf">add</span> <span class="mi">7</span>                     <span class="c1">;a += 7</span>
<span class="nl">displayHashHex2:</span>
  <span class="nf">add</span> <span class="kc">$</span><span class="mi">30</span>                   <span class="c1">;a += 48</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>                <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">inc</span> <span class="nv">bc</span>                    <span class="c1">;bc += 1</span>
  <span class="nf">dec</span> <span class="nv">d</span>                     <span class="c1">;d -= 1</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">loopDisplayHash</span>     <span class="c1">;Si d != 0 : Jump loopDisplayHash</span>
  <span class="nf">dec</span> <span class="nv">e</span>                     <span class="c1">;e -= 1</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">loopDisplayHash2</span>    <span class="c1">;Si e != 0 : Jump loopDisplayHash2</span>

  <span class="nf">xor</span> <span class="nv">a</span>                     <span class="c1">;a = 0</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nb">Disp</span><span class="nv">layHash</span><span class="p">),</span><span class="nv">a</span>        <span class="c1">;(DisplayHash) = a</span>
  <span class="nf">jr</span> <span class="nv">endVBlank</span>              <span class="c1">;Jump endVBlank</span>
<span class="nl">displayHashEnd:</span>
</code></pre></div></div>

<p>Afin de séparer l’affichage en plusieurs parties (pour ne pas dépasser le nombre de cycles) j’utilise la variable <code class="language-plaintext highlighter-rouge">DisplayHash</code> pour savoir quelle partie je dois afficher.<br />
Si mes calculs sont bons, je dépasse jamais la limite des <strong>4560 cycles</strong> !</p>

<p>Si <code class="language-plaintext highlighter-rouge">DisplayHash</code> est égal à <strong>1</strong> j’incrémente sa valeur (pour le prochain passage dans VBlank) puis je génère l’affichage du texte en commençant par remettre toutes les tiles de la ligne à <strong>0</strong> puis en affichant le contenu de <code class="language-plaintext highlighter-rouge">CharBuffer</code>.</p>

<p>Si <code class="language-plaintext highlighter-rouge">DisplayHash</code> est égal à <strong>2</strong> alors je procède à l’affichage du hash sur <code class="language-plaintext highlighter-rouge">5</code> lignes de <code class="language-plaintext highlighter-rouge">4 * 2</code> caractères (pour une représentation hexadécimale).<br />
Je parcours donc les octets en commençant par <code class="language-plaintext highlighter-rouge">StateA</code>, puis tous les 4 octets je passe à la ligne suivante (les 5 variables <code class="language-plaintext highlighter-rouge">State</code> se suivent dans la mémoire, il suffit donc juste d’incrémenter l’adresse depuis le point de départ <code class="language-plaintext highlighter-rouge">StateA</code>).</p>

<p>Pour avoir l’affichage en hexadécimal, je récupère dans un premier temps les <strong>4 bits</strong> de poids fort (via <strong>4 décalages vers la droite</strong>).<br />
Si la valeur est supérieure à <strong>9</strong> c’est qu’il s’agit d’une lettre auquel cas j’ajoute <strong>7</strong> en plus de <strong>48</strong>, ainsi je fais correspondre avec le bon caractère (le décalage de <strong>7</strong> vient des <strong>7</strong> caractères entre les chiffres et les lettres dans la <a href="https://fr.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange" target="_blank">table ASCII</a>).</p>

<p>Le principe est identique pour les <strong>4 bits</strong> de poids faible, je les récupère avec un <code class="language-plaintext highlighter-rouge">and 0b00001111</code> puis je fais exactement les mêmes opérations que pour les 4 bits précédents.</p>

<p>Pour finir, je repasse <code class="language-plaintext highlighter-rouge">DisplayHash</code> à <strong>0</strong> afin de permettre de relancer un nouveau calcul SHA1 et donc un nouvel affichage.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Au début j’avais un doute sur la nécessité de faire un article sur ce sujet.<br />
Puis quand j’ai commencé à me renseigner et à faire mes tests, j’ai trouvé ça vraiment très intéressant et il aurait été dommage de ne pas partager tout ça !</p>

<p>Même si ça semble très simple, il y a assez de possibilités et de subtilités pour justifier la rédaction d’un article.</p>

<p>Comme d’habitude, il y a encore pas mal d’optimisations possibles et je suis preneur de vos propositions !</p>

<p>Et encore une fois, un grand merci à <a href="https://entropyqueen.github.io/" target="_blank">entropyQueen</a> pour l’idée du projet et pour le test de mon code en conditions réelles sur sa GameBoy !<br />
<em>(Hé oui, je n’ai pas encore le matériel pour tester sur ma GB, je me contente de l’émulateur)</em></p>

<h2 id="sources-et-inspirations">Sources et inspirations</h2>

<ul>
  <li><a href="https://github.com/Elrindel/SHA1-GUI-GameBoy" target="_blank">Code du projet</a></li>
  <li><a href="https://github.com/Elrindel/GameBoy-Tiles-Fonts" target="_blank">Polices d’écriture GB</a></li>
  <li><a href="implementation-sha1-sur-gameboy" target="_blank">Mon premier article</a></li>
  <li><a href="specifications-gameboy" target="_blank">Spécifications GameBoy</a></li>
  <li><a href="https://entropyqueen.github.io/" target="_blank">Blog d’entropyQueen</a></li>
  <li><a href="http://furrtek.free.fr/?a=gbasm" target="_blank">Article de Furrtek</a></li>
  <li><a href="https://blog.flozz.fr/2019/09/18/developpement-gameboy-1bis-re-hello-world/" target="_blank">Suite d’articles de FLOZz</a></li>
</ul>

  </div>
  <div id="markdown-outline" class="col-lg-3">
  </div>
  
    <div id="disqus_thread" class="pt-2 pb-4">
</div>

<script>
	var disqus_loaded = false;
	function load_disqus(){
		var disqus_target = document.getElementById('disqus_thread'),
		disqus_embed = document.createElement('script');

		if(disqus_target && !disqus_loaded){
			disqus_loaded = true;
			disqus_embed.type = 'text/javascript';
			disqus_embed.async = true;
			disqus_embed.src = '//elrindel.disqus.com/embed.js';
			document.getElementsByTagName('head')[0].appendChild(disqus_embed);
		}
	}
	function load_disqus_scroll(){
		var currentScroll = document.scrollingElement.scrollTop;
		var disqus_target = document.getElementById('disqus_thread');

		if(window.scrollY >= disqus_target.offsetTop-window.innerHeight-150){
			load_disqus();
			window.removeEventListener('scroll', load_disqus_scroll);
		}
	}
	window.addEventListener('scroll', load_disqus_scroll, false);
</script>
  
</div>
      </div>
    </section>
    
<footer id="l-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<script type="text/javascript" src="/assets/js/simpleLightbox.min.js"></script>
<script type="text/javascript" src="/assets/js/base.js?v=1.0.4"></script>

<script type="text/javascript" src="/assets/js/post.js?v=1.0.4"></script>


  </body>

</html>
