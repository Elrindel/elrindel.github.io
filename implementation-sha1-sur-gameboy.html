<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Suite à une petite discussion avec entropyQueen concernant ses projets sur GameBoy, je me suis lancé dans l’implémentation de l’algorithme de hachage SHA1 su...">
<link type="application/atom+xml" rel="alternate" href="https://elrindel.github.io/feed.xml" title="Elrindel/Flob Blog" />
<title>Implémentation SHA1 sur GameBoy | Elrindel/Flob Blog</title>
<meta property="og:title" content="Implémentation SHA1 sur GameBoy" />
<meta property="og:locale" content="fr_FR" />
<link rel="canonical" href="https://elrindel.github.io/implementation-sha1-sur-gameboy" />
<meta property="og:url" content="https://elrindel.github.io/implementation-sha1-sur-gameboy" />
<meta property="og:site_name" content="Elrindel/Flob Blog" />

<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-04-22T22:43:30+02:00" />

<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Implémentation SHA1 sur GameBoy" />
<link rel="shortcut icon" href="/favicon.ico" type="image/icon">
<link rel="icon" href="/favicon.ico" type="image/icon">
<link rel="stylesheet" type="text/css" href="/assets/css/style.css?v=1.0.4">


<link rel="stylesheet" type="text/css" href="/assets/css/highlight-theme.css">
<link rel="stylesheet" type="text/css" href="/assets/css/rouge-code.css">



</head>

<body>
    <header id="header">
    <div class="container">
        
        <h1 class="title">
            <a href="/">Elrindel/Flob</a>
        </h1>
        
        <nav>
            <ul>
                <li><a href="/">Accueil</a></li>
                <li><a href="https://github.com/Elrindel/" target="_blank">Github</a></li>
                <li><a href="/liens">Liens</a></li>
                <li><a href="/bin-dec-hex-converter">Bin Converter</a></li>
            </ul>
        </nav>
    </div>
</header>
    <section id="main">
        <div class="container sidebar">
    <article>
        <header>
            <h1>Implémentation SHA1 sur GameBoy</h1>
            <p class="metas">Publié le : <b>22 Apr 2020</b> Catégories : <b>gameboy</b></p>
        </header>
        <p>Suite à une petite discussion avec <a href="https://entropyqueen.github.io/" target="_blank">entropyQueen</a> concernant ses projets sur GameBoy, je me suis lancé dans l’implémentation de l’algorithme de hachage SHA1 sur GameBoy !</p>

<p>C’était une première pour moi puisque j’avais encore jamais fait de programmation sur GB (et très peu fait d’assembleur également). Dans cet article je vais donc vous partager mon apprentissage en essayant d’expliquer au mieux mes recherches/analyses/réflexions pour avancer sur ce projet !</p>

<p>Les sources de ce projet sont disponibles ici : <a href="https://github.com/Elrindel/SHA1-GameBoy" target="_blank">SHA1 GameBoy</a></p>

<h2 id="programmation-sur-gameboy">Programmation sur GameBoy</h2>

<p>Ma première étape a été de me renseigner sur les différentes méthodes possibles de programmation sur GB.</p>

<p>Il m’est vite apparu que la seule solution réellement intéressante est l’assembleur !</p>

<p>On trouve d’ailleurs assez facilement un certain nombre d’articles qui traitent très bien ce sujet. Dans mon cas, je me suis arrêté sur l’article de <a href="http://furrtek.free.fr/?a=gbasm" target="_blank">Furrtek</a> qui a le mérite d’être clair et assez complet pour débuter dans le domaine.</p>

<h3 id="spécifications-techniques-de-la-gameboy">Spécifications techniques de la GameBoy</h3>

<p>Il existe plusieurs versions de la documentation mais globalement le contenu est toujours le même.<br />
Afin de m’assurer de ne pas perdre ce document (comme c’est le cas avec le lien fourni par Furrtek), j’ai préféré en faire une copie ici sur mon blog : <a href="specifications-gameboy" target="_blank">Spécifications GameBoy</a></p>

<p>Ce document donne toutes les indications nécessaires pour utiliser l’ensemble des fonctionnalités de la GB !</p>

<p>Je ne rentrerai pas dans les détails (sauf si besoin pour certains points spécifiques), des articles comme celui de Furrtek font déjà très bien le travail.</p>

<p>Pour ce projet j’ai utilisé l’émulateur BGB. J’avoue ne pas avoir testé les autres étant donné que celui-ci répondait parfaitement à mes besoins.</p>

<h3 id="assembleur-wla-dx">Assembleur WLA DX</h3>

<p>Comme le suggère Furrtek dans son article, je vais utiliser l’assembleur <a href="https://github.com/vhelin/wla-dx" target="_blank">WLA-DX</a>.<br />
Suivez les instructions de compilations indiquées dans le <a href="https://github.com/vhelin/wla-dx/blob/master/README.md" target="_blank">readme</a> ou <a href="http://www.villehelin.com/wla.html" target="_blank">téléchargez une version déjà compilée</a>.</p>

<p>Pour simplifier l’utilisation, j’ai ajouté le dossier <strong>binaries</strong> à ma variable d’environnement <strong>PATH</strong>.</p>

<p>Voici un petit script que j’ai nommé <code class="language-plaintext highlighter-rouge">wla-gb-build</code> et qui permet de faciliter l’utilisation de <strong>WLA-DX</strong> (je l’ai ajouté dans le dossier <strong>binaries</strong>) :</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/sh</span>

<span class="nv">fileDir</span><span class="o">=</span><span class="si">$(</span><span class="nb">dirname</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span><span class="si">)</span>
<span class="nv">fileName</span><span class="o">=</span><span class="si">$(</span><span class="nb">basename</span> <span class="nt">--</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span><span class="si">)</span>
<span class="nv">fileName</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">fileName</span><span class="p">%.*</span><span class="k">}</span><span class="s2">"</span>

<span class="nb">echo</span> <span class="o">[</span>objects]&gt;<span class="s2">"</span><span class="k">${</span><span class="nv">fileDir</span><span class="k">}</span><span class="s2">/linkfile"</span>
<span class="nb">echo</span> <span class="k">${</span><span class="nv">fileDir</span><span class="k">}</span>/<span class="k">${</span><span class="nv">fileName</span><span class="k">}</span>.o&gt;&gt;<span class="s2">"</span><span class="k">${</span><span class="nv">fileDir</span><span class="k">}</span><span class="s2">/linkfile"</span>

<span class="o">[</span> <span class="nt">-e</span> <span class="s2">"</span><span class="k">${</span><span class="nv">fileDir</span><span class="k">}</span><span class="s2">/</span><span class="k">${</span><span class="nv">fileName</span><span class="k">}</span><span class="s2">.o"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">rm</span> <span class="s2">"</span><span class="k">${</span><span class="nv">fileDir</span><span class="k">}</span><span class="s2">/</span><span class="k">${</span><span class="nv">fileName</span><span class="k">}</span><span class="s2">.o"</span>

wla-gb <span class="nt">-o</span> <span class="s2">"</span><span class="k">${</span><span class="nv">fileDir</span><span class="k">}</span><span class="s2">/</span><span class="k">${</span><span class="nv">fileName</span><span class="k">}</span><span class="s2">.o"</span> <span class="nv">$1</span>
wlalink <span class="nt">-d</span> <span class="nt">-r</span> <span class="nt">-v</span> <span class="nt">-s</span> <span class="s2">"</span><span class="k">${</span><span class="nv">fileDir</span><span class="k">}</span><span class="s2">/linkfile"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">fileDir</span><span class="k">}</span><span class="s2">/</span><span class="k">${</span><span class="nv">fileName</span><span class="k">}</span><span class="s2">.gb"</span>
</code></pre></div></div>

<p>Ainsi il suffit d’exécuter la commande <code class="language-plaintext highlighter-rouge">wla-gb-build mon_jeu.s</code> pour obtenir le fichier <code class="language-plaintext highlighter-rouge">mon_jeu.gb</code>.</p>

<h2 id="algorithme-sha1">Algorithme SHA1</h2>

<p>Maintenant que je sais comment créer et tester des programmes GB, je peux m’attaquer à la plus grosse partie, l’algorithme SHA1 !</p>

<p>La solution qui me semble la plus évidente consiste à trouver le code de cet algorithme en C, ou même directement en assembleur x86, puis de voir comment je peux l’adapter avec les instructions disponibles en z80 (enfin, la version GB qui est légèrement différente d’un véritable z80).</p>

<p>J’ai donc trouvé mon bonheur sur ce site : <a href="https://www.nayuki.io/page/fast-sha1-hash-implementation-in-x86-assembly" target="_blank">https://www.nayuki.io/page/fast-sha1-hash-implementation-in-x86-assembly</a></p>

<p>Plus particulièrement leur implémentation en version <strong>fast</strong>.</p>

<h3 id="opérations-32-bits-sur-cpu-8-bits">Opérations 32 bits sur CPU 8 bits</h3>

<p>En étudiant un peu l’assembleur de la version <strong>fast</strong> je remarque, sans surprise, un certain nombre d’instructions basées sur une architecture 32 bits.</p>

<p>Les instructions en question sont les suivantes :</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">movl</code> Ecrit un entier 32 bits à une adresse en mémoire</li>
  <li><code class="language-plaintext highlighter-rouge">andl</code> Opération logique <strong>and</strong> entre 2 entiers 32 bits</li>
  <li><code class="language-plaintext highlighter-rouge">orl</code>  Opération logique <strong>or</strong> entre 2 entiers 32 bits</li>
  <li><code class="language-plaintext highlighter-rouge">xorl</code> Opération logique <strong>xor</strong> entre 2 entiers 32 bits</li>
  <li><code class="language-plaintext highlighter-rouge">addl</code> Additionne 2 entiers 32 bits</li>
  <li><code class="language-plaintext highlighter-rouge">roll</code> Rotation des bits vers la gauche sur un entier 32 bits (les bits qui sortent re-rentrent par la droite)</li>
</ul>

<p>Concernant l’instruction <code class="language-plaintext highlighter-rouge">bswapl</code> (qui permet d’inverser l’ordre des 4 octets d’un entier 32 bits), elle n’est pas nécessaire en z80 (pour cet algorithme en tout cas), voir l’implémentation de <code class="language-plaintext highlighter-rouge">addl</code> ci-dessous pour plus de détails.</p>

<p>Désormais il faut trouver un moyen de convertir ces instructions 32 bits pour pouvoir les utiliser sur un CPU 8 bits !</p>

<p>Afin de simplifier l’utilisation, je choisis arbitrairement que le registre <strong>BC</strong> correspond à la source, et le registre <strong>HL</strong> à la destination.</p>

<h4 id="instruction-movl">Instruction <code class="language-plaintext highlighter-rouge">movl</code></h4>

<p>Cette instruction est probablement la plus simple à réaliser puisqu’il s’agit de déplacer 4 octets d’une adresse vers une autre.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">movl:</span>                   <span class="c1">;hl=bc</span>
  <span class="nf">ld</span> <span class="nv">e</span><span class="p">,</span><span class="mi">4</span>                <span class="c1">;e = 4</span>
<span class="nl">loopmovl:</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">bc</span><span class="p">)</span>             <span class="c1">;a = (bc)</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">inc</span> <span class="nv">bc</span>                <span class="c1">;bc += 1</span>
  <span class="nf">dec</span> <span class="nv">e</span>                 <span class="c1">;e -= 1</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">loopmovl</span>        <span class="c1">;Si e != 0 : Jump loopmovl</span>
  <span class="nf">ret</span>
</code></pre></div></div>

<p>La valeur pointée par le registre <strong>BC</strong> est insérée dans le registre <strong>A</strong> qui est ensuite insérée à l’adresse pointée par le registre <strong>HL</strong>.<br />
Les adresses pointées par <strong>HL</strong> et <strong>BC</strong> sont incrémentées afin de passer à l’octet suivant. Ces opérations sont répétées 4 fois.</p>

<h4 id="instructions-andl-orl-xorl">Instructions <code class="language-plaintext highlighter-rouge">andl</code>, <code class="language-plaintext highlighter-rouge">orl</code>, <code class="language-plaintext highlighter-rouge">xorl</code></h4>

<p>Le principe est très similaire à <code class="language-plaintext highlighter-rouge">movl</code>, il faut juste réaliser une opération supplémentaire (<code class="language-plaintext highlighter-rouge">and</code>, <code class="language-plaintext highlighter-rouge">or</code>, <code class="language-plaintext highlighter-rouge">xor</code>) sur chaque octet.</p>

<p>Exemple pour l’instruction <code class="language-plaintext highlighter-rouge">and</code> :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">andl:</span>                   <span class="c1">;hl&amp;=bc</span>
  <span class="nf">ld</span> <span class="nv">e</span><span class="p">,</span><span class="mi">4</span>                <span class="c1">;e = 4</span>
<span class="nl">loopandl:</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">bc</span><span class="p">)</span>             <span class="c1">;a = (bc)</span>
  <span class="nf">and</span> <span class="p">(</span><span class="nv">hl</span><span class="p">)</span>              <span class="c1">;a &amp;= (hl)</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">inc</span> <span class="nv">bc</span>                <span class="c1">;bc += 1</span>
  <span class="nf">dec</span> <span class="nv">e</span>                 <span class="c1">;e -= 1</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">loopandl</span>        <span class="c1">;Si e != 0 : Jump loopandl</span>
  <span class="nf">ret</span>
</code></pre></div></div>

<h4 id="instruction-addl">Instruction <code class="language-plaintext highlighter-rouge">addl</code></h4>

<p>Voilà enfin un peu de challenge !! Réaliser une addition de deux entiers 32 bits avec seulement des instructions sur 8 bits.<br />
A première vue il est légitime de penser que c’est compliqué, mais en réalité ça ne l’est pas !</p>

<p>L’instruction <code class="language-plaintext highlighter-rouge">add</code> permet d’additionner deux entiers 8 bits, et si 8 bits ne suffisent pas pour stocker le résultat, alors il y aura une retenue qu’on peut intercepter via le flag <strong>c</strong> (Carry Flag) !</p>

<p>On peut donc facilement étendre l’addition à plusieurs octets en utilisant le flag <strong>c</strong> pour vérifier si il est nécessaire d’appliquer la retenue sur l’octet suivant !</p>

<p>A ce niveau il faut être cohérent sur l’ordre des octets. Le résultat ne pourra pas être le même si on va de l’octet 1 à 4 (little endian) ou de l’octet 4 à 1 (big endian). Pour simplifier et éviter d’implémenter l’instruction <code class="language-plaintext highlighter-rouge">bswapl</code> j’ai décidé de partir sur l’ordre big endian.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">addl:</span>                   <span class="c1">;hl+=bc</span>
  <span class="nf">inc</span> <span class="nv">bc</span>                <span class="c1">;bc += 1</span>
  <span class="nf">inc</span> <span class="nv">bc</span>                <span class="c1">;bc += 1</span>
  <span class="nf">inc</span> <span class="nv">bc</span>                <span class="c1">;bc += 1</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">d</span><span class="p">,</span><span class="mi">5</span>                <span class="c1">;d = 5</span>
  <span class="nf">jp</span> <span class="nv">addlstart</span>          <span class="c1">;Jump addlstart</span>
<span class="nl">addlnext:</span>
  <span class="nf">pop</span> <span class="nv">de</span>                <span class="c1">;UnStack de</span>
  <span class="nf">pop</span> <span class="nv">hl</span>                <span class="c1">;UnStack hl</span>
  <span class="nf">dec</span> <span class="nv">hl</span>                <span class="c1">;hl -= 1</span>
<span class="nl">addlstart:</span>
  <span class="nf">dec</span> <span class="nv">d</span>                 <span class="c1">;d -= 1</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nv">addlend</span>          <span class="c1">;Si d == 0 : Jump addlend</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">bc</span><span class="p">)</span>             <span class="c1">;a = (bc)</span>
  <span class="nf">dec</span> <span class="nv">bc</span>                <span class="c1">;bc -= 1</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack hl</span>
  <span class="nf">push</span> <span class="nv">de</span>               <span class="c1">;Stack de</span>
  <span class="nf">add</span> <span class="p">(</span><span class="nv">hl</span><span class="p">)</span>              <span class="c1">;a += (hl)</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>             <span class="c1">;(hl) = a</span>
  <span class="nf">jr</span> <span class="nv">nc</span><span class="p">,</span><span class="nv">addlnext</span>        <span class="c1">;Si a+(hl) &lt; 256 : Jump addlnext (si pas de retenue)</span>
<span class="nl">addlnc:</span>
  <span class="nf">dec</span> <span class="nv">d</span>                 <span class="c1">;d -= 1</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nv">addlnext</span>         <span class="c1">;Si d == 0 : Jump addlnext (si on est sur le dernier octet)</span>
  <span class="nf">dec</span> <span class="nv">hl</span>                <span class="c1">;hl -= 1</span>
  <span class="nf">inc</span> <span class="p">(</span><span class="nv">hl</span><span class="p">)</span>              <span class="c1">;(hl) += 1 (on applique la retenue)</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">addlnext</span>        <span class="c1">;Si (hl) != 0 : Jump addlnext</span>
  <span class="nf">jp</span> <span class="nv">addlnc</span>             <span class="c1">;Sinon Jump addlnc (on fait suivre la retenue sur l'octet suivant)</span>
<span class="nl">addlend:</span>
  <span class="nf">ret</span>
</code></pre></div></div>

<p>Pour commencer il faut ajouter 3 aux registres <strong>HL</strong> et <strong>BC</strong> afin de commencer le traitement sur les bons octets, puis je commence les additions octet par octet tout en appliquant bien la retenue aux octets suivants.</p>

<p>Je sauvegarde les registres <strong>HL</strong> et <strong>DE</strong> sur la pile (Stack) afin de pouvoir procéder aux éventuels applications de retenues sans pour autant perdre le compte (puisque je dois décrémenter <strong>D</strong> et <strong>HL</strong> pour gérer correctement les retenues) puis je rétablis <strong>HL</strong> et <strong>DE</strong> pour le traitement du prochain octet (<strong>addlnext</strong>).</p>

<h4 id="instruction-roll">Instruction <code class="language-plaintext highlighter-rouge">roll</code></h4>

<p>On monte encore d’un cran en terme de challenge !! Je n’ai pas encore réussi à implémenter un <code class="language-plaintext highlighter-rouge">roll</code> générique et j’ai une doute sur la pertinence de le faire étant donné la complexité d’une telle opération comparé au besoin pour ce projet.</p>

<p>En analysant l’algorithme SHA1 on constate que <code class="language-plaintext highlighter-rouge">roll</code> est utilisé seulement avec 3 décalages différents (1, 5 et 30). J’ai donc décidé de créer ces 3 <code class="language-plaintext highlighter-rouge">roll</code> différents sans chercher à faire une version générique.<br />
Pour cela j’ai posé sur papier chacun des 3 décalages afin de voir les correspondances des bits entre chaque octet, et ainsi pouvoir le retranscrire en assembleur.</p>

<p><strong>Je suis cependant curieux/preneur de toutes solutions génériques ou de toutes optimisations de mon implémentation actuelle !</strong></p>

<p>Voici le <code class="language-plaintext highlighter-rouge">roll5</code> en exemple :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">roll5:</span>                  <span class="c1">;hl=roll(bc,5)</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack hl</span>
  <span class="nf">pop</span> <span class="nv">de</span>                <span class="c1">;UnStack de = hl</span>

  <span class="nf">push</span> <span class="nv">bc</span>               <span class="c1">;Stack bc</span>
  <span class="nf">pop</span> <span class="nv">hl</span>                <span class="c1">;UnStack hl = bc</span>

  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="mi">3</span>                <span class="c1">;b = 3</span>
<span class="nl">looproll5:</span>
  <span class="nf">ldi</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>            <span class="c1">;a = (hl), hl += 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">srl</span> <span class="nv">c</span>                 <span class="c1">;c &gt;&gt;= 1</span>
  <span class="nf">srl</span> <span class="nv">c</span>                 <span class="c1">;c &gt;&gt;= 1</span>
  <span class="nf">srl</span> <span class="nv">c</span>                 <span class="c1">;c &gt;&gt;= 1</span>
  <span class="nf">or</span> <span class="nv">c</span>                  <span class="c1">;a |= c</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">de</span><span class="p">),</span><span class="nv">a</span>             <span class="c1">;(de) = a</span>
  <span class="nf">inc</span> <span class="nv">de</span>                <span class="c1">;de += 1</span>
  <span class="nf">dec</span> <span class="nv">b</span>                 <span class="c1">;b -= 1</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">looproll5</span>       <span class="c1">;Si b != 0 : Jump looproll5</span>

  <span class="nf">ldd</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>            <span class="c1">;a = (hl), hl -= 1</span>
  <span class="nf">dec</span> <span class="nv">hl</span>                <span class="c1">;hl -= 1</span>
  <span class="nf">dec</span> <span class="nv">hl</span>                <span class="c1">;hl -= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">srl</span> <span class="nv">c</span>                 <span class="c1">;c &gt;&gt;= 1</span>
  <span class="nf">srl</span> <span class="nv">c</span>                 <span class="c1">;c &gt;&gt;= 1</span>
  <span class="nf">srl</span> <span class="nv">c</span>                 <span class="c1">;c &gt;&gt;= 1</span>
  <span class="nf">or</span> <span class="nv">c</span>                  <span class="c1">;a |= c</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">de</span><span class="p">),</span><span class="nv">a</span>             <span class="c1">;(de) = a</span>

  <span class="nf">ret</span>
</code></pre></div></div>

<p>Il s’agit donc de réaliser les bons <code class="language-plaintext highlighter-rouge">shift</code> (décalages) sur les bons octets puis de faire un <code class="language-plaintext highlighter-rouge">or</code> pour fusionner les bits.</p>

<p>Le principe est identique pour les 3 <code class="language-plaintext highlighter-rouge">roll</code> (1, 5 et 30) mais avec les bons décalages et les bonnes correspondances pour chacun.</p>

<h3 id="espace-mémoire-nécessaire-variables">Espace mémoire nécessaire (variables)</h3>

<p>Voici les différentes variables qui seront nécessaires au bon fonctionnement de l’algo :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">Step</span>      <span class="nv">DB</span>            <span class="c1">;C000      : Compteur de rounds</span>
<span class="nf">StateA</span>    <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C001-C004 : SHA1 A en cours</span>
<span class="nf">StateB</span>    <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C005-C008 : SHA1 B en cours</span>
<span class="nf">StateC</span>    <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C009-C00C : SHA1 C en cours</span>
<span class="nf">StateD</span>    <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C00D-C010 : SHA1 D en cours</span>
<span class="nf">StateE</span>    <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C011-C014 : SHA1 E en cours</span>
<span class="nf">StateT</span>    <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C015-C018 : Temporaire pour les opérations sur les State</span>
<span class="nf">RollT</span>     <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C019-C01C : Temporaire pour certaines opérations </span>
<span class="nf">RoundK</span>    <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C01D-C020 : SHA1 K du round en cours</span>
<span class="nf">Block</span>     <span class="nb">DS</span> <span class="mi">64</span>         <span class="c1">;C021-C060 : SHA1 Block (message à hacher)</span>
<span class="nf">Schedule</span>  <span class="nb">DS</span> <span class="mi">64</span>         <span class="c1">;C061-C0A0 : Temporaire pour les opérations sur Block</span>
<span class="nf">InitA</span>     <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C0A1-C0A5 : Sauvegarde SHA1 A à l'initialisation</span>
<span class="nf">InitB</span>     <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C0A6-C0A9 : Sauvegarde SHA1 B à l'initialisation</span>
<span class="nf">InitC</span>     <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C0AA-C0AD : Sauvegarde SHA1 C à l'initialisation</span>
<span class="nf">InitD</span>     <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C0AE-C0B1 : Sauvegarde SHA1 D à l'initialisation</span>
<span class="nf">InitE</span>     <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C0B2-C0B5 : Sauvegarde SHA1 E à l'initialisation</span>
<span class="nf">Reg1</span>      <span class="nb">DS</span> <span class="mi">2</span>          <span class="c1">;C0B6-C0B7 : Registre 1</span>
<span class="nf">Reg2</span>      <span class="nb">DS</span> <span class="mi">2</span>          <span class="c1">;C0B8-C0B9 : Registre 2</span>
</code></pre></div></div>

<p><strong>Total :</strong> 185 octets</p>

<p>Les variables <code class="language-plaintext highlighter-rouge">StateA</code> à <code class="language-plaintext highlighter-rouge">StateE</code> contiennent le hash SHA1 en cours de calcul, le hash final sera donc dans ces variables également.<br />
Le hash correspond donc aux 20 octets de l’adresse <code class="language-plaintext highlighter-rouge">C001</code> à l’adresse <code class="language-plaintext highlighter-rouge">C014</code>.</p>

<p><code class="language-plaintext highlighter-rouge">Reg1</code> et <code class="language-plaintext highlighter-rouge">Reg2</code> permettent de combler le faible nombre de registres disponibles sur la GB (seulement 3 registres 16 bits), ils servent donc de stockage d’adresse 16 bits.<br />
Ils sont nécessaires pour gérer la rotation automatique des 5 variables <code class="language-plaintext highlighter-rouge">State</code> à chaque round (voir le chapitre suivant).<br />
Sans eux il est possible de faire cette rotation en utilisant directement la pile (stack) mais il serait alors obligatoire de désactiver les interruptions de la GameBoy afin d’éviter d’avoir une interruption au mauvais moment qui viendrait écraser certaines données sur la pile : <a href="specifications-gameboy#interrupts" target="_blank">Voir la documentation sur les interruptions</a></p>

<h3 id="initialisation-sha1">Initialisation SHA1</h3>

<p>L’initialisation SHA1 consiste simplement à définir les valeurs des 5 états (<code class="language-plaintext highlighter-rouge">StateA</code> à <code class="language-plaintext highlighter-rouge">StateE</code>), il s’agit du vecteur d’initialisation du SHA1 par défaut :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">sha1:</span>
  <span class="c1">;Init StateA = 0x67452301</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">67</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateA</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">45</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateA</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">23</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateA</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">01</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateA</span><span class="o">+</span><span class="mi">3</span><span class="p">),</span><span class="nv">a</span>

  <span class="c1">;Init StateB = 0xEFCDAB89</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">EF</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateB</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">CD</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateB</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">AB</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateB</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">89</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateB</span><span class="o">+</span><span class="mi">3</span><span class="p">),</span><span class="nv">a</span>

  <span class="c1">;Init StateC = 0x98BADCFE</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">98</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateC</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">BA</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateC</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">DC</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateC</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">FE</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateC</span><span class="o">+</span><span class="mi">3</span><span class="p">),</span><span class="nv">a</span>

  <span class="c1">;Init StateD = 0x10325476</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">10</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateD</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">32</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateD</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">54</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateD</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">76</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateD</span><span class="o">+</span><span class="mi">3</span><span class="p">),</span><span class="nv">a</span>

  <span class="c1">;Init StateE = 0xC3D2E1F0</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">C3</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateE</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">D2</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateE</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">E1</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateE</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">F0</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateE</span><span class="o">+</span><span class="mi">3</span><span class="p">),</span><span class="nv">a</span>

<span class="nl">sha1next:</span>
  <span class="nf">xor</span> <span class="nv">a</span>                 <span class="c1">;a = 0</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">Step</span><span class="p">),</span><span class="nv">a</span>           <span class="c1">;(Step) = 0</span>

  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateA</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">InitA</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;InitA = StateA</span>

  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateB</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">InitB</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;InitB = StateB</span>

  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateC</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">InitC</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;InitC = StateC</span>

  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateD</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">InitD</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;InitD = StateD</span>

  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateE</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">InitE</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;InitE = StateE</span>
</code></pre></div></div>

<p>Cet algorithme procède au calcul du hash SHA1 par blocs de <strong>64 octets</strong> (voir le chapitre sur la construction de la chaine à hacher pour plus d’informations).</p>

<p>Il peut évidemment arriver qu’on ait besoin d’obtenir le hash de chaines bien plus longues que <strong>64 octets</strong>, c’est pourquoi il y a un second point de départ qui permet de ne pas réinitialiser les états du SHA1 en cours, il s’agit de <code class="language-plaintext highlighter-rouge">sha1next</code>.</p>

<h3 id="initialisation-dun-round">Initialisation d’un round</h3>

<p>A chaque round on constate deux changements, à savoir l’incrémentation du compteur de rounds (<code class="language-plaintext highlighter-rouge">Step</code>) ainsi qu’une rotation des arguments.<br />
Pour le round <strong>0</strong>, les arguments sont dans l’ordre <code class="language-plaintext highlighter-rouge">A, B, C, D, E</code>, puis au round suivant on constate une rotation : <code class="language-plaintext highlighter-rouge">E, A, B, C, D</code>, puis <code class="language-plaintext highlighter-rouge">D, E, A, B, C</code> et ainsi de suite pour les 80 rounds.</p>

<p>Je commence donc par initialiser le tout premier ordre :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateE</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack : StateE =&gt; ArgE</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateD</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack : StateD =&gt; ArgD</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateC</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack : StateC =&gt; ArgC</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateB</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack : StateB =&gt; ArgB</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateA</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack : StateA =&gt; ArgA</span>
  <span class="nf">jp</span> <span class="nv">initRound0</span>         <span class="c1">;Jump initRound0</span>
</code></pre></div></div>

<p>J’utilise la pile afin de manipuler plus facilement ces valeurs. Le dernier entré est le premier sorti, c’est pour cela que je <code class="language-plaintext highlighter-rouge">push</code> de <code class="language-plaintext highlighter-rouge">StateE</code> à <code class="language-plaintext highlighter-rouge">StateA</code> et non l’inverse.<br />
Vu qu’il s’agit de l’ordre pour le round <strong>0</strong> je jump directement à cette étape (voir le chapitre sur le round 0 ci-dessous).</p>

<p>Ensuite Il faut donc gérer la rotation des arguments pour les prochains rounds :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">loopRound:</span>
  <span class="c1">;SP = 0</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">Reg1</span>            <span class="c1">;hl = Reg1</span>
  <span class="nf">pop</span> <span class="nv">de</span>                <span class="c1">;de = sp[0] = ArgA, sp = 2</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="nv">d</span>                <span class="c1">;a = d</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="nv">e</span>                <span class="c1">;a = e</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">pop</span> <span class="nv">de</span>                <span class="c1">;de = sp[2] = ArgB, sp = 4</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="nv">d</span>                <span class="c1">;a = d</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="nv">e</span>                <span class="c1">;a = e</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">pop</span> <span class="nv">de</span>                <span class="c1">;de = sp[4] = ArgC, sp = 6</span>
  <span class="nf">pop</span> <span class="nv">hl</span>                <span class="c1">;hl = sp[6] = ArgD, sp = 8</span>
  <span class="nf">pop</span> <span class="nv">bc</span>                <span class="c1">;bc = sp[8] = ArgE, sp = 10</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;sp = 8, sp[8] = hl = D</span>
  <span class="nf">push</span> <span class="nv">de</span>               <span class="c1">;sp = 6, sp[6] = de = C</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">Reg2</span>            <span class="c1">;hl = Reg2</span>
  <span class="nf">ld</span> <span class="nv">d</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;d = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">e</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;e = (hl)</span>
  <span class="nf">push</span> <span class="nv">de</span>               <span class="c1">;sp = 4, sp[4] = de = Reg2 = ArgB</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">Reg1</span>            <span class="c1">;hl = Reg1</span>
  <span class="nf">ld</span> <span class="nv">d</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;d = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">e</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;e = (hl)</span>
  <span class="nf">push</span> <span class="nv">de</span>               <span class="c1">;sp = 2, sp[2] = de = Reg1 = ArgA</span>
  <span class="nf">push</span> <span class="nv">bc</span>               <span class="c1">;sp = 0, sp[0] = bc = ArgE</span>

  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">Step</span><span class="p">)</span>           <span class="c1">;a = (Step)</span>
  <span class="nf">inc</span> <span class="nv">a</span>                 <span class="c1">;a += 1</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">Step</span><span class="p">),</span><span class="nv">a</span>           <span class="c1">;(Step) = a</span>

  <span class="nf">cp</span> <span class="nv">a</span><span class="p">,</span><span class="mi">16</span>
  <span class="nf">jr</span> <span class="nv">c</span><span class="p">,</span><span class="nv">loopRound0a</span>      <span class="c1">;Si Step &lt; 16: Jump loopRound0a</span>
  <span class="nf">cp</span> <span class="nv">a</span><span class="p">,</span><span class="mi">20</span>
  <span class="nf">jr</span> <span class="nv">c</span><span class="p">,</span><span class="nv">loopRound0b</span>      <span class="c1">;Si Step &lt; 20: Jump loopRound0b</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nv">initRound1</span>       <span class="c1">;Si Step == 20: Jump initRound1</span>
  <span class="nf">cp</span> <span class="nv">a</span><span class="p">,</span><span class="mi">40</span>
  <span class="nf">jr</span> <span class="nv">c</span><span class="p">,</span><span class="nv">loopRound1</span>       <span class="c1">;Si Step &lt; 40: Jump loopRound1</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nv">initRound2</span>       <span class="c1">;Si Step == 40: Jump initRound2</span>
  <span class="nf">cp</span> <span class="nv">a</span><span class="p">,</span><span class="mi">60</span>
  <span class="nf">jr</span> <span class="nv">c</span><span class="p">,</span><span class="nv">loopRound2</span>       <span class="c1">;Si Step &lt; 60: Jump loopRound2</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nv">initRound3</span>       <span class="c1">;Si Step == 60: Jump initRound3</span>
  <span class="nf">cp</span> <span class="nv">a</span><span class="p">,</span><span class="mi">80</span>
  <span class="nf">jr</span> <span class="nv">c</span><span class="p">,</span><span class="nv">loopRound3</span>       <span class="c1">;Si Step &lt; 80: Jump loopRound3</span>
  <span class="nf">jp</span> <span class="nv">loopRoundEnd</span>       <span class="c1">;Sinon Jump loopRoundEnd</span>
</code></pre></div></div>

<p>Afin de simplifier les commentaires je pars du principe que <code class="language-plaintext highlighter-rouge">SP</code> vaut 0, ce n’est évidemment pas le cas en réalité !</p>

<p>A ce niveau j’ai plusieurs possibilités pour faire la rotation.<br />
Dans un premier temps j’avais réalisé cela à base de <code class="language-plaintext highlighter-rouge">pop</code> et de <code class="language-plaintext highlighter-rouge">push</code> tout en jouant avec <code class="language-plaintext highlighter-rouge">SP</code> pour atteindre le bon emplacement. Mais cette solution n’était pas correcte car incompatible avec les interruptions GB !<br />
En effet, lors d’une interruption, la GameBoy va mettre en “pause” le code en cours d’exécution et faire l’équivalent d’un <code class="language-plaintext highlighter-rouge">call</code> vers le code de l’interruption (avec une étape en plus cependant). Cela a pour effet d’ajouter 2 adresses de retour sur la pile (pour les <code class="language-plaintext highlighter-rouge">ret</code> en fin d’interruption).<br />
De ce fait, si je tente de faire une rotation en me déplaçant directement dans la pile et qu’une interruption intervient en même temps, alors je verrai mes valeurs écrasées par ces adresses de retour.</p>

<p>Pour éviter cela, j’ai ajouté deux variables (<code class="language-plaintext highlighter-rouge">Reg1</code> et <code class="language-plaintext highlighter-rouge">Reg2</code>) qui me servent de registre tampon en complément des 3 registres 16 bits de la GB. Ainsi je peux totalement vider la pile des 5 arguments puis la reconstruire proprement sans risquer de perdre des valeurs !</p>

<p>Ensuite j’incrémente <code class="language-plaintext highlighter-rouge">Step</code> et je fais des simples comparaisons pour savoir quel round lancer.</p>

<h3 id="round-0a-et-roundtail">Round 0a et roundtail</h3>

<p>Initialisation du round <strong>0</strong> :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">initRound0:</span>
  <span class="c1">;Init RoundK ROUND0 0x5A827999</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">RoundK</span>          <span class="c1">;hl = RoundK</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">5</span><span class="nv">A</span>              <span class="c1">;a = 0x5A</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">82</span>              <span class="c1">;a = 0x82</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">79</span>              <span class="c1">;a = 0x79</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">99</span>              <span class="c1">;a = 0x99</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
<span class="nl">loopRound0a:</span>
  <span class="nf">call</span> <span class="nv">round0a</span>
  <span class="nf">jp</span> <span class="nv">loopRound</span>
<span class="nl">loopRound0b:</span>
  <span class="nf">call</span> <span class="nv">round0b</span>
  <span class="nf">jp</span> <span class="nv">loopRound</span>
</code></pre></div></div>

<p>On définit <code class="language-plaintext highlighter-rouge">RoundK</code> lors de l’initialisation du round <strong>0</strong> puis on appel <code class="language-plaintext highlighter-rouge">round0a</code> :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">round0a:</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">Step</span><span class="p">)</span>           <span class="c1">;a = (Step)</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="mi">0</span>                <span class="c1">;b = 0</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,</span><span class="nv">a</span>                <span class="c1">;c = a</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">Bl</span><span class="nv">ock</span>           <span class="c1">;hl = Block</span>
  <span class="nf">add</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">bc</span>             <span class="c1">;hl += bc : Block[Step * 4]</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack hl</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">Schedule</span>        <span class="c1">;hl = Schedule</span>
  <span class="nf">add</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">bc</span>             <span class="c1">;hl += bc : Schedule[Step * 4]</span>
  <span class="nf">pop</span> <span class="nv">bc</span>                <span class="c1">;UnStack bc = Block[Step * 4]</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack hl</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;Schedule[Step * 4] = Block[Step * 4]</span>

  <span class="nf">pop</span> <span class="nv">bc</span>                <span class="c1">;UnStack bc = Schedule[Step * 4]</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">10</span>           <span class="c1">;hl = Stack+10 = ArgE</span>
  <span class="nf">ld</span> <span class="nv">e</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;e = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">d</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;d = (hl)</span>
  <span class="nf">push</span> <span class="nv">de</span>               <span class="c1">;Stack de</span>
  <span class="nf">pop</span> <span class="nv">hl</span>                <span class="c1">;UnStack hl = de</span>
  <span class="nf">call</span> <span class="nv">addl</span>             <span class="c1">;ArgE += Schedule[Step * 4]</span>

  <span class="nf">jp</span> <span class="nv">round0</span>
</code></pre></div></div>

<p>Il n’y a pas d’instruction pour réaliser directement une multiplication sur GB, cependant, un <code class="language-plaintext highlighter-rouge">shift left</code> revient à multiplier par deux, je le fais donc deux fois afin de multiplier par 4.</p>

<p>Pour atteindre <code class="language-plaintext highlighter-rouge">ArgE</code> j’utilise le registre <code class="language-plaintext highlighter-rouge">SP</code> sachant que j’ai construit la pile juste avant, je peux donc récupérer l’argument souhaité. Voici d’ailleurs à quoi ressemble la pile à ce moment :</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SP+0</code> = Adresse de retour</li>
  <li><code class="language-plaintext highlighter-rouge">SP+2</code> = ArgA</li>
  <li><code class="language-plaintext highlighter-rouge">SP+4</code> = ArgB</li>
  <li><code class="language-plaintext highlighter-rouge">SP+6</code> = ArgC</li>
  <li><code class="language-plaintext highlighter-rouge">SP+8</code> = ArgD</li>
  <li><code class="language-plaintext highlighter-rouge">SP+10</code> = ArgE</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">round0</code> correspond à la partie commune entre <code class="language-plaintext highlighter-rouge">round0a</code> et <code class="language-plaintext highlighter-rouge">round0b</code> :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">round0:</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">6</span>            <span class="c1">;hl = Stack+6 = ArgC</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;StateT = ArgC</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">8</span>            <span class="c1">;hl = Stack+8 = ArgD</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">xorl</span>             <span class="c1">;StateT ^= ArgD</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">4</span>            <span class="c1">;hl = Stack+4 = ArgB</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">andl</span>             <span class="c1">;StateT &amp;= ArgB</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">8</span>            <span class="c1">;hl = Stack+6 = ArgD</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">xorl</span>             <span class="c1">;StateT ^= ArgD</span>

  <span class="nf">jp</span> <span class="nv">roundtail</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">round0</code> étant atteint via un <code class="language-plaintext highlighter-rouge">jump</code>, il n’y a pas d’adresse de retour en plus sur la pile, ça ne change donc pas les accès aux arguments.<br />
<code class="language-plaintext highlighter-rouge">StateT</code> est utilisé comme variable temporaire pour réaliser les calculs tout au long du round.</p>

<p>Je fais un <code class="language-plaintext highlighter-rouge">jump</code> et non un <code class="language-plaintext highlighter-rouge">call</code> pour atteindre <code class="language-plaintext highlighter-rouge">roundtail</code> car il est toujours appelé en fin de round, autant se servir du <code class="language-plaintext highlighter-rouge">ret</code> de <code class="language-plaintext highlighter-rouge">roundtail</code> et ainsi ne pas décaler la pile avec un autre <code class="language-plaintext highlighter-rouge">call</code> (les arguments restent donc accessibles avec la même offset sur SP).</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">roundtail:</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">4</span>            <span class="c1">;hl = Stack+4 = ArgB</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">push</span> <span class="nv">bc</span>               <span class="c1">;Stack bc</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">RollT</span>           <span class="c1">;hl = RollT</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;RollT = ArgB</span>
  <span class="nf">pop</span> <span class="nv">hl</span>                <span class="c1">;UnStack hl = ArgB</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">RollT</span>           <span class="c1">;bc = RollT</span>
  <span class="nf">call</span> <span class="nv">roll30</span>           <span class="c1">;ArgB = roll30(RollT)</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">10</span>           <span class="c1">;hl = Stack+10 = ArgE</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = ArgE</span>
  <span class="nf">push</span> <span class="nv">bc</span>               <span class="c1">;Stack bc</span>
  <span class="nf">push</span> <span class="nv">bc</span>               <span class="c1">;Stack bc</span>
  <span class="nf">pop</span> <span class="nv">hl</span>                <span class="c1">;UnStack hl = bc</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;bc = StateT</span>
  <span class="nf">call</span> <span class="nv">addl</span>             <span class="c1">;ArgE += StateT</span>

  <span class="nf">pop</span> <span class="nv">hl</span>                <span class="c1">;UnStack hl = ArgE</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">RoundK</span>          <span class="c1">;bc = RoundK</span>
  <span class="nf">call</span> <span class="nv">addl</span>             <span class="c1">;ArgE += RoundK</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">2</span>            <span class="c1">;hl = Stack+2 = ArgA</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">RollT</span>           <span class="c1">;hl = RollT</span>
  <span class="nf">call</span> <span class="nv">roll5</span>            <span class="c1">;RollT = roll5(ArgA)</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">10</span>           <span class="c1">;hl = Stack+10 = ArgE</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">push</span> <span class="nv">bc</span>               <span class="c1">;Stack bc</span>
  <span class="nf">pop</span> <span class="nv">hl</span>                <span class="c1">;UnStack hl = bc</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">RollT</span>           <span class="c1">;bc = RollT</span>
  <span class="nf">call</span> <span class="nv">addl</span>             <span class="c1">;ArgE += RollT</span>
  
  <span class="nf">ret</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">RollT</code> est utilisé comme variable temporaire pour réaliser les opérations <code class="language-plaintext highlighter-rouge">roll</code>.</p>

<h3 id="round-0b-et-roundschedule">Round 0b et roundschedule</h3>

<p>Les rounds <strong>0a</strong> et <strong>0b</strong> sont assez similaires et partagent la même valeur de <strong>K</strong>, ils ont donc la même initialisation ainsi qu’une partie de code en commun (voir ci-dessus pour l’initialisation du round).</p>

<p>Code <code class="language-plaintext highlighter-rouge">round0b</code> :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">round0b:</span>
  <span class="nf">call</span> <span class="nv">roundschedule</span>
  <span class="nf">jp</span> <span class="nv">round0</span>
</code></pre></div></div>

<p>On a déjà vu <code class="language-plaintext highlighter-rouge">round0</code> ci-dessus puisqu’il s’agit du même code que pour <code class="language-plaintext highlighter-rouge">round0a</code>.</p>

<p>Concernant <code class="language-plaintext highlighter-rouge">roundschedule</code>, il sera utile pour tous les rounds excepté <code class="language-plaintext highlighter-rouge">round0a</code> :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">roundschedule:</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">Step</span><span class="p">)</span>           <span class="c1">;a = (Step)</span>
  <span class="nf">sub</span> <span class="mi">3</span>                 <span class="c1">;a -= 3</span>
  <span class="nf">and</span> <span class="mi">15</span>                <span class="c1">;a &amp;= 15</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="mi">0</span>                <span class="c1">;b = 0</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,</span><span class="nv">a</span>                <span class="c1">;c = a</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">Schedule</span>        <span class="c1">;hl = Schedule</span>
  <span class="nf">add</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">bc</span>             <span class="c1">;hl += bc : Schedule[(Step - 3) * 4]</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack hl</span>
  <span class="nf">pop</span> <span class="nv">bc</span>                <span class="c1">;UnStack bc = hl</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;StateT = Schedule[(Step - 3) * 4]</span>

  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">Step</span><span class="p">)</span>           <span class="c1">;a = (Step)</span>
  <span class="nf">sub</span> <span class="mi">8</span>                 <span class="c1">;a -= 8</span>
  <span class="nf">and</span> <span class="mi">15</span>                <span class="c1">;a &amp;= 15</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="mi">0</span>                <span class="c1">;b = 0</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,</span><span class="nv">a</span>                <span class="c1">;c = a</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">Schedule</span>        <span class="c1">;hl = Schedule</span>
  <span class="nf">add</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">bc</span>             <span class="c1">;hl += bc : Schedule[(Step - 8) * 4]</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack hl</span>
  <span class="nf">pop</span> <span class="nv">bc</span>                <span class="c1">;UnStack bc = hl</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">xorl</span>             <span class="c1">;StateT ^= Schedule[(Step - 8) * 4]</span>

  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">Step</span><span class="p">)</span>           <span class="c1">;a = (Step)</span>
  <span class="nf">sub</span> <span class="mi">14</span>                <span class="c1">;a -= 14</span>
  <span class="nf">and</span> <span class="mi">15</span>                <span class="c1">;a &amp;= 15</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="mi">0</span>                <span class="c1">;b = 0</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,</span><span class="nv">a</span>                <span class="c1">;c = a</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">Schedule</span>        <span class="c1">;hl = Schedule</span>
  <span class="nf">add</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">bc</span>             <span class="c1">;hl += bc : Schedule[(Step - 14) * 4]</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack hl</span>
  <span class="nf">pop</span> <span class="nv">bc</span>                <span class="c1">;UnStack bc = hl</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">xorl</span>             <span class="c1">;StateT ^= Schedule[(Step - 14) * 4]</span>

  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">Step</span><span class="p">)</span>           <span class="c1">;a = (Step)</span>
  <span class="nf">sub</span> <span class="mi">16</span>                <span class="c1">;a -= 16</span>
  <span class="nf">and</span> <span class="mi">15</span>                <span class="c1">;a &amp;= 15</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="mi">0</span>                <span class="c1">;b = 0</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,</span><span class="nv">a</span>                <span class="c1">;c = a</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">Schedule</span>        <span class="c1">;hl = Schedule</span>
  <span class="nf">add</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">bc</span>             <span class="c1">;hl += bc : Schedule[(Step - 16) * 4]</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack hl</span>
  <span class="nf">pop</span> <span class="nv">bc</span>                <span class="c1">;UnStack bc = hl</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">xorl</span>             <span class="c1">;StateT ^= Schedule[(Step - 16) * 4]</span>

  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;bc = StateT</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">RollT</span>           <span class="c1">;hl = RollT</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;RollT = StateT</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">RollT</span>           <span class="c1">;bc = RollT</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">roll1</span>            <span class="c1">;StateT = roll1(RollT)</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">12</span>           <span class="c1">;hl = Stack+12 = ArgE</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">push</span> <span class="nv">bc</span>               <span class="c1">;Stack bc</span>
  <span class="nf">pop</span> <span class="nv">hl</span>                <span class="c1">;UnStack hl = bc</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;bc = StateT</span>
  <span class="nf">call</span> <span class="nv">addl</span>             <span class="c1">;ArgE += StateT</span>

  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">Step</span><span class="p">)</span>           <span class="c1">;a = (Step)</span>
  <span class="nf">and</span> <span class="mi">15</span>                <span class="c1">;a &amp;= 15</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="mi">0</span>                <span class="c1">;b = 0</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,</span><span class="nv">a</span>                <span class="c1">;c = a</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">Schedule</span>        <span class="c1">;hl = Schedule</span>
  <span class="nf">add</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">bc</span>             <span class="c1">;hl += bc : Schedule[Step * 4]</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;bc = StateT</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;Schedule[Step * 4] = StateT</span>

  <span class="nf">ret</span>
</code></pre></div></div>

<p>Rien de particulier à dire, le principe est similaire au reste du code qu’on a déjà vu plus haut.</p>

<h3 id="round-1-et-3">Round 1 et 3</h3>

<p>J’ai regroupé les rounds <strong>1</strong> et <strong>3</strong> dans le même chapitre car la seule différence entre les deux c’est la valeur de <strong>K</strong> (donc l’initialisation).</p>

<p>Initialisation du round <strong>1</strong> :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">initRound1:</span>
  <span class="c1">;Init RoundK ROUND1 0x6ED9EBA1</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">RoundK</span>          <span class="c1">;hl = RoundK</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">6</span><span class="nv">E</span>              <span class="c1">;a = 0x6E</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">D9</span>              <span class="c1">;a = 0xD9</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">EB</span>              <span class="c1">;a = 0xEB</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">A1</span>              <span class="c1">;a = 0xA1</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
<span class="nl">loopRound1:</span>
  <span class="nf">call</span> <span class="nv">round1</span>
  <span class="nf">jp</span> <span class="nv">loopRound</span>
</code></pre></div></div>

<p>Initialisation du round <strong>3</strong> :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">initRound3:</span>
  <span class="c1">;Init RoundK ROUND3 0xCA62C1D6</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">RoundK</span>          <span class="c1">;hl = RoundK</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">CA</span>              <span class="c1">;a = 0xCA</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">62</span>              <span class="c1">;a = 0x62</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">C1</span>              <span class="c1">;a = 0xC1</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">D6</span>              <span class="c1">;a = 0xD6</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
<span class="nl">loopRound3:</span>
  <span class="nf">call</span> <span class="nv">round3</span>
  <span class="nf">jp</span> <span class="nv">loopRound</span>
</code></pre></div></div>

<p>Code <code class="language-plaintext highlighter-rouge">round1</code> et <code class="language-plaintext highlighter-rouge">round3</code> :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">round1:</span>
<span class="nl">round3:</span>
  <span class="nf">call</span> <span class="nv">roundschedule</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">4</span>            <span class="c1">;hl = Stack+4 = ArgB</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;StateT = ArgB</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">6</span>            <span class="c1">;hl = Stack+6 = ArgC</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">xorl</span>             <span class="c1">;StateT ^= ArgC</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">8</span>            <span class="c1">;hl = Stack+8 = ArgD</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">xorl</span>             <span class="c1">;StateT ^= ArgD</span>

  <span class="nf">jp</span> <span class="nv">roundtail</span>
</code></pre></div></div>

<h3 id="round-2">Round 2</h3>

<p>Et pour terminer, le round <strong>2</strong> :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">round2:</span>
  <span class="nf">call</span> <span class="nv">roundschedule</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">6</span>            <span class="c1">;hl = Stack+6 = ArgC</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;StateT = ArgC</span>

  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;bc = StateT</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">RollT</span>           <span class="c1">;hl = RollT</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;RollT = StateT</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">8</span>            <span class="c1">;hl = Stack+8 = ArgD</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">push</span> <span class="nv">bc</span>               <span class="c1">;Stack bc : ArgD</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">orl</span>              <span class="c1">;StateT |= ArgD</span>

  <span class="nf">pop</span> <span class="nv">bc</span>                <span class="c1">;UnStack bc = ArgD</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">RollT</span>           <span class="c1">;hl = RollT</span>
  <span class="nf">call</span> <span class="nv">andl</span>             <span class="c1">;RollT &amp;= ArgD</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">4</span>            <span class="c1">;hl = Stack+4 = ArgB</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">andl</span>             <span class="c1">;StateT &amp;= ArgB</span>
  
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">RollT</span>           <span class="c1">;bc = RollT</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">orl</span>              <span class="c1">;StateT |= RollT</span>

  <span class="nf">jp</span> <span class="nv">roundtail</span>
</code></pre></div></div>

<p>Ici j’utilise <code class="language-plaintext highlighter-rouge">RollT</code> comme variable temporaire en plus de <code class="language-plaintext highlighter-rouge">StateT</code>. Au final le nom de ces deux variables n’a pas réellement d’importance ;)</p>

<h3 id="construction-de-la-chaine-à-hacher-blocs-sha1">Construction de la chaine à hacher (blocs SHA1)</h3>

<p>Comme vaguement évoqué dans le chapitre sur l’initialisation SHA1, cet algorithme utilise des blocs de <strong>64 octets</strong>.</p>

<p>Pour le moment je n’ai pas implémenté la génération des blocs, c’est donc une évolution future tout à fait envisageable !</p>

<p>En attendant, afin de tester correctement le calcul du SHA1, j’ai fait un petit script python afin de générer les blocs :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
</span>
<span class="kn">import</span> <span class="nn">getopt</span><span class="p">,</span> <span class="n">sys</span><span class="p">,</span> <span class="n">io</span>
<span class="kn">import</span> <span class="nn">binascii</span>

<span class="k">def</span> <span class="nf">usage</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"""
Usage : build-blocks.py [OPTIONS] &lt;source&gt;

Options :
-f  Source as file
-o  Output format (raw,hex,base64), default : hex
"""</span><span class="p">)</span>
    <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">output</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="nb">format</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s">"raw"</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="s">'unicode_escape'</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s">"hex"</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">binascii</span><span class="p">.</span><span class="n">b2a_hex</span><span class="p">(</span><span class="n">block</span><span class="p">).</span><span class="n">decode</span><span class="p">())</span>
    <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s">"base64"</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">binascii</span><span class="p">.</span><span class="n">b2a_base64</span><span class="p">(</span><span class="n">block</span><span class="p">).</span><span class="n">decode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">opts</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">getopt</span><span class="p">.</span><span class="n">getopt</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="s">"o:fh"</span><span class="p">,[</span><span class="s">"file"</span><span class="p">,</span> <span class="s">"output"</span><span class="p">,</span> <span class="s">"help"</span><span class="p">])</span>
    <span class="k">except</span> <span class="n">getopt</span><span class="p">.</span><span class="n">GetoptError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="n">usage</span><span class="p">()</span>
    <span class="n">source</span> <span class="o">=</span> <span class="s">' '</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">).</span><span class="n">encode</span><span class="p">()</span>
    <span class="n">isFile</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">out</span> <span class="o">=</span> <span class="s">"hex"</span>
    <span class="k">for</span> <span class="n">opt</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">(</span><span class="s">"-h"</span><span class="p">,</span> <span class="s">"--help"</span><span class="p">):</span>
            <span class="n">usage</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">(</span><span class="s">"-f"</span><span class="p">,</span> <span class="s">"--file"</span><span class="p">):</span>
            <span class="n">isFile</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">(</span><span class="s">"-o"</span><span class="p">,</span> <span class="s">"--output"</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="s">"raw"</span><span class="p">,</span> <span class="s">"hex"</span><span class="p">,</span> <span class="s">"base64"</span><span class="p">):</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">usage</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">usage</span><span class="p">()</span>

    <span class="n">reader</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">)</span> <span class="k">if</span> <span class="n">isFile</span> <span class="k">else</span> <span class="n">io</span><span class="p">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
    <span class="n">sourcelen</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">block</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">block</span> <span class="o">=</span> <span class="n">reader</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">:</span>
            <span class="n">sourcelen</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="n">sourcelen</span> <span class="o">+=</span> <span class="mi">64</span>
        <span class="n">output</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

    <span class="n">block</span> <span class="o">+=</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x80</span><span class="s">'</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">57</span><span class="p">:</span>
        <span class="n">block</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">(</span><span class="mi">64</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>
        <span class="n">output</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">block</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span>
    
    <span class="n">block</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">(</span><span class="mi">57</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>
    <span class="n">blocklen</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([((</span><span class="n">sourcelen</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">])</span>
    <span class="n">sourcelen</span> <span class="o">&gt;&gt;=</span> <span class="mi">5</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span>
        <span class="n">blocklen</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">sourcelen</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">])</span>
        <span class="n">sourcelen</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span>
    <span class="n">block</span> <span class="o">+=</span> <span class="n">blocklen</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">output</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

    <span class="n">reader</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div></div>

<p>Ce script permet donc de générer les blocs (1 par ligne) pour le message passé en argument (<code class="language-plaintext highlighter-rouge">source</code>), ou via le contenu d’un fichier en précisant l’option <code class="language-plaintext highlighter-rouge">-f</code>.<br />
L’option <code class="language-plaintext highlighter-rouge">-o</code> permet également de définir le format de sortie, à savoir :</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">raw</code> : Données brutes <strong>Attention cependant aux retours à la ligne, un bloc doit faire 64 octets même si il contient des retours à la ligne</strong></li>
  <li><code class="language-plaintext highlighter-rouge">hex</code> : Données en hexadécimal</li>
  <li><code class="language-plaintext highlighter-rouge">base64</code> : Données en base64</li>
</ul>

<p>On peut désormais insérer ces blocs dans le code assembleur, voici un exemple pour le message <strong>test</strong> :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">;Message : test</span>
  <span class="c1">;Init Block 1</span>
  <span class="c1">;Data (64 bytes) = test + \x80 + \x00*58 + \x20</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">Bl</span><span class="nv">ock</span>           <span class="c1">;hl = Block</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">74</span>              <span class="c1">;a = 0x74</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">65</span>              <span class="c1">;a = 0x65</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">73</span>              <span class="c1">;a = 0x73</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">74</span>              <span class="c1">;a = 0x74</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">80</span>              <span class="c1">;a = 0x80</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="mi">58</span>               <span class="c1">;b = 58</span>
  <span class="nf">xor</span> <span class="nv">a</span>                 <span class="c1">;a = 0</span>
<span class="nl">initblock1:</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">dec</span> <span class="nv">b</span>                 <span class="c1">;b -= 1</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">initblock1</span>      <span class="c1">;Si b &gt; 0 : Jump initblock1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">20</span>              <span class="c1">;a = 0x20</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">call</span> <span class="nv">sha1</span>
</code></pre></div></div>

<p>Après avoir inséré le bloc dans la variable bloc on appel <code class="language-plaintext highlighter-rouge">sha1</code> pour exécuter les calculs.</p>

<p>Dans le cas où on a plusieurs blocs, il faut quand même appeler <code class="language-plaintext highlighter-rouge">sha1</code> sur le premier bloc puis appeler <code class="language-plaintext highlighter-rouge">sha1next</code> à la place pour les prochains blocs !</p>

<h3 id="récupération-du-hash">Récupération du hash</h3>

<p>Comme indiqué dans le chapitre sur l’espace mémoire nécessaire, le hash est stocké dans les variables <code class="language-plaintext highlighter-rouge">StateA</code> à <code class="language-plaintext highlighter-rouge">StateE</code>.</p>

<p>Le 20 octets de ces 5 variables cumulées correspondent au hash et sont accessibles de l’adresse mémoire <code class="language-plaintext highlighter-rouge">C001</code> à <code class="language-plaintext highlighter-rouge">C014</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Ce projet a été un challenge très intéressant pour moi. J’ai pris beaucoup de plaisir à découvrir une partie des possibilités qu’offre la GameBoy.</p>

<p>Il y a encore pas mal d’optimisations/évolutions possibles pour ce projet et je n’exclus pas une éventuelle seconde partie à cet article !</p>

<p>Un grand merci à <a href="https://entropyqueen.github.io/" target="_blank">entropyQueen</a> pour m’avoir motivé (sans le vouloir ^^) à me lancer dans ce projet.</p>

<h2 id="sources-et-inspirations">Sources et inspirations</h2>

<ul>
  <li><a href="https://github.com/Elrindel/SHA1-GameBoy" target="_blank">Code du projet</a></li>
  <li><a href="specifications-gameboy" target="_blank">Spécifications GameBoy</a></li>
  <li><a href="https://entropyqueen.github.io/" target="_blank">Blog d’entropyQueen</a></li>
  <li><a href="http://furrtek.free.fr/?a=gbasm" target="_blank">Article de Furrtek</a></li>
  <li><a href="https://www.nayuki.io/page/fast-sha1-hash-implementation-in-x86-assembly" target="_blank">Source SHA1 en C et assembleur x86</a></li>
</ul>

    </article>
    <nav>
        <div id="summary"></div>
    </nav>
</div>
    </section>
    
<div class="container">
    <div id="disqus_thread"></div>

<script>
	let disqus = document.getElementById('disqus');
	let observer = new IntersectionObserver((e) => {
		if(e[0].isIntersecting){
			observer.disconnect();
			let disqus = document.createElement('script');
			disqus.type = 'text/javascript';
			disqus.async = true;
			disqus.src = '//elrindel.disqus.com/embed.js';
			document.getElementsByTagName('head')[0].appendChild(disqus);
		}
	});
	observer.observe(document.getElementById('disqus_thread'));
</script>
</div>

<footer id="footer"></footer>

<script async type="text/javascript" src="/assets/js/summary.js"></script>

</body>

</html>
