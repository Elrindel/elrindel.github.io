<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta name="description" content="Suite à une petite discussion avec entropyQueen concernant ses projets sur GameBoy, je me suis lancé dans l’implémentation de l’algorithme de hachage SHA1 su..."> <link type="application/atom+xml" rel="alternate" href="https://elrindel.github.io/feed.xml" title="Elrindel/Flob Blog" /> <!-- Begin Jekyll SEO tag v2.6.1 --> <title>Implémentation SHA1 sur GameBoy | Elrindel/Flob Blog</title> <meta name="generator" content="Jekyll v4.0.0" /> <meta property="og:title" content="Implémentation SHA1 sur GameBoy" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Suite à une petite discussion avec entropyQueen concernant ses projets sur GameBoy, je me suis lancé dans l’implémentation de l’algorithme de hachage SHA1 sur GameBoy ! C’était une première pour moi puisque j’avais encore jamais fait de programmation sur GB (et très peu fait d’assembleur également). Dans cet article je vais donc vous partager mon apprentissage en essayant d’expliquer au mieux mes recherches/analyses/réflexions pour avancer sur ce projet ! Les sources de ce projet sont disponibles ici : SHA1 GameBoy Programmation sur GameBoy Ma première étape a été de me renseigner sur les différentes méthodes possibles de programmation sur GB. Il m’est vite apparu que la seule solution réellement intéressante est l’assembleur ! On trouve d’ailleurs assez facilement un certain nombre d’articles qui traitent très bien ce sujet. Dans mon cas, je me suis arrêté sur l’article de Furrtek qui a le mérite d’être clair et assez complet pour débuter dans le domaine. Spécifications techniques de la GameBoy Il existe plusieurs versions de la documentation mais globalement le contenu est toujours le même. Afin de m’assurer de ne pas perdre ce document (comme c’est le cas avec le lien fourni par Furrtek), j’ai préféré en faire une copie ici sur mon blog : Spécifications GameBoy Ce document donne toutes les indications nécessaires pour utiliser l’ensemble des fonctionnalités de la GB ! Je ne rentrerai pas dans les détails (sauf si besoin pour certains points spécifiques), des articles comme celui de Furrtek font déjà très bien le travail. Pour ce projet j’ai utilisé l’émulateur BGB. J’avoue ne pas avoir testé les autres étant donné que celui-ci répondait parfaitement à mes besoins. Assembleur WLA DX Comme le suggère Furrtek dans son article, je vais utiliser l’assembleur WLA-DX. Suivez les instructions de compilations indiquées dans le readme ou téléchargez une version déjà compilée. Pour simplifier l’utilisation, j’ai ajouté le dossier binaries à ma variable d’environnement PATH. Voici un petit script que j’ai nommé wla-gb-build et qui permet de faciliter l’utilisation de WLA-DX (je l’ai ajouté dans le dossier binaries) : #!/bin/sh fileDir=$(dirname &quot;$1&quot;) fileName=$(basename -- &quot;$1&quot;) fileName=&quot;${fileName%.*}&quot; echo [objects]&gt;&quot;${fileDir}/linkfile&quot; echo ${fileDir}/${fileName}.o&gt;&gt;&quot;${fileDir}/linkfile&quot; [ -e &quot;${fileDir}/${fileName}.o&quot; ] &amp;&amp; rm &quot;${fileDir}/${fileName}.o&quot; wla-gb -o &quot;${fileDir}/${fileName}.o&quot; $1 wlalink -d -r -v -s &quot;${fileDir}/linkfile&quot; &quot;${fileDir}/${fileName}.gb&quot; Ainsi il suffit d’exécuter la commande wla-gb-build mon_jeu.s pour obtenir le fichier mon_jeu.gb. Algorithme SHA1 Maintenant que je sais comment créer et tester des programmes GB, je peux m’attaquer à la plus grosse partie, l’algorithme SHA1 ! La solution qui me semble la plus évidente consiste à trouver le code de cet algorithme en C, ou même directement en assembleur x86, puis de voir comment je peux l’adapter avec les instructions disponibles en z80 (enfin, la version GB qui est légèrement différente d’un véritable z80). J’ai donc trouvé mon bonheur sur ce site : https://www.nayuki.io/page/fast-sha1-hash-implementation-in-x86-assembly Plus particulièrement leur implémentation en version fast. Opérations 32 bits sur CPU 8 bits En étudiant un peu l’assembleur de la version fast je remarque, sans surprise, un certain nombre d’instructions basées sur une architecture 32 bits. Les instructions en question sont les suivantes : movl Ecrit un entier 32 bits à une adresse en mémoire andl Opération logique and entre 2 entiers 32 bits orl Opération logique or entre 2 entiers 32 bits xorl Opération logique xor entre 2 entiers 32 bits addl Additionne 2 entiers 32 bits roll Rotation des bits vers la gauche sur un entier 32 bits (les bits qui sortent re-rentrent par la droite) Concernant l’instruction bswapl (qui permet d’inverser l’ordre des 4 octets d’un entier 32 bits), elle n’est pas nécessaire en z80 (pour cet algorithme en tout cas), voir l’implémentation de addl ci-dessous pour plus de détails. Désormais il faut trouver un moyen de convertir ces instructions 32 bits pour pouvoir les utiliser sur un CPU 8 bits ! Afin de simplifier l’utilisation, je choisis arbitrairement que le registre BC correspond à la source, et le registre HL à la destination. Instruction movl Cette instruction est probablement la plus simple à réaliser puisqu’il s’agit de déplacer 4 octets d’une adresse vers une autre. movl: ;hl=bc ld e,4 ;e = 4 loopmovl: ld a,(bc) ;a = (bc) ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec e ;e -= 1 jr nz,loopmovl ;Si e != 0 : Jump loopmovl ret La valeur pointée par le registre BC est insérée dans le registre A qui est ensuite insérée à l’adresse pointée par le registre HL. Les adresses pointées par HL et BC sont incrémentées afin de passer à l’octet suivant. Ces opérations sont répétées 4 fois. Instructions andl, orl, xorl Le principe est très similaire à movl, il faut juste réaliser une opération supplémentaire (and, or, xor) sur chaque octet. Exemple pour l’instruction and : andl: ;hl&amp;=bc ld e,4 ;e = 4 loopandl: ld a,(bc) ;a = (bc) and (hl) ;a &amp;= (hl) ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec e ;e -= 1 jr nz,loopandl ;Si e != 0 : Jump loopandl ret Instruction addl Voilà enfin un peu de challenge !! Réaliser une addition de deux entiers 32 bits avec seulement des instructions sur 8 bits. A première vue il est légitime de penser que c’est compliqué, mais en réalité ça ne l’est pas ! L’instruction add permet d’additionner deux entiers 8 bits, et si 8 bits ne suffisent pas pour stocker le résultat, alors il y aura une retenue qu’on peut intercepter via le flag c (Carry Flag) ! On peut donc facilement étendre l’addition à plusieurs octets en utilisant le flag c pour vérifier si il est nécessaire d’appliquer la retenue sur l’octet suivant ! A ce niveau il faut être cohérent sur l’ordre des octets. Le résultat ne pourra pas être le même si on va de l’octet 1 à 4 (little endian) ou de l’octet 4 à 1 (big endian). Pour simplifier et éviter d’implémenter l’instruction bswapl j’ai décidé de partir sur l’ordre big endian. addl: ;hl+=bc inc bc ;bc += 1 inc bc ;bc += 1 inc bc ;bc += 1 inc hl ;hl += 1 inc hl ;hl += 1 inc hl ;hl += 1 ld d,5 ;d = 5 jp addlstart ;Jump addlstart addlnext: pop de ;UnStack de pop hl ;UnStack hl dec hl ;hl -= 1 addlstart: dec d ;d -= 1 jr z,addlend ;Si d == 0 : Jump addlend ld a,(bc) ;a = (bc) dec bc ;bc -= 1 push hl ;Stack hl push de ;Stack de add (hl) ;a += (hl) ld (hl),a ;(hl) = a jr nc,addlnext ;Si a+(hl) &lt; 256 : Jump addlnext (si pas de retenue) addlnc: dec d ;d -= 1 jr z,addlnext ;Si d == 0 : Jump addlnext (si on est sur le dernier octet) dec hl ;hl -= 1 inc (hl) ;(hl) += 1 (on applique la retenue) jr nz,addlnext ;Si (hl) != 0 : Jump addlnext jp addlnc ;Sinon Jump addlnc (on fait suivre la retenue sur l&#39;octet suivant) addlend: ret Pour commencer il faut ajouter 3 aux registres HL et BC afin de commencer le traitement sur les bons octets, puis je commence les additions octet par octet tout en appliquant bien la retenue aux octets suivants. Je sauvegarde les registres HL et DE sur la pile (Stack) afin de pouvoir procéder aux éventuels applications de retenues sans pour autant perdre le compte (puisque je dois décrémenter D et HL pour gérer correctement les retenues) puis je rétablis HL et DE pour le traitement du prochain octet (addlnext). Instruction roll On monte encore d’un cran en terme de challenge !! Je n’ai pas encore réussi à implémenter un roll générique et j’ai une doute sur la pertinence de le faire étant donné la complexité d’une telle opération comparé au besoin pour ce projet. En analysant l’algorithme SHA1 on constate que roll est utilisé seulement avec 3 décalages différents (1, 5 et 30). J’ai donc décidé de créer ces 3 roll différents sans chercher à faire une version générique. Pour cela j’ai posé sur papier chacun des 3 décalages afin de voir les correspondances des bits entre chaque octet, et ainsi pouvoir le retranscrire en assembleur. Je suis cependant curieux/preneur de toutes solutions génériques ou de toutes optimisations de mon implémentation actuelle ! Voici le roll5 en exemple : roll5: ;hl=roll(bc,5) push hl ;Stack hl pop de ;UnStack de = hl push bc ;Stack bc pop hl ;UnStack hl = bc ld b,3 ;b = 3 looproll5: ldi a,(hl) ;a = (hl), hl += 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 ld c,(hl) ;c = (hl) srl c ;c &gt;&gt;= 1 srl c ;c &gt;&gt;= 1 srl c ;c &gt;&gt;= 1 or c ;a |= c ld (de),a ;(de) = a inc de ;de += 1 dec b ;b -= 1 jr nz,looproll5 ;Si b != 0 : Jump looproll5 ldd a,(hl) ;a = (hl), hl -= 1 dec hl ;hl -= 1 dec hl ;hl -= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 ld c,(hl) ;c = (hl) srl c ;c &gt;&gt;= 1 srl c ;c &gt;&gt;= 1 srl c ;c &gt;&gt;= 1 or c ;a |= c ld (de),a ;(de) = a ret Il s’agit donc de réaliser les bons shift (décalages) sur les bons octets puis de faire un or pour fusionner les bits. Le principe est identique pour les 3 roll (1, 5 et 30) mais avec les bons décalages et les bonnes correspondances pour chacun. Espace mémoire nécessaire (variables) Voici les différentes variables qui seront nécessaires au bon fonctionnement de l’algo : Step DB ;C000 : Compteur de rounds StateA DS 4 ;C001-C004 : SHA1 A en cours StateB DS 4 ;C005-C008 : SHA1 B en cours StateC DS 4 ;C009-C00C : SHA1 C en cours StateD DS 4 ;C00D-C010 : SHA1 D en cours StateE DS 4 ;C011-C014 : SHA1 E en cours StateT DS 4 ;C015-C018 : Temporaire pour les opérations sur les State RollT DS 4 ;C019-C01C : Temporaire pour certaines opérations RoundK DS 4 ;C01D-C020 : SHA1 K du round en cours Block DS 64 ;C021-C060 : SHA1 Block (message à hacher) Schedule DS 64 ;C061-C0A0 : Temporaire pour les opérations sur Block InitA DS 4 ;C0A1-C0A5 : Sauvegarde SHA1 A à l&#39;initialisation InitB DS 4 ;C0A6-C0A9 : Sauvegarde SHA1 B à l&#39;initialisation InitC DS 4 ;C0AA-C0AD : Sauvegarde SHA1 C à l&#39;initialisation InitD DS 4 ;C0AE-C0B1 : Sauvegarde SHA1 D à l&#39;initialisation InitE DS 4 ;C0B2-C0B5 : Sauvegarde SHA1 E à l&#39;initialisation Reg1 DS 2 ;C0B6-C0B7 : Registre 1 Reg2 DS 2 ;C0B8-C0B9 : Registre 2 Total : 185 octets Les variables StateA à StateE contiennent le hash SHA1 en cours de calcul, le hash final sera donc dans ces variables également. Le hash correspond donc aux 20 octets de l’adresse C001 à l’adresse C014. Reg1 et Reg2 permettent de combler le faible nombre de registres disponibles sur la GB (seulement 3 registres 16 bits), ils servent donc de stockage d’adresse 16 bits. Ils sont nécessaires pour gérer la rotation automatique des 5 variables State à chaque round (voir le chapitre suivant). Sans eux il est possible de faire cette rotation en utilisant directement la pile (stack) mais il serait alors obligatoire de désactiver les interruptions de la GameBoy afin d’éviter d’avoir une interruption au mauvais moment qui viendrait écraser certaines données sur la pile : Voir la documentation sur les interruptions Initialisation SHA1 L’initialisation SHA1 consiste simplement à définir les valeurs des 5 états (StateA à StateE), il s’agit du vecteur d’initialisation du SHA1 par défaut : sha1: ;Init StateA = 0x67452301 ld a,$67 ld (StateA),a ld a,$45 ld (StateA+1),a ld a,$23 ld (StateA+2),a ld a,$01 ld (StateA+3),a ;Init StateB = 0xEFCDAB89 ld a,$EF ld (StateB),a ld a,$CD ld (StateB+1),a ld a,$AB ld (StateB+2),a ld a,$89 ld (StateB+3),a ;Init StateC = 0x98BADCFE ld a,$98 ld (StateC),a ld a,$BA ld (StateC+1),a ld a,$DC ld (StateC+2),a ld a,$FE ld (StateC+3),a ;Init StateD = 0x10325476 ld a,$10 ld (StateD),a ld a,$32 ld (StateD+1),a ld a,$54 ld (StateD+2),a ld a,$76 ld (StateD+3),a ;Init StateE = 0xC3D2E1F0 ld a,$C3 ld (StateE),a ld a,$D2 ld (StateE+1),a ld a,$E1 ld (StateE+2),a ld a,$F0 ld (StateE+3),a sha1next: xor a ;a = 0 ld (Step),a ;(Step) = 0 ld bc,StateA ld hl,InitA call movl ;InitA = StateA ld bc,StateB ld hl,InitB call movl ;InitB = StateB ld bc,StateC ld hl,InitC call movl ;InitC = StateC ld bc,StateD ld hl,InitD call movl ;InitD = StateD ld bc,StateE ld hl,InitE call movl ;InitE = StateE Cet algorithme procède au calcul du hash SHA1 par blocs de 64 octets (voir le chapitre sur la construction de la chaine à hacher pour plus d’informations). Il peut évidemment arriver qu’on ait besoin d’obtenir le hash de chaines bien plus longues que 64 octets, c’est pourquoi il y a un second point de départ qui permet de ne pas réinitialiser les états du SHA1 en cours, il s’agit de sha1next. Initialisation d’un round A chaque round on constate deux changements, à savoir l’incrémentation du compteur de rounds (Step) ainsi qu’une rotation des arguments. Pour le round 0, les arguments sont dans l’ordre A, B, C, D, E, puis au round suivant on constate une rotation : E, A, B, C, D, puis D, E, A, B, C et ainsi de suite pour les 80 rounds. Je commence donc par initialiser le tout premier ordre : ld hl,StateE push hl ;Stack : StateE =&gt; ArgE ld hl,StateD push hl ;Stack : StateD =&gt; ArgD ld hl,StateC push hl ;Stack : StateC =&gt; ArgC ld hl,StateB push hl ;Stack : StateB =&gt; ArgB ld hl,StateA push hl ;Stack : StateA =&gt; ArgA jp initRound0 ;Jump initRound0 J’utilise la pile afin de manipuler plus facilement ces valeurs. Le dernier entré est le premier sorti, c’est pour cela que je push de StateE à StateA et non l’inverse. Vu qu’il s’agit de l’ordre pour le round 0 je jump directement à cette étape (voir le chapitre sur le round 0 ci-dessous). Ensuite Il faut donc gérer la rotation des arguments pour les prochains rounds : loopRound: ;SP = 0 ld hl,Reg1 ;hl = Reg1 pop de ;de = sp[0] = ArgA, sp = 2 ld a,d ;a = d ldi (hl),a ;(hl) = a, hl += 1 ld a,e ;a = e ldi (hl),a ;(hl) = a, hl += 1 pop de ;de = sp[2] = ArgB, sp = 4 ld a,d ;a = d ldi (hl),a ;(hl) = a, hl += 1 ld a,e ;a = e ldi (hl),a ;(hl) = a, hl += 1 pop de ;de = sp[4] = ArgC, sp = 6 pop hl ;hl = sp[6] = ArgD, sp = 8 pop bc ;bc = sp[8] = ArgE, sp = 10 push hl ;sp = 8, sp[8] = hl = D push de ;sp = 6, sp[6] = de = C ld hl,Reg2 ;hl = Reg2 ld d,(hl) ;d = (hl) inc hl ;hl += 1 ld e,(hl) ;e = (hl) push de ;sp = 4, sp[4] = de = Reg2 = ArgB ld hl,Reg1 ;hl = Reg1 ld d,(hl) ;d = (hl) inc hl ;hl += 1 ld e,(hl) ;e = (hl) push de ;sp = 2, sp[2] = de = Reg1 = ArgA push bc ;sp = 0, sp[0] = bc = ArgE ld a,(Step) ;a = (Step) inc a ;a += 1 ld (Step),a ;(Step) = a cp a,16 jr c,loopRound0a ;Si Step &lt; 16: Jump loopRound0a cp a,20 jr c,loopRound0b ;Si Step &lt; 20: Jump loopRound0b jr z,initRound1 ;Si Step == 20: Jump initRound1 cp a,40 jr c,loopRound1 ;Si Step &lt; 40: Jump loopRound1 jr z,initRound2 ;Si Step == 40: Jump initRound2 cp a,60 jr c,loopRound2 ;Si Step &lt; 60: Jump loopRound2 jr z,initRound3 ;Si Step == 60: Jump initRound3 cp a,80 jr c,loopRound3 ;Si Step &lt; 80: Jump loopRound3 jp loopRoundEnd ;Sinon Jump loopRoundEnd Afin de simplifier les commentaires je pars du principe que SP vaut 0, ce n’est évidemment pas le cas en réalité ! A ce niveau j’ai plusieurs possibilités pour faire la rotation. Dans un premier temps j’avais réalisé cela à base de pop et de push tout en jouant avec SP pour atteindre le bon emplacement. Mais cette solution n’était pas correcte car incompatible avec les interruptions GB ! En effet, lors d’une interruption, la GameBoy va mettre en “pause” le code en cours d’exécution et faire l’équivalent d’un call vers le code de l’interruption (avec une étape en plus cependant). Cela a pour effet d’ajouter 2 adresses de retour sur la pile (pour les ret en fin d’interruption). De ce fait, si je tente de faire une rotation en me déplaçant directement dans la pile et qu’une interruption intervient en même temps, alors je verrai mes valeurs écrasées par ces adresses de retour. Pour éviter cela, j’ai ajouté deux variables (Reg1 et Reg2) qui me servent de registre tampon en complément des 3 registres 16 bits de la GB. Ainsi je peux totalement vider la pile des 5 arguments puis la reconstruire proprement sans risquer de perdre des valeurs ! Ensuite j’incrémente Step et je fais des simples comparaisons pour savoir quel round lancer. Round 0a et roundtail Initialisation du round 0 : initRound0: ;Init RoundK ROUND0 0x5A827999 ld hl,RoundK ;hl = RoundK ld a,$5A ;a = 0x5A ldi (hl),a ;(hl) = a, hl += 1 ld a,$82 ;a = 0x82 ldi (hl),a ;(hl) = a, hl += 1 ld a,$79 ;a = 0x79 ldi (hl),a ;(hl) = a, hl += 1 ld a,$99 ;a = 0x99 ldi (hl),a ;(hl) = a, hl += 1 loopRound0a: call round0a jp loopRound loopRound0b: call round0b jp loopRound On définit RoundK lors de l’initialisation du round 0 puis on appel round0a : round0a: ld a,(Step) ;a = (Step) sla a ;a *= 2 sla a ;a *= 2 ld b,0 ;b = 0 ld c,a ;c = a ld hl,Block ;hl = Block add hl,bc ;hl += bc : Block[Step * 4] push hl ;Stack hl ld hl,Schedule ;hl = Schedule add hl,bc ;hl += bc : Schedule[Step * 4] pop bc ;UnStack bc = Block[Step * 4] push hl ;Stack hl call movl ;Schedule[Step * 4] = Block[Step * 4] pop bc ;UnStack bc = Schedule[Step * 4] ld hl,sp+10 ;hl = Stack+10 = ArgE ld e,(hl) ;e = (hl) inc hl ;hl += 1 ld d,(hl) ;d = (hl) push de ;Stack de pop hl ;UnStack hl = de call addl ;ArgE += Schedule[Step * 4] jp round0 Il n’y a pas d’instruction pour réaliser directement une multiplication sur GB, cependant, un shift left revient à multiplier par deux, je le fais donc deux fois afin de multiplier par 4. Pour atteindre ArgE j’utilise le registre SP sachant que j’ai construit la pile juste avant, je peux donc récupérer l’argument souhaité. Voici d’ailleurs à quoi ressemble la pile à ce moment : SP+0 = Adresse de retour SP+2 = ArgA SP+4 = ArgB SP+6 = ArgC SP+8 = ArgD SP+10 = ArgE round0 correspond à la partie commune entre round0a et round0b : round0: ld hl,sp+6 ;hl = Stack+6 = ArgC ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call movl ;StateT = ArgC ld hl,sp+8 ;hl = Stack+8 = ArgD ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call xorl ;StateT ^= ArgD ld hl,sp+4 ;hl = Stack+4 = ArgB ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call andl ;StateT &amp;= ArgB ld hl,sp+8 ;hl = Stack+6 = ArgD ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call xorl ;StateT ^= ArgD jp roundtail round0 étant atteint via un jump, il n’y a pas d’adresse de retour en plus sur la pile, ça ne change donc pas les accès aux arguments. StateT est utilisé comme variable temporaire pour réaliser les calculs tout au long du round. Je fais un jump et non un call pour atteindre roundtail car il est toujours appelé en fin de round, autant se servir du ret de roundtail et ainsi ne pas décaler la pile avec un autre call (les arguments restent donc accessibles avec la même offset sur SP). roundtail: ld hl,sp+4 ;hl = Stack+4 = ArgB ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) push bc ;Stack bc ld hl,RollT ;hl = RollT call movl ;RollT = ArgB pop hl ;UnStack hl = ArgB ld bc,RollT ;bc = RollT call roll30 ;ArgB = roll30(RollT) ld hl,sp+10 ;hl = Stack+10 = ArgE ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = ArgE push bc ;Stack bc push bc ;Stack bc pop hl ;UnStack hl = bc ld bc,StateT ;bc = StateT call addl ;ArgE += StateT pop hl ;UnStack hl = ArgE ld bc,RoundK ;bc = RoundK call addl ;ArgE += RoundK ld hl,sp+2 ;hl = Stack+2 = ArgA ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,RollT ;hl = RollT call roll5 ;RollT = roll5(ArgA) ld hl,sp+10 ;hl = Stack+10 = ArgE ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) push bc ;Stack bc pop hl ;UnStack hl = bc ld bc,RollT ;bc = RollT call addl ;ArgE += RollT ret RollT est utilisé comme variable temporaire pour réaliser les opérations roll. Round 0b et roundschedule Les rounds 0a et 0b sont assez similaires et partagent la même valeur de K, ils ont donc la même initialisation ainsi qu’une partie de code en commun (voir ci-dessus pour l’initialisation du round). Code round0b : round0b: call roundschedule jp round0 On a déjà vu round0 ci-dessus puisqu’il s’agit du même code que pour round0a. Concernant roundschedule, il sera utile pour tous les rounds excepté round0a : roundschedule: ld a,(Step) ;a = (Step) sub 3 ;a -= 3 and 15 ;a &amp;= 15 sla a ;a *= 2 sla a ;a *= 2 ld b,0 ;b = 0 ld c,a ;c = a ld hl,Schedule ;hl = Schedule add hl,bc ;hl += bc : Schedule[(Step - 3) * 4] push hl ;Stack hl pop bc ;UnStack bc = hl ld hl,StateT ;hl = StateT call movl ;StateT = Schedule[(Step - 3) * 4] ld a,(Step) ;a = (Step) sub 8 ;a -= 8 and 15 ;a &amp;= 15 sla a ;a *= 2 sla a ;a *= 2 ld b,0 ;b = 0 ld c,a ;c = a ld hl,Schedule ;hl = Schedule add hl,bc ;hl += bc : Schedule[(Step - 8) * 4] push hl ;Stack hl pop bc ;UnStack bc = hl ld hl,StateT ;hl = StateT call xorl ;StateT ^= Schedule[(Step - 8) * 4] ld a,(Step) ;a = (Step) sub 14 ;a -= 14 and 15 ;a &amp;= 15 sla a ;a *= 2 sla a ;a *= 2 ld b,0 ;b = 0 ld c,a ;c = a ld hl,Schedule ;hl = Schedule add hl,bc ;hl += bc : Schedule[(Step - 14) * 4] push hl ;Stack hl pop bc ;UnStack bc = hl ld hl,StateT ;hl = StateT call xorl ;StateT ^= Schedule[(Step - 14) * 4] ld a,(Step) ;a = (Step) sub 16 ;a -= 16 and 15 ;a &amp;= 15 sla a ;a *= 2 sla a ;a *= 2 ld b,0 ;b = 0 ld c,a ;c = a ld hl,Schedule ;hl = Schedule add hl,bc ;hl += bc : Schedule[(Step - 16) * 4] push hl ;Stack hl pop bc ;UnStack bc = hl ld hl,StateT ;hl = StateT call xorl ;StateT ^= Schedule[(Step - 16) * 4] ld bc,StateT ;bc = StateT ld hl,RollT ;hl = RollT call movl ;RollT = StateT ld bc,RollT ;bc = RollT ld hl,StateT ;hl = StateT call roll1 ;StateT = roll1(RollT) ld hl,sp+12 ;hl = Stack+12 = ArgE ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) push bc ;Stack bc pop hl ;UnStack hl = bc ld bc,StateT ;bc = StateT call addl ;ArgE += StateT ld a,(Step) ;a = (Step) and 15 ;a &amp;= 15 sla a ;a *= 2 sla a ;a *= 2 ld b,0 ;b = 0 ld c,a ;c = a ld hl,Schedule ;hl = Schedule add hl,bc ;hl += bc : Schedule[Step * 4] ld bc,StateT ;bc = StateT call movl ;Schedule[Step * 4] = StateT ret Rien de particulier à dire, le principe est similaire au reste du code qu’on a déjà vu plus haut. Round 1 et 3 J’ai regroupé les rounds 1 et 3 dans le même chapitre car la seule différence entre les deux c’est la valeur de K (donc l’initialisation). Initialisation du round 1 : initRound1: ;Init RoundK ROUND1 0x6ED9EBA1 ld hl,RoundK ;hl = RoundK ld a,$6E ;a = 0x6E ldi (hl),a ;(hl) = a, hl += 1 ld a,$D9 ;a = 0xD9 ldi (hl),a ;(hl) = a, hl += 1 ld a,$EB ;a = 0xEB ldi (hl),a ;(hl) = a, hl += 1 ld a,$A1 ;a = 0xA1 ldi (hl),a ;(hl) = a, hl += 1 loopRound1: call round1 jp loopRound Initialisation du round 3 : initRound3: ;Init RoundK ROUND3 0xCA62C1D6 ld hl,RoundK ;hl = RoundK ld a,$CA ;a = 0xCA ldi (hl),a ;(hl) = a, hl += 1 ld a,$62 ;a = 0x62 ldi (hl),a ;(hl) = a, hl += 1 ld a,$C1 ;a = 0xC1 ldi (hl),a ;(hl) = a, hl += 1 ld a,$D6 ;a = 0xD6 ldi (hl),a ;(hl) = a, hl += 1 loopRound3: call round3 jp loopRound Code round1 et round3 : round1: round3: call roundschedule ld hl,sp+4 ;hl = Stack+4 = ArgB ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call movl ;StateT = ArgB ld hl,sp+6 ;hl = Stack+6 = ArgC ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call xorl ;StateT ^= ArgC ld hl,sp+8 ;hl = Stack+8 = ArgD ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call xorl ;StateT ^= ArgD jp roundtail Round 2 Et pour terminer, le round 2 : round2: call roundschedule ld hl,sp+6 ;hl = Stack+6 = ArgC ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call movl ;StateT = ArgC ld bc,StateT ;bc = StateT ld hl,RollT ;hl = RollT call movl ;RollT = StateT ld hl,sp+8 ;hl = Stack+8 = ArgD ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) push bc ;Stack bc : ArgD ld hl,StateT ;hl = StateT call orl ;StateT |= ArgD pop bc ;UnStack bc = ArgD ld hl,RollT ;hl = RollT call andl ;RollT &amp;= ArgD ld hl,sp+4 ;hl = Stack+4 = ArgB ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call andl ;StateT &amp;= ArgB ld bc,RollT ;bc = RollT ld hl,StateT ;hl = StateT call orl ;StateT |= RollT jp roundtail Ici j’utilise RollT comme variable temporaire en plus de StateT. Au final le nom de ces deux variables n’a pas réellement d’importance ;) Construction de la chaine à hacher (blocs SHA1) Comme vaguement évoqué dans le chapitre sur l’initialisation SHA1, cet algorithme utilise des blocs de 64 octets. Pour le moment je n’ai pas implémenté la génération des blocs, c’est donc une évolution future tout à fait envisageable ! En attendant, afin de tester correctement le calcul du SHA1, j’ai fait un petit script python afin de générer les blocs : #!/usr/bin/env python3 import getopt, sys, io import binascii def usage(): print(&quot;&quot;&quot; Usage : build-blocks.py [OPTIONS] &lt;source&gt; Options : -f Source as file -o Output format (raw,hex,base64), default : hex &quot;&quot;&quot;) sys.exit(2) def output(block, format): if format == &quot;raw&quot;: print(block.decode(&#39;unicode_escape&#39;)) elif format == &quot;hex&quot;: print(binascii.b2a_hex(block).decode()) elif format == &quot;base64&quot;: print(binascii.b2a_base64(block).decode()) def main(): try: opts, args = getopt.getopt(sys.argv[1:],&quot;o:fh&quot;,[&quot;file&quot;, &quot;output&quot;, &quot;help&quot;]) except getopt.GetoptError as error: print(error) usage() source = &#39; &#39;.join(args).encode() isFile = False out = &quot;hex&quot; for opt, arg in opts: if opt in (&quot;-h&quot;, &quot;--help&quot;): usage() elif opt in (&quot;-f&quot;, &quot;--file&quot;): isFile = True elif opt in (&quot;-o&quot;, &quot;--output&quot;): if arg in (&quot;raw&quot;, &quot;hex&quot;, &quot;base64&quot;): out = arg else: usage() else: usage() reader = open(source, &quot;rb&quot;) if isFile else io.BytesIO(source) sourcelen = 0 block = b&#39;&#39; while True: block = reader.read(64) if len(block) &lt; 64: sourcelen += len(block) break sourcelen += 64 output(block, out) block += b&#39;\x80&#39; if len(block) &gt;= 57: block += bytes(64-len(block)) output(block, out) block = b&#39;&#39; block += bytes(57-len(block)) blocklen = bytes([((sourcelen &amp; 0x1F) &lt;&lt; 3) &amp; 0xFF]) sourcelen &gt;&gt;= 5 for i in range(1, 7): blocklen += bytes([sourcelen &amp; 0xFF]) sourcelen &gt;&gt;= 8 block += blocklen[::-1] output(block, out) reader.close() if __name__ == &quot;__main__&quot;: main() Ce script permet donc de générer les blocs (1 par ligne) pour le message passé en argument (source), ou via le contenu d’un fichier en précisant l’option -f. L’option -o permet également de définir le format de sortie, à savoir : raw : Données brutes Attention cependant aux retours à la ligne, un bloc doit faire 64 octets même si il contient des retours à la ligne hex : Données en hexadécimal base64 : Données en base64 On peut désormais insérer ces blocs dans le code assembleur, voici un exemple pour le message test : ;Message : test ;Init Block 1 ;Data (64 bytes) = test + \x80 + \x00*58 + \x20 ld hl,Block ;hl = Block ld a,$74 ;a = 0x74 ldi (hl),a ;(hl) = a, hl += 1 ld a,$65 ;a = 0x65 ldi (hl),a ;(hl) = a, hl += 1 ld a,$73 ;a = 0x73 ldi (hl),a ;(hl) = a, hl += 1 ld a,$74 ;a = 0x74 ldi (hl),a ;(hl) = a, hl += 1 ld a,$80 ;a = 0x80 ldi (hl),a ;(hl) = a, hl += 1 ld b,58 ;b = 58 xor a ;a = 0 initblock1: ldi (hl),a ;(hl) = a, hl += 1 dec b ;b -= 1 jr nz,initblock1 ;Si b &gt; 0 : Jump initblock1 ld a,$20 ;a = 0x20 ldi (hl),a ;(hl) = a, hl += 1 call sha1 Après avoir inséré le bloc dans la variable bloc on appel sha1 pour exécuter les calculs. Dans le cas où on a plusieurs blocs, il faut quand même appeler sha1 sur le premier bloc puis appeler sha1next à la place pour les prochains blocs ! Récupération du hash Comme indiqué dans le chapitre sur l’espace mémoire nécessaire, le hash est stocké dans les variables StateA à StateE. Le 20 octets de ces 5 variables cumulées correspondent au hash et sont accessibles de l’adresse mémoire C001 à C014. Conclusion Ce projet a été un challenge très intéressant pour moi. J’ai pris beaucoup de plaisir à découvrir une partie des possibilités qu’offre la GameBoy. Il y a encore pas mal d’optimisations/évolutions possibles pour ce projet et je n’exclus pas une éventuelle seconde partie à cet article ! Un grand merci à entropyQueen pour m’avoir motivé (sans le vouloir ^^) à me lancer dans ce projet. Sources et inspirations Code du projet Spécifications GameBoy Blog d’entropyQueen Article de Furrtek Source SHA1 en C et assembleur x86" /> <meta property="og:description" content="Suite à une petite discussion avec entropyQueen concernant ses projets sur GameBoy, je me suis lancé dans l’implémentation de l’algorithme de hachage SHA1 sur GameBoy ! C’était une première pour moi puisque j’avais encore jamais fait de programmation sur GB (et très peu fait d’assembleur également). Dans cet article je vais donc vous partager mon apprentissage en essayant d’expliquer au mieux mes recherches/analyses/réflexions pour avancer sur ce projet ! Les sources de ce projet sont disponibles ici : SHA1 GameBoy Programmation sur GameBoy Ma première étape a été de me renseigner sur les différentes méthodes possibles de programmation sur GB. Il m’est vite apparu que la seule solution réellement intéressante est l’assembleur ! On trouve d’ailleurs assez facilement un certain nombre d’articles qui traitent très bien ce sujet. Dans mon cas, je me suis arrêté sur l’article de Furrtek qui a le mérite d’être clair et assez complet pour débuter dans le domaine. Spécifications techniques de la GameBoy Il existe plusieurs versions de la documentation mais globalement le contenu est toujours le même. Afin de m’assurer de ne pas perdre ce document (comme c’est le cas avec le lien fourni par Furrtek), j’ai préféré en faire une copie ici sur mon blog : Spécifications GameBoy Ce document donne toutes les indications nécessaires pour utiliser l’ensemble des fonctionnalités de la GB ! Je ne rentrerai pas dans les détails (sauf si besoin pour certains points spécifiques), des articles comme celui de Furrtek font déjà très bien le travail. Pour ce projet j’ai utilisé l’émulateur BGB. J’avoue ne pas avoir testé les autres étant donné que celui-ci répondait parfaitement à mes besoins. Assembleur WLA DX Comme le suggère Furrtek dans son article, je vais utiliser l’assembleur WLA-DX. Suivez les instructions de compilations indiquées dans le readme ou téléchargez une version déjà compilée. Pour simplifier l’utilisation, j’ai ajouté le dossier binaries à ma variable d’environnement PATH. Voici un petit script que j’ai nommé wla-gb-build et qui permet de faciliter l’utilisation de WLA-DX (je l’ai ajouté dans le dossier binaries) : #!/bin/sh fileDir=$(dirname &quot;$1&quot;) fileName=$(basename -- &quot;$1&quot;) fileName=&quot;${fileName%.*}&quot; echo [objects]&gt;&quot;${fileDir}/linkfile&quot; echo ${fileDir}/${fileName}.o&gt;&gt;&quot;${fileDir}/linkfile&quot; [ -e &quot;${fileDir}/${fileName}.o&quot; ] &amp;&amp; rm &quot;${fileDir}/${fileName}.o&quot; wla-gb -o &quot;${fileDir}/${fileName}.o&quot; $1 wlalink -d -r -v -s &quot;${fileDir}/linkfile&quot; &quot;${fileDir}/${fileName}.gb&quot; Ainsi il suffit d’exécuter la commande wla-gb-build mon_jeu.s pour obtenir le fichier mon_jeu.gb. Algorithme SHA1 Maintenant que je sais comment créer et tester des programmes GB, je peux m’attaquer à la plus grosse partie, l’algorithme SHA1 ! La solution qui me semble la plus évidente consiste à trouver le code de cet algorithme en C, ou même directement en assembleur x86, puis de voir comment je peux l’adapter avec les instructions disponibles en z80 (enfin, la version GB qui est légèrement différente d’un véritable z80). J’ai donc trouvé mon bonheur sur ce site : https://www.nayuki.io/page/fast-sha1-hash-implementation-in-x86-assembly Plus particulièrement leur implémentation en version fast. Opérations 32 bits sur CPU 8 bits En étudiant un peu l’assembleur de la version fast je remarque, sans surprise, un certain nombre d’instructions basées sur une architecture 32 bits. Les instructions en question sont les suivantes : movl Ecrit un entier 32 bits à une adresse en mémoire andl Opération logique and entre 2 entiers 32 bits orl Opération logique or entre 2 entiers 32 bits xorl Opération logique xor entre 2 entiers 32 bits addl Additionne 2 entiers 32 bits roll Rotation des bits vers la gauche sur un entier 32 bits (les bits qui sortent re-rentrent par la droite) Concernant l’instruction bswapl (qui permet d’inverser l’ordre des 4 octets d’un entier 32 bits), elle n’est pas nécessaire en z80 (pour cet algorithme en tout cas), voir l’implémentation de addl ci-dessous pour plus de détails. Désormais il faut trouver un moyen de convertir ces instructions 32 bits pour pouvoir les utiliser sur un CPU 8 bits ! Afin de simplifier l’utilisation, je choisis arbitrairement que le registre BC correspond à la source, et le registre HL à la destination. Instruction movl Cette instruction est probablement la plus simple à réaliser puisqu’il s’agit de déplacer 4 octets d’une adresse vers une autre. movl: ;hl=bc ld e,4 ;e = 4 loopmovl: ld a,(bc) ;a = (bc) ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec e ;e -= 1 jr nz,loopmovl ;Si e != 0 : Jump loopmovl ret La valeur pointée par le registre BC est insérée dans le registre A qui est ensuite insérée à l’adresse pointée par le registre HL. Les adresses pointées par HL et BC sont incrémentées afin de passer à l’octet suivant. Ces opérations sont répétées 4 fois. Instructions andl, orl, xorl Le principe est très similaire à movl, il faut juste réaliser une opération supplémentaire (and, or, xor) sur chaque octet. Exemple pour l’instruction and : andl: ;hl&amp;=bc ld e,4 ;e = 4 loopandl: ld a,(bc) ;a = (bc) and (hl) ;a &amp;= (hl) ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec e ;e -= 1 jr nz,loopandl ;Si e != 0 : Jump loopandl ret Instruction addl Voilà enfin un peu de challenge !! Réaliser une addition de deux entiers 32 bits avec seulement des instructions sur 8 bits. A première vue il est légitime de penser que c’est compliqué, mais en réalité ça ne l’est pas ! L’instruction add permet d’additionner deux entiers 8 bits, et si 8 bits ne suffisent pas pour stocker le résultat, alors il y aura une retenue qu’on peut intercepter via le flag c (Carry Flag) ! On peut donc facilement étendre l’addition à plusieurs octets en utilisant le flag c pour vérifier si il est nécessaire d’appliquer la retenue sur l’octet suivant ! A ce niveau il faut être cohérent sur l’ordre des octets. Le résultat ne pourra pas être le même si on va de l’octet 1 à 4 (little endian) ou de l’octet 4 à 1 (big endian). Pour simplifier et éviter d’implémenter l’instruction bswapl j’ai décidé de partir sur l’ordre big endian. addl: ;hl+=bc inc bc ;bc += 1 inc bc ;bc += 1 inc bc ;bc += 1 inc hl ;hl += 1 inc hl ;hl += 1 inc hl ;hl += 1 ld d,5 ;d = 5 jp addlstart ;Jump addlstart addlnext: pop de ;UnStack de pop hl ;UnStack hl dec hl ;hl -= 1 addlstart: dec d ;d -= 1 jr z,addlend ;Si d == 0 : Jump addlend ld a,(bc) ;a = (bc) dec bc ;bc -= 1 push hl ;Stack hl push de ;Stack de add (hl) ;a += (hl) ld (hl),a ;(hl) = a jr nc,addlnext ;Si a+(hl) &lt; 256 : Jump addlnext (si pas de retenue) addlnc: dec d ;d -= 1 jr z,addlnext ;Si d == 0 : Jump addlnext (si on est sur le dernier octet) dec hl ;hl -= 1 inc (hl) ;(hl) += 1 (on applique la retenue) jr nz,addlnext ;Si (hl) != 0 : Jump addlnext jp addlnc ;Sinon Jump addlnc (on fait suivre la retenue sur l&#39;octet suivant) addlend: ret Pour commencer il faut ajouter 3 aux registres HL et BC afin de commencer le traitement sur les bons octets, puis je commence les additions octet par octet tout en appliquant bien la retenue aux octets suivants. Je sauvegarde les registres HL et DE sur la pile (Stack) afin de pouvoir procéder aux éventuels applications de retenues sans pour autant perdre le compte (puisque je dois décrémenter D et HL pour gérer correctement les retenues) puis je rétablis HL et DE pour le traitement du prochain octet (addlnext). Instruction roll On monte encore d’un cran en terme de challenge !! Je n’ai pas encore réussi à implémenter un roll générique et j’ai une doute sur la pertinence de le faire étant donné la complexité d’une telle opération comparé au besoin pour ce projet. En analysant l’algorithme SHA1 on constate que roll est utilisé seulement avec 3 décalages différents (1, 5 et 30). J’ai donc décidé de créer ces 3 roll différents sans chercher à faire une version générique. Pour cela j’ai posé sur papier chacun des 3 décalages afin de voir les correspondances des bits entre chaque octet, et ainsi pouvoir le retranscrire en assembleur. Je suis cependant curieux/preneur de toutes solutions génériques ou de toutes optimisations de mon implémentation actuelle ! Voici le roll5 en exemple : roll5: ;hl=roll(bc,5) push hl ;Stack hl pop de ;UnStack de = hl push bc ;Stack bc pop hl ;UnStack hl = bc ld b,3 ;b = 3 looproll5: ldi a,(hl) ;a = (hl), hl += 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 ld c,(hl) ;c = (hl) srl c ;c &gt;&gt;= 1 srl c ;c &gt;&gt;= 1 srl c ;c &gt;&gt;= 1 or c ;a |= c ld (de),a ;(de) = a inc de ;de += 1 dec b ;b -= 1 jr nz,looproll5 ;Si b != 0 : Jump looproll5 ldd a,(hl) ;a = (hl), hl -= 1 dec hl ;hl -= 1 dec hl ;hl -= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 ld c,(hl) ;c = (hl) srl c ;c &gt;&gt;= 1 srl c ;c &gt;&gt;= 1 srl c ;c &gt;&gt;= 1 or c ;a |= c ld (de),a ;(de) = a ret Il s’agit donc de réaliser les bons shift (décalages) sur les bons octets puis de faire un or pour fusionner les bits. Le principe est identique pour les 3 roll (1, 5 et 30) mais avec les bons décalages et les bonnes correspondances pour chacun. Espace mémoire nécessaire (variables) Voici les différentes variables qui seront nécessaires au bon fonctionnement de l’algo : Step DB ;C000 : Compteur de rounds StateA DS 4 ;C001-C004 : SHA1 A en cours StateB DS 4 ;C005-C008 : SHA1 B en cours StateC DS 4 ;C009-C00C : SHA1 C en cours StateD DS 4 ;C00D-C010 : SHA1 D en cours StateE DS 4 ;C011-C014 : SHA1 E en cours StateT DS 4 ;C015-C018 : Temporaire pour les opérations sur les State RollT DS 4 ;C019-C01C : Temporaire pour certaines opérations RoundK DS 4 ;C01D-C020 : SHA1 K du round en cours Block DS 64 ;C021-C060 : SHA1 Block (message à hacher) Schedule DS 64 ;C061-C0A0 : Temporaire pour les opérations sur Block InitA DS 4 ;C0A1-C0A5 : Sauvegarde SHA1 A à l&#39;initialisation InitB DS 4 ;C0A6-C0A9 : Sauvegarde SHA1 B à l&#39;initialisation InitC DS 4 ;C0AA-C0AD : Sauvegarde SHA1 C à l&#39;initialisation InitD DS 4 ;C0AE-C0B1 : Sauvegarde SHA1 D à l&#39;initialisation InitE DS 4 ;C0B2-C0B5 : Sauvegarde SHA1 E à l&#39;initialisation Reg1 DS 2 ;C0B6-C0B7 : Registre 1 Reg2 DS 2 ;C0B8-C0B9 : Registre 2 Total : 185 octets Les variables StateA à StateE contiennent le hash SHA1 en cours de calcul, le hash final sera donc dans ces variables également. Le hash correspond donc aux 20 octets de l’adresse C001 à l’adresse C014. Reg1 et Reg2 permettent de combler le faible nombre de registres disponibles sur la GB (seulement 3 registres 16 bits), ils servent donc de stockage d’adresse 16 bits. Ils sont nécessaires pour gérer la rotation automatique des 5 variables State à chaque round (voir le chapitre suivant). Sans eux il est possible de faire cette rotation en utilisant directement la pile (stack) mais il serait alors obligatoire de désactiver les interruptions de la GameBoy afin d’éviter d’avoir une interruption au mauvais moment qui viendrait écraser certaines données sur la pile : Voir la documentation sur les interruptions Initialisation SHA1 L’initialisation SHA1 consiste simplement à définir les valeurs des 5 états (StateA à StateE), il s’agit du vecteur d’initialisation du SHA1 par défaut : sha1: ;Init StateA = 0x67452301 ld a,$67 ld (StateA),a ld a,$45 ld (StateA+1),a ld a,$23 ld (StateA+2),a ld a,$01 ld (StateA+3),a ;Init StateB = 0xEFCDAB89 ld a,$EF ld (StateB),a ld a,$CD ld (StateB+1),a ld a,$AB ld (StateB+2),a ld a,$89 ld (StateB+3),a ;Init StateC = 0x98BADCFE ld a,$98 ld (StateC),a ld a,$BA ld (StateC+1),a ld a,$DC ld (StateC+2),a ld a,$FE ld (StateC+3),a ;Init StateD = 0x10325476 ld a,$10 ld (StateD),a ld a,$32 ld (StateD+1),a ld a,$54 ld (StateD+2),a ld a,$76 ld (StateD+3),a ;Init StateE = 0xC3D2E1F0 ld a,$C3 ld (StateE),a ld a,$D2 ld (StateE+1),a ld a,$E1 ld (StateE+2),a ld a,$F0 ld (StateE+3),a sha1next: xor a ;a = 0 ld (Step),a ;(Step) = 0 ld bc,StateA ld hl,InitA call movl ;InitA = StateA ld bc,StateB ld hl,InitB call movl ;InitB = StateB ld bc,StateC ld hl,InitC call movl ;InitC = StateC ld bc,StateD ld hl,InitD call movl ;InitD = StateD ld bc,StateE ld hl,InitE call movl ;InitE = StateE Cet algorithme procède au calcul du hash SHA1 par blocs de 64 octets (voir le chapitre sur la construction de la chaine à hacher pour plus d’informations). Il peut évidemment arriver qu’on ait besoin d’obtenir le hash de chaines bien plus longues que 64 octets, c’est pourquoi il y a un second point de départ qui permet de ne pas réinitialiser les états du SHA1 en cours, il s’agit de sha1next. Initialisation d’un round A chaque round on constate deux changements, à savoir l’incrémentation du compteur de rounds (Step) ainsi qu’une rotation des arguments. Pour le round 0, les arguments sont dans l’ordre A, B, C, D, E, puis au round suivant on constate une rotation : E, A, B, C, D, puis D, E, A, B, C et ainsi de suite pour les 80 rounds. Je commence donc par initialiser le tout premier ordre : ld hl,StateE push hl ;Stack : StateE =&gt; ArgE ld hl,StateD push hl ;Stack : StateD =&gt; ArgD ld hl,StateC push hl ;Stack : StateC =&gt; ArgC ld hl,StateB push hl ;Stack : StateB =&gt; ArgB ld hl,StateA push hl ;Stack : StateA =&gt; ArgA jp initRound0 ;Jump initRound0 J’utilise la pile afin de manipuler plus facilement ces valeurs. Le dernier entré est le premier sorti, c’est pour cela que je push de StateE à StateA et non l’inverse. Vu qu’il s’agit de l’ordre pour le round 0 je jump directement à cette étape (voir le chapitre sur le round 0 ci-dessous). Ensuite Il faut donc gérer la rotation des arguments pour les prochains rounds : loopRound: ;SP = 0 ld hl,Reg1 ;hl = Reg1 pop de ;de = sp[0] = ArgA, sp = 2 ld a,d ;a = d ldi (hl),a ;(hl) = a, hl += 1 ld a,e ;a = e ldi (hl),a ;(hl) = a, hl += 1 pop de ;de = sp[2] = ArgB, sp = 4 ld a,d ;a = d ldi (hl),a ;(hl) = a, hl += 1 ld a,e ;a = e ldi (hl),a ;(hl) = a, hl += 1 pop de ;de = sp[4] = ArgC, sp = 6 pop hl ;hl = sp[6] = ArgD, sp = 8 pop bc ;bc = sp[8] = ArgE, sp = 10 push hl ;sp = 8, sp[8] = hl = D push de ;sp = 6, sp[6] = de = C ld hl,Reg2 ;hl = Reg2 ld d,(hl) ;d = (hl) inc hl ;hl += 1 ld e,(hl) ;e = (hl) push de ;sp = 4, sp[4] = de = Reg2 = ArgB ld hl,Reg1 ;hl = Reg1 ld d,(hl) ;d = (hl) inc hl ;hl += 1 ld e,(hl) ;e = (hl) push de ;sp = 2, sp[2] = de = Reg1 = ArgA push bc ;sp = 0, sp[0] = bc = ArgE ld a,(Step) ;a = (Step) inc a ;a += 1 ld (Step),a ;(Step) = a cp a,16 jr c,loopRound0a ;Si Step &lt; 16: Jump loopRound0a cp a,20 jr c,loopRound0b ;Si Step &lt; 20: Jump loopRound0b jr z,initRound1 ;Si Step == 20: Jump initRound1 cp a,40 jr c,loopRound1 ;Si Step &lt; 40: Jump loopRound1 jr z,initRound2 ;Si Step == 40: Jump initRound2 cp a,60 jr c,loopRound2 ;Si Step &lt; 60: Jump loopRound2 jr z,initRound3 ;Si Step == 60: Jump initRound3 cp a,80 jr c,loopRound3 ;Si Step &lt; 80: Jump loopRound3 jp loopRoundEnd ;Sinon Jump loopRoundEnd Afin de simplifier les commentaires je pars du principe que SP vaut 0, ce n’est évidemment pas le cas en réalité ! A ce niveau j’ai plusieurs possibilités pour faire la rotation. Dans un premier temps j’avais réalisé cela à base de pop et de push tout en jouant avec SP pour atteindre le bon emplacement. Mais cette solution n’était pas correcte car incompatible avec les interruptions GB ! En effet, lors d’une interruption, la GameBoy va mettre en “pause” le code en cours d’exécution et faire l’équivalent d’un call vers le code de l’interruption (avec une étape en plus cependant). Cela a pour effet d’ajouter 2 adresses de retour sur la pile (pour les ret en fin d’interruption). De ce fait, si je tente de faire une rotation en me déplaçant directement dans la pile et qu’une interruption intervient en même temps, alors je verrai mes valeurs écrasées par ces adresses de retour. Pour éviter cela, j’ai ajouté deux variables (Reg1 et Reg2) qui me servent de registre tampon en complément des 3 registres 16 bits de la GB. Ainsi je peux totalement vider la pile des 5 arguments puis la reconstruire proprement sans risquer de perdre des valeurs ! Ensuite j’incrémente Step et je fais des simples comparaisons pour savoir quel round lancer. Round 0a et roundtail Initialisation du round 0 : initRound0: ;Init RoundK ROUND0 0x5A827999 ld hl,RoundK ;hl = RoundK ld a,$5A ;a = 0x5A ldi (hl),a ;(hl) = a, hl += 1 ld a,$82 ;a = 0x82 ldi (hl),a ;(hl) = a, hl += 1 ld a,$79 ;a = 0x79 ldi (hl),a ;(hl) = a, hl += 1 ld a,$99 ;a = 0x99 ldi (hl),a ;(hl) = a, hl += 1 loopRound0a: call round0a jp loopRound loopRound0b: call round0b jp loopRound On définit RoundK lors de l’initialisation du round 0 puis on appel round0a : round0a: ld a,(Step) ;a = (Step) sla a ;a *= 2 sla a ;a *= 2 ld b,0 ;b = 0 ld c,a ;c = a ld hl,Block ;hl = Block add hl,bc ;hl += bc : Block[Step * 4] push hl ;Stack hl ld hl,Schedule ;hl = Schedule add hl,bc ;hl += bc : Schedule[Step * 4] pop bc ;UnStack bc = Block[Step * 4] push hl ;Stack hl call movl ;Schedule[Step * 4] = Block[Step * 4] pop bc ;UnStack bc = Schedule[Step * 4] ld hl,sp+10 ;hl = Stack+10 = ArgE ld e,(hl) ;e = (hl) inc hl ;hl += 1 ld d,(hl) ;d = (hl) push de ;Stack de pop hl ;UnStack hl = de call addl ;ArgE += Schedule[Step * 4] jp round0 Il n’y a pas d’instruction pour réaliser directement une multiplication sur GB, cependant, un shift left revient à multiplier par deux, je le fais donc deux fois afin de multiplier par 4. Pour atteindre ArgE j’utilise le registre SP sachant que j’ai construit la pile juste avant, je peux donc récupérer l’argument souhaité. Voici d’ailleurs à quoi ressemble la pile à ce moment : SP+0 = Adresse de retour SP+2 = ArgA SP+4 = ArgB SP+6 = ArgC SP+8 = ArgD SP+10 = ArgE round0 correspond à la partie commune entre round0a et round0b : round0: ld hl,sp+6 ;hl = Stack+6 = ArgC ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call movl ;StateT = ArgC ld hl,sp+8 ;hl = Stack+8 = ArgD ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call xorl ;StateT ^= ArgD ld hl,sp+4 ;hl = Stack+4 = ArgB ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call andl ;StateT &amp;= ArgB ld hl,sp+8 ;hl = Stack+6 = ArgD ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call xorl ;StateT ^= ArgD jp roundtail round0 étant atteint via un jump, il n’y a pas d’adresse de retour en plus sur la pile, ça ne change donc pas les accès aux arguments. StateT est utilisé comme variable temporaire pour réaliser les calculs tout au long du round. Je fais un jump et non un call pour atteindre roundtail car il est toujours appelé en fin de round, autant se servir du ret de roundtail et ainsi ne pas décaler la pile avec un autre call (les arguments restent donc accessibles avec la même offset sur SP). roundtail: ld hl,sp+4 ;hl = Stack+4 = ArgB ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) push bc ;Stack bc ld hl,RollT ;hl = RollT call movl ;RollT = ArgB pop hl ;UnStack hl = ArgB ld bc,RollT ;bc = RollT call roll30 ;ArgB = roll30(RollT) ld hl,sp+10 ;hl = Stack+10 = ArgE ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = ArgE push bc ;Stack bc push bc ;Stack bc pop hl ;UnStack hl = bc ld bc,StateT ;bc = StateT call addl ;ArgE += StateT pop hl ;UnStack hl = ArgE ld bc,RoundK ;bc = RoundK call addl ;ArgE += RoundK ld hl,sp+2 ;hl = Stack+2 = ArgA ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,RollT ;hl = RollT call roll5 ;RollT = roll5(ArgA) ld hl,sp+10 ;hl = Stack+10 = ArgE ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) push bc ;Stack bc pop hl ;UnStack hl = bc ld bc,RollT ;bc = RollT call addl ;ArgE += RollT ret RollT est utilisé comme variable temporaire pour réaliser les opérations roll. Round 0b et roundschedule Les rounds 0a et 0b sont assez similaires et partagent la même valeur de K, ils ont donc la même initialisation ainsi qu’une partie de code en commun (voir ci-dessus pour l’initialisation du round). Code round0b : round0b: call roundschedule jp round0 On a déjà vu round0 ci-dessus puisqu’il s’agit du même code que pour round0a. Concernant roundschedule, il sera utile pour tous les rounds excepté round0a : roundschedule: ld a,(Step) ;a = (Step) sub 3 ;a -= 3 and 15 ;a &amp;= 15 sla a ;a *= 2 sla a ;a *= 2 ld b,0 ;b = 0 ld c,a ;c = a ld hl,Schedule ;hl = Schedule add hl,bc ;hl += bc : Schedule[(Step - 3) * 4] push hl ;Stack hl pop bc ;UnStack bc = hl ld hl,StateT ;hl = StateT call movl ;StateT = Schedule[(Step - 3) * 4] ld a,(Step) ;a = (Step) sub 8 ;a -= 8 and 15 ;a &amp;= 15 sla a ;a *= 2 sla a ;a *= 2 ld b,0 ;b = 0 ld c,a ;c = a ld hl,Schedule ;hl = Schedule add hl,bc ;hl += bc : Schedule[(Step - 8) * 4] push hl ;Stack hl pop bc ;UnStack bc = hl ld hl,StateT ;hl = StateT call xorl ;StateT ^= Schedule[(Step - 8) * 4] ld a,(Step) ;a = (Step) sub 14 ;a -= 14 and 15 ;a &amp;= 15 sla a ;a *= 2 sla a ;a *= 2 ld b,0 ;b = 0 ld c,a ;c = a ld hl,Schedule ;hl = Schedule add hl,bc ;hl += bc : Schedule[(Step - 14) * 4] push hl ;Stack hl pop bc ;UnStack bc = hl ld hl,StateT ;hl = StateT call xorl ;StateT ^= Schedule[(Step - 14) * 4] ld a,(Step) ;a = (Step) sub 16 ;a -= 16 and 15 ;a &amp;= 15 sla a ;a *= 2 sla a ;a *= 2 ld b,0 ;b = 0 ld c,a ;c = a ld hl,Schedule ;hl = Schedule add hl,bc ;hl += bc : Schedule[(Step - 16) * 4] push hl ;Stack hl pop bc ;UnStack bc = hl ld hl,StateT ;hl = StateT call xorl ;StateT ^= Schedule[(Step - 16) * 4] ld bc,StateT ;bc = StateT ld hl,RollT ;hl = RollT call movl ;RollT = StateT ld bc,RollT ;bc = RollT ld hl,StateT ;hl = StateT call roll1 ;StateT = roll1(RollT) ld hl,sp+12 ;hl = Stack+12 = ArgE ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) push bc ;Stack bc pop hl ;UnStack hl = bc ld bc,StateT ;bc = StateT call addl ;ArgE += StateT ld a,(Step) ;a = (Step) and 15 ;a &amp;= 15 sla a ;a *= 2 sla a ;a *= 2 ld b,0 ;b = 0 ld c,a ;c = a ld hl,Schedule ;hl = Schedule add hl,bc ;hl += bc : Schedule[Step * 4] ld bc,StateT ;bc = StateT call movl ;Schedule[Step * 4] = StateT ret Rien de particulier à dire, le principe est similaire au reste du code qu’on a déjà vu plus haut. Round 1 et 3 J’ai regroupé les rounds 1 et 3 dans le même chapitre car la seule différence entre les deux c’est la valeur de K (donc l’initialisation). Initialisation du round 1 : initRound1: ;Init RoundK ROUND1 0x6ED9EBA1 ld hl,RoundK ;hl = RoundK ld a,$6E ;a = 0x6E ldi (hl),a ;(hl) = a, hl += 1 ld a,$D9 ;a = 0xD9 ldi (hl),a ;(hl) = a, hl += 1 ld a,$EB ;a = 0xEB ldi (hl),a ;(hl) = a, hl += 1 ld a,$A1 ;a = 0xA1 ldi (hl),a ;(hl) = a, hl += 1 loopRound1: call round1 jp loopRound Initialisation du round 3 : initRound3: ;Init RoundK ROUND3 0xCA62C1D6 ld hl,RoundK ;hl = RoundK ld a,$CA ;a = 0xCA ldi (hl),a ;(hl) = a, hl += 1 ld a,$62 ;a = 0x62 ldi (hl),a ;(hl) = a, hl += 1 ld a,$C1 ;a = 0xC1 ldi (hl),a ;(hl) = a, hl += 1 ld a,$D6 ;a = 0xD6 ldi (hl),a ;(hl) = a, hl += 1 loopRound3: call round3 jp loopRound Code round1 et round3 : round1: round3: call roundschedule ld hl,sp+4 ;hl = Stack+4 = ArgB ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call movl ;StateT = ArgB ld hl,sp+6 ;hl = Stack+6 = ArgC ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call xorl ;StateT ^= ArgC ld hl,sp+8 ;hl = Stack+8 = ArgD ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call xorl ;StateT ^= ArgD jp roundtail Round 2 Et pour terminer, le round 2 : round2: call roundschedule ld hl,sp+6 ;hl = Stack+6 = ArgC ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call movl ;StateT = ArgC ld bc,StateT ;bc = StateT ld hl,RollT ;hl = RollT call movl ;RollT = StateT ld hl,sp+8 ;hl = Stack+8 = ArgD ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) push bc ;Stack bc : ArgD ld hl,StateT ;hl = StateT call orl ;StateT |= ArgD pop bc ;UnStack bc = ArgD ld hl,RollT ;hl = RollT call andl ;RollT &amp;= ArgD ld hl,sp+4 ;hl = Stack+4 = ArgB ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call andl ;StateT &amp;= ArgB ld bc,RollT ;bc = RollT ld hl,StateT ;hl = StateT call orl ;StateT |= RollT jp roundtail Ici j’utilise RollT comme variable temporaire en plus de StateT. Au final le nom de ces deux variables n’a pas réellement d’importance ;) Construction de la chaine à hacher (blocs SHA1) Comme vaguement évoqué dans le chapitre sur l’initialisation SHA1, cet algorithme utilise des blocs de 64 octets. Pour le moment je n’ai pas implémenté la génération des blocs, c’est donc une évolution future tout à fait envisageable ! En attendant, afin de tester correctement le calcul du SHA1, j’ai fait un petit script python afin de générer les blocs : #!/usr/bin/env python3 import getopt, sys, io import binascii def usage(): print(&quot;&quot;&quot; Usage : build-blocks.py [OPTIONS] &lt;source&gt; Options : -f Source as file -o Output format (raw,hex,base64), default : hex &quot;&quot;&quot;) sys.exit(2) def output(block, format): if format == &quot;raw&quot;: print(block.decode(&#39;unicode_escape&#39;)) elif format == &quot;hex&quot;: print(binascii.b2a_hex(block).decode()) elif format == &quot;base64&quot;: print(binascii.b2a_base64(block).decode()) def main(): try: opts, args = getopt.getopt(sys.argv[1:],&quot;o:fh&quot;,[&quot;file&quot;, &quot;output&quot;, &quot;help&quot;]) except getopt.GetoptError as error: print(error) usage() source = &#39; &#39;.join(args).encode() isFile = False out = &quot;hex&quot; for opt, arg in opts: if opt in (&quot;-h&quot;, &quot;--help&quot;): usage() elif opt in (&quot;-f&quot;, &quot;--file&quot;): isFile = True elif opt in (&quot;-o&quot;, &quot;--output&quot;): if arg in (&quot;raw&quot;, &quot;hex&quot;, &quot;base64&quot;): out = arg else: usage() else: usage() reader = open(source, &quot;rb&quot;) if isFile else io.BytesIO(source) sourcelen = 0 block = b&#39;&#39; while True: block = reader.read(64) if len(block) &lt; 64: sourcelen += len(block) break sourcelen += 64 output(block, out) block += b&#39;\x80&#39; if len(block) &gt;= 57: block += bytes(64-len(block)) output(block, out) block = b&#39;&#39; block += bytes(57-len(block)) blocklen = bytes([((sourcelen &amp; 0x1F) &lt;&lt; 3) &amp; 0xFF]) sourcelen &gt;&gt;= 5 for i in range(1, 7): blocklen += bytes([sourcelen &amp; 0xFF]) sourcelen &gt;&gt;= 8 block += blocklen[::-1] output(block, out) reader.close() if __name__ == &quot;__main__&quot;: main() Ce script permet donc de générer les blocs (1 par ligne) pour le message passé en argument (source), ou via le contenu d’un fichier en précisant l’option -f. L’option -o permet également de définir le format de sortie, à savoir : raw : Données brutes Attention cependant aux retours à la ligne, un bloc doit faire 64 octets même si il contient des retours à la ligne hex : Données en hexadécimal base64 : Données en base64 On peut désormais insérer ces blocs dans le code assembleur, voici un exemple pour le message test : ;Message : test ;Init Block 1 ;Data (64 bytes) = test + \x80 + \x00*58 + \x20 ld hl,Block ;hl = Block ld a,$74 ;a = 0x74 ldi (hl),a ;(hl) = a, hl += 1 ld a,$65 ;a = 0x65 ldi (hl),a ;(hl) = a, hl += 1 ld a,$73 ;a = 0x73 ldi (hl),a ;(hl) = a, hl += 1 ld a,$74 ;a = 0x74 ldi (hl),a ;(hl) = a, hl += 1 ld a,$80 ;a = 0x80 ldi (hl),a ;(hl) = a, hl += 1 ld b,58 ;b = 58 xor a ;a = 0 initblock1: ldi (hl),a ;(hl) = a, hl += 1 dec b ;b -= 1 jr nz,initblock1 ;Si b &gt; 0 : Jump initblock1 ld a,$20 ;a = 0x20 ldi (hl),a ;(hl) = a, hl += 1 call sha1 Après avoir inséré le bloc dans la variable bloc on appel sha1 pour exécuter les calculs. Dans le cas où on a plusieurs blocs, il faut quand même appeler sha1 sur le premier bloc puis appeler sha1next à la place pour les prochains blocs ! Récupération du hash Comme indiqué dans le chapitre sur l’espace mémoire nécessaire, le hash est stocké dans les variables StateA à StateE. Le 20 octets de ces 5 variables cumulées correspondent au hash et sont accessibles de l’adresse mémoire C001 à C014. Conclusion Ce projet a été un challenge très intéressant pour moi. J’ai pris beaucoup de plaisir à découvrir une partie des possibilités qu’offre la GameBoy. Il y a encore pas mal d’optimisations/évolutions possibles pour ce projet et je n’exclus pas une éventuelle seconde partie à cet article ! Un grand merci à entropyQueen pour m’avoir motivé (sans le vouloir ^^) à me lancer dans ce projet. Sources et inspirations Code du projet Spécifications GameBoy Blog d’entropyQueen Article de Furrtek Source SHA1 en C et assembleur x86" /> <link rel="canonical" href="https://elrindel.github.io/implementation-sha1-sur-gameboy" /> <meta property="og:url" content="https://elrindel.github.io/implementation-sha1-sur-gameboy" /> <meta property="og:site_name" content="Elrindel/Flob Blog" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2020-04-22T22:43:30+02:00" /> <script type="application/ld+json"> {"mainEntityOfPage":{"@type":"WebPage","@id":"https://elrindel.github.io/implementation-sha1-sur-gameboy"},"@type":"BlogPosting","url":"https://elrindel.github.io/implementation-sha1-sur-gameboy","headline":"Implémentation SHA1 sur GameBoy","dateModified":"2020-04-22T22:43:30+02:00","datePublished":"2020-04-22T22:43:30+02:00","description":"Suite à une petite discussion avec entropyQueen concernant ses projets sur GameBoy, je me suis lancé dans l’implémentation de l’algorithme de hachage SHA1 sur GameBoy ! C’était une première pour moi puisque j’avais encore jamais fait de programmation sur GB (et très peu fait d’assembleur également). Dans cet article je vais donc vous partager mon apprentissage en essayant d’expliquer au mieux mes recherches/analyses/réflexions pour avancer sur ce projet ! Les sources de ce projet sont disponibles ici : SHA1 GameBoy Programmation sur GameBoy Ma première étape a été de me renseigner sur les différentes méthodes possibles de programmation sur GB. Il m’est vite apparu que la seule solution réellement intéressante est l’assembleur ! On trouve d’ailleurs assez facilement un certain nombre d’articles qui traitent très bien ce sujet. Dans mon cas, je me suis arrêté sur l’article de Furrtek qui a le mérite d’être clair et assez complet pour débuter dans le domaine. Spécifications techniques de la GameBoy Il existe plusieurs versions de la documentation mais globalement le contenu est toujours le même. Afin de m’assurer de ne pas perdre ce document (comme c’est le cas avec le lien fourni par Furrtek), j’ai préféré en faire une copie ici sur mon blog : Spécifications GameBoy Ce document donne toutes les indications nécessaires pour utiliser l’ensemble des fonctionnalités de la GB ! Je ne rentrerai pas dans les détails (sauf si besoin pour certains points spécifiques), des articles comme celui de Furrtek font déjà très bien le travail. Pour ce projet j’ai utilisé l’émulateur BGB. J’avoue ne pas avoir testé les autres étant donné que celui-ci répondait parfaitement à mes besoins. Assembleur WLA DX Comme le suggère Furrtek dans son article, je vais utiliser l’assembleur WLA-DX. Suivez les instructions de compilations indiquées dans le readme ou téléchargez une version déjà compilée. Pour simplifier l’utilisation, j’ai ajouté le dossier binaries à ma variable d’environnement PATH. Voici un petit script que j’ai nommé wla-gb-build et qui permet de faciliter l’utilisation de WLA-DX (je l’ai ajouté dans le dossier binaries) : #!/bin/sh fileDir=$(dirname &quot;$1&quot;) fileName=$(basename -- &quot;$1&quot;) fileName=&quot;${fileName%.*}&quot; echo [objects]&gt;&quot;${fileDir}/linkfile&quot; echo ${fileDir}/${fileName}.o&gt;&gt;&quot;${fileDir}/linkfile&quot; [ -e &quot;${fileDir}/${fileName}.o&quot; ] &amp;&amp; rm &quot;${fileDir}/${fileName}.o&quot; wla-gb -o &quot;${fileDir}/${fileName}.o&quot; $1 wlalink -d -r -v -s &quot;${fileDir}/linkfile&quot; &quot;${fileDir}/${fileName}.gb&quot; Ainsi il suffit d’exécuter la commande wla-gb-build mon_jeu.s pour obtenir le fichier mon_jeu.gb. Algorithme SHA1 Maintenant que je sais comment créer et tester des programmes GB, je peux m’attaquer à la plus grosse partie, l’algorithme SHA1 ! La solution qui me semble la plus évidente consiste à trouver le code de cet algorithme en C, ou même directement en assembleur x86, puis de voir comment je peux l’adapter avec les instructions disponibles en z80 (enfin, la version GB qui est légèrement différente d’un véritable z80). J’ai donc trouvé mon bonheur sur ce site : https://www.nayuki.io/page/fast-sha1-hash-implementation-in-x86-assembly Plus particulièrement leur implémentation en version fast. Opérations 32 bits sur CPU 8 bits En étudiant un peu l’assembleur de la version fast je remarque, sans surprise, un certain nombre d’instructions basées sur une architecture 32 bits. Les instructions en question sont les suivantes : movl Ecrit un entier 32 bits à une adresse en mémoire andl Opération logique and entre 2 entiers 32 bits orl Opération logique or entre 2 entiers 32 bits xorl Opération logique xor entre 2 entiers 32 bits addl Additionne 2 entiers 32 bits roll Rotation des bits vers la gauche sur un entier 32 bits (les bits qui sortent re-rentrent par la droite) Concernant l’instruction bswapl (qui permet d’inverser l’ordre des 4 octets d’un entier 32 bits), elle n’est pas nécessaire en z80 (pour cet algorithme en tout cas), voir l’implémentation de addl ci-dessous pour plus de détails. Désormais il faut trouver un moyen de convertir ces instructions 32 bits pour pouvoir les utiliser sur un CPU 8 bits ! Afin de simplifier l’utilisation, je choisis arbitrairement que le registre BC correspond à la source, et le registre HL à la destination. Instruction movl Cette instruction est probablement la plus simple à réaliser puisqu’il s’agit de déplacer 4 octets d’une adresse vers une autre. movl: ;hl=bc ld e,4 ;e = 4 loopmovl: ld a,(bc) ;a = (bc) ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec e ;e -= 1 jr nz,loopmovl ;Si e != 0 : Jump loopmovl ret La valeur pointée par le registre BC est insérée dans le registre A qui est ensuite insérée à l’adresse pointée par le registre HL. Les adresses pointées par HL et BC sont incrémentées afin de passer à l’octet suivant. Ces opérations sont répétées 4 fois. Instructions andl, orl, xorl Le principe est très similaire à movl, il faut juste réaliser une opération supplémentaire (and, or, xor) sur chaque octet. Exemple pour l’instruction and : andl: ;hl&amp;=bc ld e,4 ;e = 4 loopandl: ld a,(bc) ;a = (bc) and (hl) ;a &amp;= (hl) ldi (hl),a ;(hl) = a, hl += 1 inc bc ;bc += 1 dec e ;e -= 1 jr nz,loopandl ;Si e != 0 : Jump loopandl ret Instruction addl Voilà enfin un peu de challenge !! Réaliser une addition de deux entiers 32 bits avec seulement des instructions sur 8 bits. A première vue il est légitime de penser que c’est compliqué, mais en réalité ça ne l’est pas ! L’instruction add permet d’additionner deux entiers 8 bits, et si 8 bits ne suffisent pas pour stocker le résultat, alors il y aura une retenue qu’on peut intercepter via le flag c (Carry Flag) ! On peut donc facilement étendre l’addition à plusieurs octets en utilisant le flag c pour vérifier si il est nécessaire d’appliquer la retenue sur l’octet suivant ! A ce niveau il faut être cohérent sur l’ordre des octets. Le résultat ne pourra pas être le même si on va de l’octet 1 à 4 (little endian) ou de l’octet 4 à 1 (big endian). Pour simplifier et éviter d’implémenter l’instruction bswapl j’ai décidé de partir sur l’ordre big endian. addl: ;hl+=bc inc bc ;bc += 1 inc bc ;bc += 1 inc bc ;bc += 1 inc hl ;hl += 1 inc hl ;hl += 1 inc hl ;hl += 1 ld d,5 ;d = 5 jp addlstart ;Jump addlstart addlnext: pop de ;UnStack de pop hl ;UnStack hl dec hl ;hl -= 1 addlstart: dec d ;d -= 1 jr z,addlend ;Si d == 0 : Jump addlend ld a,(bc) ;a = (bc) dec bc ;bc -= 1 push hl ;Stack hl push de ;Stack de add (hl) ;a += (hl) ld (hl),a ;(hl) = a jr nc,addlnext ;Si a+(hl) &lt; 256 : Jump addlnext (si pas de retenue) addlnc: dec d ;d -= 1 jr z,addlnext ;Si d == 0 : Jump addlnext (si on est sur le dernier octet) dec hl ;hl -= 1 inc (hl) ;(hl) += 1 (on applique la retenue) jr nz,addlnext ;Si (hl) != 0 : Jump addlnext jp addlnc ;Sinon Jump addlnc (on fait suivre la retenue sur l&#39;octet suivant) addlend: ret Pour commencer il faut ajouter 3 aux registres HL et BC afin de commencer le traitement sur les bons octets, puis je commence les additions octet par octet tout en appliquant bien la retenue aux octets suivants. Je sauvegarde les registres HL et DE sur la pile (Stack) afin de pouvoir procéder aux éventuels applications de retenues sans pour autant perdre le compte (puisque je dois décrémenter D et HL pour gérer correctement les retenues) puis je rétablis HL et DE pour le traitement du prochain octet (addlnext). Instruction roll On monte encore d’un cran en terme de challenge !! Je n’ai pas encore réussi à implémenter un roll générique et j’ai une doute sur la pertinence de le faire étant donné la complexité d’une telle opération comparé au besoin pour ce projet. En analysant l’algorithme SHA1 on constate que roll est utilisé seulement avec 3 décalages différents (1, 5 et 30). J’ai donc décidé de créer ces 3 roll différents sans chercher à faire une version générique. Pour cela j’ai posé sur papier chacun des 3 décalages afin de voir les correspondances des bits entre chaque octet, et ainsi pouvoir le retranscrire en assembleur. Je suis cependant curieux/preneur de toutes solutions génériques ou de toutes optimisations de mon implémentation actuelle ! Voici le roll5 en exemple : roll5: ;hl=roll(bc,5) push hl ;Stack hl pop de ;UnStack de = hl push bc ;Stack bc pop hl ;UnStack hl = bc ld b,3 ;b = 3 looproll5: ldi a,(hl) ;a = (hl), hl += 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 ld c,(hl) ;c = (hl) srl c ;c &gt;&gt;= 1 srl c ;c &gt;&gt;= 1 srl c ;c &gt;&gt;= 1 or c ;a |= c ld (de),a ;(de) = a inc de ;de += 1 dec b ;b -= 1 jr nz,looproll5 ;Si b != 0 : Jump looproll5 ldd a,(hl) ;a = (hl), hl -= 1 dec hl ;hl -= 1 dec hl ;hl -= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 sla a ;a &lt;&lt;= 1 ld c,(hl) ;c = (hl) srl c ;c &gt;&gt;= 1 srl c ;c &gt;&gt;= 1 srl c ;c &gt;&gt;= 1 or c ;a |= c ld (de),a ;(de) = a ret Il s’agit donc de réaliser les bons shift (décalages) sur les bons octets puis de faire un or pour fusionner les bits. Le principe est identique pour les 3 roll (1, 5 et 30) mais avec les bons décalages et les bonnes correspondances pour chacun. Espace mémoire nécessaire (variables) Voici les différentes variables qui seront nécessaires au bon fonctionnement de l’algo : Step DB ;C000 : Compteur de rounds StateA DS 4 ;C001-C004 : SHA1 A en cours StateB DS 4 ;C005-C008 : SHA1 B en cours StateC DS 4 ;C009-C00C : SHA1 C en cours StateD DS 4 ;C00D-C010 : SHA1 D en cours StateE DS 4 ;C011-C014 : SHA1 E en cours StateT DS 4 ;C015-C018 : Temporaire pour les opérations sur les State RollT DS 4 ;C019-C01C : Temporaire pour certaines opérations RoundK DS 4 ;C01D-C020 : SHA1 K du round en cours Block DS 64 ;C021-C060 : SHA1 Block (message à hacher) Schedule DS 64 ;C061-C0A0 : Temporaire pour les opérations sur Block InitA DS 4 ;C0A1-C0A5 : Sauvegarde SHA1 A à l&#39;initialisation InitB DS 4 ;C0A6-C0A9 : Sauvegarde SHA1 B à l&#39;initialisation InitC DS 4 ;C0AA-C0AD : Sauvegarde SHA1 C à l&#39;initialisation InitD DS 4 ;C0AE-C0B1 : Sauvegarde SHA1 D à l&#39;initialisation InitE DS 4 ;C0B2-C0B5 : Sauvegarde SHA1 E à l&#39;initialisation Reg1 DS 2 ;C0B6-C0B7 : Registre 1 Reg2 DS 2 ;C0B8-C0B9 : Registre 2 Total : 185 octets Les variables StateA à StateE contiennent le hash SHA1 en cours de calcul, le hash final sera donc dans ces variables également. Le hash correspond donc aux 20 octets de l’adresse C001 à l’adresse C014. Reg1 et Reg2 permettent de combler le faible nombre de registres disponibles sur la GB (seulement 3 registres 16 bits), ils servent donc de stockage d’adresse 16 bits. Ils sont nécessaires pour gérer la rotation automatique des 5 variables State à chaque round (voir le chapitre suivant). Sans eux il est possible de faire cette rotation en utilisant directement la pile (stack) mais il serait alors obligatoire de désactiver les interruptions de la GameBoy afin d’éviter d’avoir une interruption au mauvais moment qui viendrait écraser certaines données sur la pile : Voir la documentation sur les interruptions Initialisation SHA1 L’initialisation SHA1 consiste simplement à définir les valeurs des 5 états (StateA à StateE), il s’agit du vecteur d’initialisation du SHA1 par défaut : sha1: ;Init StateA = 0x67452301 ld a,$67 ld (StateA),a ld a,$45 ld (StateA+1),a ld a,$23 ld (StateA+2),a ld a,$01 ld (StateA+3),a ;Init StateB = 0xEFCDAB89 ld a,$EF ld (StateB),a ld a,$CD ld (StateB+1),a ld a,$AB ld (StateB+2),a ld a,$89 ld (StateB+3),a ;Init StateC = 0x98BADCFE ld a,$98 ld (StateC),a ld a,$BA ld (StateC+1),a ld a,$DC ld (StateC+2),a ld a,$FE ld (StateC+3),a ;Init StateD = 0x10325476 ld a,$10 ld (StateD),a ld a,$32 ld (StateD+1),a ld a,$54 ld (StateD+2),a ld a,$76 ld (StateD+3),a ;Init StateE = 0xC3D2E1F0 ld a,$C3 ld (StateE),a ld a,$D2 ld (StateE+1),a ld a,$E1 ld (StateE+2),a ld a,$F0 ld (StateE+3),a sha1next: xor a ;a = 0 ld (Step),a ;(Step) = 0 ld bc,StateA ld hl,InitA call movl ;InitA = StateA ld bc,StateB ld hl,InitB call movl ;InitB = StateB ld bc,StateC ld hl,InitC call movl ;InitC = StateC ld bc,StateD ld hl,InitD call movl ;InitD = StateD ld bc,StateE ld hl,InitE call movl ;InitE = StateE Cet algorithme procède au calcul du hash SHA1 par blocs de 64 octets (voir le chapitre sur la construction de la chaine à hacher pour plus d’informations). Il peut évidemment arriver qu’on ait besoin d’obtenir le hash de chaines bien plus longues que 64 octets, c’est pourquoi il y a un second point de départ qui permet de ne pas réinitialiser les états du SHA1 en cours, il s’agit de sha1next. Initialisation d’un round A chaque round on constate deux changements, à savoir l’incrémentation du compteur de rounds (Step) ainsi qu’une rotation des arguments. Pour le round 0, les arguments sont dans l’ordre A, B, C, D, E, puis au round suivant on constate une rotation : E, A, B, C, D, puis D, E, A, B, C et ainsi de suite pour les 80 rounds. Je commence donc par initialiser le tout premier ordre : ld hl,StateE push hl ;Stack : StateE =&gt; ArgE ld hl,StateD push hl ;Stack : StateD =&gt; ArgD ld hl,StateC push hl ;Stack : StateC =&gt; ArgC ld hl,StateB push hl ;Stack : StateB =&gt; ArgB ld hl,StateA push hl ;Stack : StateA =&gt; ArgA jp initRound0 ;Jump initRound0 J’utilise la pile afin de manipuler plus facilement ces valeurs. Le dernier entré est le premier sorti, c’est pour cela que je push de StateE à StateA et non l’inverse. Vu qu’il s’agit de l’ordre pour le round 0 je jump directement à cette étape (voir le chapitre sur le round 0 ci-dessous). Ensuite Il faut donc gérer la rotation des arguments pour les prochains rounds : loopRound: ;SP = 0 ld hl,Reg1 ;hl = Reg1 pop de ;de = sp[0] = ArgA, sp = 2 ld a,d ;a = d ldi (hl),a ;(hl) = a, hl += 1 ld a,e ;a = e ldi (hl),a ;(hl) = a, hl += 1 pop de ;de = sp[2] = ArgB, sp = 4 ld a,d ;a = d ldi (hl),a ;(hl) = a, hl += 1 ld a,e ;a = e ldi (hl),a ;(hl) = a, hl += 1 pop de ;de = sp[4] = ArgC, sp = 6 pop hl ;hl = sp[6] = ArgD, sp = 8 pop bc ;bc = sp[8] = ArgE, sp = 10 push hl ;sp = 8, sp[8] = hl = D push de ;sp = 6, sp[6] = de = C ld hl,Reg2 ;hl = Reg2 ld d,(hl) ;d = (hl) inc hl ;hl += 1 ld e,(hl) ;e = (hl) push de ;sp = 4, sp[4] = de = Reg2 = ArgB ld hl,Reg1 ;hl = Reg1 ld d,(hl) ;d = (hl) inc hl ;hl += 1 ld e,(hl) ;e = (hl) push de ;sp = 2, sp[2] = de = Reg1 = ArgA push bc ;sp = 0, sp[0] = bc = ArgE ld a,(Step) ;a = (Step) inc a ;a += 1 ld (Step),a ;(Step) = a cp a,16 jr c,loopRound0a ;Si Step &lt; 16: Jump loopRound0a cp a,20 jr c,loopRound0b ;Si Step &lt; 20: Jump loopRound0b jr z,initRound1 ;Si Step == 20: Jump initRound1 cp a,40 jr c,loopRound1 ;Si Step &lt; 40: Jump loopRound1 jr z,initRound2 ;Si Step == 40: Jump initRound2 cp a,60 jr c,loopRound2 ;Si Step &lt; 60: Jump loopRound2 jr z,initRound3 ;Si Step == 60: Jump initRound3 cp a,80 jr c,loopRound3 ;Si Step &lt; 80: Jump loopRound3 jp loopRoundEnd ;Sinon Jump loopRoundEnd Afin de simplifier les commentaires je pars du principe que SP vaut 0, ce n’est évidemment pas le cas en réalité ! A ce niveau j’ai plusieurs possibilités pour faire la rotation. Dans un premier temps j’avais réalisé cela à base de pop et de push tout en jouant avec SP pour atteindre le bon emplacement. Mais cette solution n’était pas correcte car incompatible avec les interruptions GB ! En effet, lors d’une interruption, la GameBoy va mettre en “pause” le code en cours d’exécution et faire l’équivalent d’un call vers le code de l’interruption (avec une étape en plus cependant). Cela a pour effet d’ajouter 2 adresses de retour sur la pile (pour les ret en fin d’interruption). De ce fait, si je tente de faire une rotation en me déplaçant directement dans la pile et qu’une interruption intervient en même temps, alors je verrai mes valeurs écrasées par ces adresses de retour. Pour éviter cela, j’ai ajouté deux variables (Reg1 et Reg2) qui me servent de registre tampon en complément des 3 registres 16 bits de la GB. Ainsi je peux totalement vider la pile des 5 arguments puis la reconstruire proprement sans risquer de perdre des valeurs ! Ensuite j’incrémente Step et je fais des simples comparaisons pour savoir quel round lancer. Round 0a et roundtail Initialisation du round 0 : initRound0: ;Init RoundK ROUND0 0x5A827999 ld hl,RoundK ;hl = RoundK ld a,$5A ;a = 0x5A ldi (hl),a ;(hl) = a, hl += 1 ld a,$82 ;a = 0x82 ldi (hl),a ;(hl) = a, hl += 1 ld a,$79 ;a = 0x79 ldi (hl),a ;(hl) = a, hl += 1 ld a,$99 ;a = 0x99 ldi (hl),a ;(hl) = a, hl += 1 loopRound0a: call round0a jp loopRound loopRound0b: call round0b jp loopRound On définit RoundK lors de l’initialisation du round 0 puis on appel round0a : round0a: ld a,(Step) ;a = (Step) sla a ;a *= 2 sla a ;a *= 2 ld b,0 ;b = 0 ld c,a ;c = a ld hl,Block ;hl = Block add hl,bc ;hl += bc : Block[Step * 4] push hl ;Stack hl ld hl,Schedule ;hl = Schedule add hl,bc ;hl += bc : Schedule[Step * 4] pop bc ;UnStack bc = Block[Step * 4] push hl ;Stack hl call movl ;Schedule[Step * 4] = Block[Step * 4] pop bc ;UnStack bc = Schedule[Step * 4] ld hl,sp+10 ;hl = Stack+10 = ArgE ld e,(hl) ;e = (hl) inc hl ;hl += 1 ld d,(hl) ;d = (hl) push de ;Stack de pop hl ;UnStack hl = de call addl ;ArgE += Schedule[Step * 4] jp round0 Il n’y a pas d’instruction pour réaliser directement une multiplication sur GB, cependant, un shift left revient à multiplier par deux, je le fais donc deux fois afin de multiplier par 4. Pour atteindre ArgE j’utilise le registre SP sachant que j’ai construit la pile juste avant, je peux donc récupérer l’argument souhaité. Voici d’ailleurs à quoi ressemble la pile à ce moment : SP+0 = Adresse de retour SP+2 = ArgA SP+4 = ArgB SP+6 = ArgC SP+8 = ArgD SP+10 = ArgE round0 correspond à la partie commune entre round0a et round0b : round0: ld hl,sp+6 ;hl = Stack+6 = ArgC ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call movl ;StateT = ArgC ld hl,sp+8 ;hl = Stack+8 = ArgD ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call xorl ;StateT ^= ArgD ld hl,sp+4 ;hl = Stack+4 = ArgB ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call andl ;StateT &amp;= ArgB ld hl,sp+8 ;hl = Stack+6 = ArgD ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call xorl ;StateT ^= ArgD jp roundtail round0 étant atteint via un jump, il n’y a pas d’adresse de retour en plus sur la pile, ça ne change donc pas les accès aux arguments. StateT est utilisé comme variable temporaire pour réaliser les calculs tout au long du round. Je fais un jump et non un call pour atteindre roundtail car il est toujours appelé en fin de round, autant se servir du ret de roundtail et ainsi ne pas décaler la pile avec un autre call (les arguments restent donc accessibles avec la même offset sur SP). roundtail: ld hl,sp+4 ;hl = Stack+4 = ArgB ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) push bc ;Stack bc ld hl,RollT ;hl = RollT call movl ;RollT = ArgB pop hl ;UnStack hl = ArgB ld bc,RollT ;bc = RollT call roll30 ;ArgB = roll30(RollT) ld hl,sp+10 ;hl = Stack+10 = ArgE ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = ArgE push bc ;Stack bc push bc ;Stack bc pop hl ;UnStack hl = bc ld bc,StateT ;bc = StateT call addl ;ArgE += StateT pop hl ;UnStack hl = ArgE ld bc,RoundK ;bc = RoundK call addl ;ArgE += RoundK ld hl,sp+2 ;hl = Stack+2 = ArgA ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,RollT ;hl = RollT call roll5 ;RollT = roll5(ArgA) ld hl,sp+10 ;hl = Stack+10 = ArgE ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) push bc ;Stack bc pop hl ;UnStack hl = bc ld bc,RollT ;bc = RollT call addl ;ArgE += RollT ret RollT est utilisé comme variable temporaire pour réaliser les opérations roll. Round 0b et roundschedule Les rounds 0a et 0b sont assez similaires et partagent la même valeur de K, ils ont donc la même initialisation ainsi qu’une partie de code en commun (voir ci-dessus pour l’initialisation du round). Code round0b : round0b: call roundschedule jp round0 On a déjà vu round0 ci-dessus puisqu’il s’agit du même code que pour round0a. Concernant roundschedule, il sera utile pour tous les rounds excepté round0a : roundschedule: ld a,(Step) ;a = (Step) sub 3 ;a -= 3 and 15 ;a &amp;= 15 sla a ;a *= 2 sla a ;a *= 2 ld b,0 ;b = 0 ld c,a ;c = a ld hl,Schedule ;hl = Schedule add hl,bc ;hl += bc : Schedule[(Step - 3) * 4] push hl ;Stack hl pop bc ;UnStack bc = hl ld hl,StateT ;hl = StateT call movl ;StateT = Schedule[(Step - 3) * 4] ld a,(Step) ;a = (Step) sub 8 ;a -= 8 and 15 ;a &amp;= 15 sla a ;a *= 2 sla a ;a *= 2 ld b,0 ;b = 0 ld c,a ;c = a ld hl,Schedule ;hl = Schedule add hl,bc ;hl += bc : Schedule[(Step - 8) * 4] push hl ;Stack hl pop bc ;UnStack bc = hl ld hl,StateT ;hl = StateT call xorl ;StateT ^= Schedule[(Step - 8) * 4] ld a,(Step) ;a = (Step) sub 14 ;a -= 14 and 15 ;a &amp;= 15 sla a ;a *= 2 sla a ;a *= 2 ld b,0 ;b = 0 ld c,a ;c = a ld hl,Schedule ;hl = Schedule add hl,bc ;hl += bc : Schedule[(Step - 14) * 4] push hl ;Stack hl pop bc ;UnStack bc = hl ld hl,StateT ;hl = StateT call xorl ;StateT ^= Schedule[(Step - 14) * 4] ld a,(Step) ;a = (Step) sub 16 ;a -= 16 and 15 ;a &amp;= 15 sla a ;a *= 2 sla a ;a *= 2 ld b,0 ;b = 0 ld c,a ;c = a ld hl,Schedule ;hl = Schedule add hl,bc ;hl += bc : Schedule[(Step - 16) * 4] push hl ;Stack hl pop bc ;UnStack bc = hl ld hl,StateT ;hl = StateT call xorl ;StateT ^= Schedule[(Step - 16) * 4] ld bc,StateT ;bc = StateT ld hl,RollT ;hl = RollT call movl ;RollT = StateT ld bc,RollT ;bc = RollT ld hl,StateT ;hl = StateT call roll1 ;StateT = roll1(RollT) ld hl,sp+12 ;hl = Stack+12 = ArgE ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) push bc ;Stack bc pop hl ;UnStack hl = bc ld bc,StateT ;bc = StateT call addl ;ArgE += StateT ld a,(Step) ;a = (Step) and 15 ;a &amp;= 15 sla a ;a *= 2 sla a ;a *= 2 ld b,0 ;b = 0 ld c,a ;c = a ld hl,Schedule ;hl = Schedule add hl,bc ;hl += bc : Schedule[Step * 4] ld bc,StateT ;bc = StateT call movl ;Schedule[Step * 4] = StateT ret Rien de particulier à dire, le principe est similaire au reste du code qu’on a déjà vu plus haut. Round 1 et 3 J’ai regroupé les rounds 1 et 3 dans le même chapitre car la seule différence entre les deux c’est la valeur de K (donc l’initialisation). Initialisation du round 1 : initRound1: ;Init RoundK ROUND1 0x6ED9EBA1 ld hl,RoundK ;hl = RoundK ld a,$6E ;a = 0x6E ldi (hl),a ;(hl) = a, hl += 1 ld a,$D9 ;a = 0xD9 ldi (hl),a ;(hl) = a, hl += 1 ld a,$EB ;a = 0xEB ldi (hl),a ;(hl) = a, hl += 1 ld a,$A1 ;a = 0xA1 ldi (hl),a ;(hl) = a, hl += 1 loopRound1: call round1 jp loopRound Initialisation du round 3 : initRound3: ;Init RoundK ROUND3 0xCA62C1D6 ld hl,RoundK ;hl = RoundK ld a,$CA ;a = 0xCA ldi (hl),a ;(hl) = a, hl += 1 ld a,$62 ;a = 0x62 ldi (hl),a ;(hl) = a, hl += 1 ld a,$C1 ;a = 0xC1 ldi (hl),a ;(hl) = a, hl += 1 ld a,$D6 ;a = 0xD6 ldi (hl),a ;(hl) = a, hl += 1 loopRound3: call round3 jp loopRound Code round1 et round3 : round1: round3: call roundschedule ld hl,sp+4 ;hl = Stack+4 = ArgB ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call movl ;StateT = ArgB ld hl,sp+6 ;hl = Stack+6 = ArgC ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call xorl ;StateT ^= ArgC ld hl,sp+8 ;hl = Stack+8 = ArgD ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call xorl ;StateT ^= ArgD jp roundtail Round 2 Et pour terminer, le round 2 : round2: call roundschedule ld hl,sp+6 ;hl = Stack+6 = ArgC ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call movl ;StateT = ArgC ld bc,StateT ;bc = StateT ld hl,RollT ;hl = RollT call movl ;RollT = StateT ld hl,sp+8 ;hl = Stack+8 = ArgD ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) push bc ;Stack bc : ArgD ld hl,StateT ;hl = StateT call orl ;StateT |= ArgD pop bc ;UnStack bc = ArgD ld hl,RollT ;hl = RollT call andl ;RollT &amp;= ArgD ld hl,sp+4 ;hl = Stack+4 = ArgB ld c,(hl) ;c = (hl) inc hl ;hl += 1 ld b,(hl) ;b = (hl) ld hl,StateT ;hl = StateT call andl ;StateT &amp;= ArgB ld bc,RollT ;bc = RollT ld hl,StateT ;hl = StateT call orl ;StateT |= RollT jp roundtail Ici j’utilise RollT comme variable temporaire en plus de StateT. Au final le nom de ces deux variables n’a pas réellement d’importance ;) Construction de la chaine à hacher (blocs SHA1) Comme vaguement évoqué dans le chapitre sur l’initialisation SHA1, cet algorithme utilise des blocs de 64 octets. Pour le moment je n’ai pas implémenté la génération des blocs, c’est donc une évolution future tout à fait envisageable ! En attendant, afin de tester correctement le calcul du SHA1, j’ai fait un petit script python afin de générer les blocs : #!/usr/bin/env python3 import getopt, sys, io import binascii def usage(): print(&quot;&quot;&quot; Usage : build-blocks.py [OPTIONS] &lt;source&gt; Options : -f Source as file -o Output format (raw,hex,base64), default : hex &quot;&quot;&quot;) sys.exit(2) def output(block, format): if format == &quot;raw&quot;: print(block.decode(&#39;unicode_escape&#39;)) elif format == &quot;hex&quot;: print(binascii.b2a_hex(block).decode()) elif format == &quot;base64&quot;: print(binascii.b2a_base64(block).decode()) def main(): try: opts, args = getopt.getopt(sys.argv[1:],&quot;o:fh&quot;,[&quot;file&quot;, &quot;output&quot;, &quot;help&quot;]) except getopt.GetoptError as error: print(error) usage() source = &#39; &#39;.join(args).encode() isFile = False out = &quot;hex&quot; for opt, arg in opts: if opt in (&quot;-h&quot;, &quot;--help&quot;): usage() elif opt in (&quot;-f&quot;, &quot;--file&quot;): isFile = True elif opt in (&quot;-o&quot;, &quot;--output&quot;): if arg in (&quot;raw&quot;, &quot;hex&quot;, &quot;base64&quot;): out = arg else: usage() else: usage() reader = open(source, &quot;rb&quot;) if isFile else io.BytesIO(source) sourcelen = 0 block = b&#39;&#39; while True: block = reader.read(64) if len(block) &lt; 64: sourcelen += len(block) break sourcelen += 64 output(block, out) block += b&#39;\\x80&#39; if len(block) &gt;= 57: block += bytes(64-len(block)) output(block, out) block = b&#39;&#39; block += bytes(57-len(block)) blocklen = bytes([((sourcelen &amp; 0x1F) &lt;&lt; 3) &amp; 0xFF]) sourcelen &gt;&gt;= 5 for i in range(1, 7): blocklen += bytes([sourcelen &amp; 0xFF]) sourcelen &gt;&gt;= 8 block += blocklen[::-1] output(block, out) reader.close() if __name__ == &quot;__main__&quot;: main() Ce script permet donc de générer les blocs (1 par ligne) pour le message passé en argument (source), ou via le contenu d’un fichier en précisant l’option -f. L’option -o permet également de définir le format de sortie, à savoir : raw : Données brutes Attention cependant aux retours à la ligne, un bloc doit faire 64 octets même si il contient des retours à la ligne hex : Données en hexadécimal base64 : Données en base64 On peut désormais insérer ces blocs dans le code assembleur, voici un exemple pour le message test : ;Message : test ;Init Block 1 ;Data (64 bytes) = test + \\x80 + \\x00*58 + \\x20 ld hl,Block ;hl = Block ld a,$74 ;a = 0x74 ldi (hl),a ;(hl) = a, hl += 1 ld a,$65 ;a = 0x65 ldi (hl),a ;(hl) = a, hl += 1 ld a,$73 ;a = 0x73 ldi (hl),a ;(hl) = a, hl += 1 ld a,$74 ;a = 0x74 ldi (hl),a ;(hl) = a, hl += 1 ld a,$80 ;a = 0x80 ldi (hl),a ;(hl) = a, hl += 1 ld b,58 ;b = 58 xor a ;a = 0 initblock1: ldi (hl),a ;(hl) = a, hl += 1 dec b ;b -= 1 jr nz,initblock1 ;Si b &gt; 0 : Jump initblock1 ld a,$20 ;a = 0x20 ldi (hl),a ;(hl) = a, hl += 1 call sha1 Après avoir inséré le bloc dans la variable bloc on appel sha1 pour exécuter les calculs. Dans le cas où on a plusieurs blocs, il faut quand même appeler sha1 sur le premier bloc puis appeler sha1next à la place pour les prochains blocs ! Récupération du hash Comme indiqué dans le chapitre sur l’espace mémoire nécessaire, le hash est stocké dans les variables StateA à StateE. Le 20 octets de ces 5 variables cumulées correspondent au hash et sont accessibles de l’adresse mémoire C001 à C014. Conclusion Ce projet a été un challenge très intéressant pour moi. J’ai pris beaucoup de plaisir à découvrir une partie des possibilités qu’offre la GameBoy. Il y a encore pas mal d’optimisations/évolutions possibles pour ce projet et je n’exclus pas une éventuelle seconde partie à cet article ! Un grand merci à entropyQueen pour m’avoir motivé (sans le vouloir ^^) à me lancer dans ce projet. Sources et inspirations Code du projet Spécifications GameBoy Blog d’entropyQueen Article de Furrtek Source SHA1 en C et assembleur x86","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> <link rel="shortcut icon" href="/favicon.ico" type="image/icon"> <link rel="icon" href="/favicon.ico" type="image/icon"> <!-- stylesheets --> <link rel="stylesheet" type="text/css" href="/assets/css/base.css"> <link rel="stylesheet" type="text/css" href="/assets/css/simpleLightbox.min.css"> <link rel="stylesheet" type="text/css" href="/assets/css/highlight-theme.css"> <link rel="stylesheet" type="text/css" href="/assets/css/rouge-code.css"> <link rel="stylesheet" type="text/css" href="/assets/css/post.css"> <!--[if lt IE 9]> <script src="/assets/js/html5shiv.js"></script> <![endif]--> </head> <body> <header id="l-header"> <div class="container"> <div class="row logo"> <div class="col-lg-7"> <div class="blog-title"><a href="/">Elrindel/Flob</a></div> </div> <div class="col-lg-5"> </div> </div> <div class="navicon"> <i class="gg-menu"></i> </div> <div class="row navbar"> <nav class="col-md-12"> <ul class="row"> <li class="col-lg-3"><a href="/">Accueil</a></li> <li class="col-lg-3"><a href="https://github.com/Elrindel/" target="_blank">Github</a></li> <li class="col-lg-3"><a href="/liens">Liens</a></li> </ul> </nav> </div> </div> </header> <section id="l-main"> <div class="container"> <div class="row"> <div id="markdown-container" class="col-lg-9"> <header> <h1 id="post-title">Implémentation SHA1 sur GameBoy</h1> <ul class="tags clearfix"> </ul> <p id="post-meta">Publié le : <b>22 Apr 2020</b> Catégories : <b>gameboy</b> </p> </header> <p>Suite à une petite discussion avec <a href="https://ark444.github.io/" target="_blank">entropyQueen</a> concernant ses projets sur GameBoy, je me suis lancé dans l’implémentation de l’algorithme de hachage SHA1 sur GameBoy !</p> <p>C’était une première pour moi puisque j’avais encore jamais fait de programmation sur GB (et très peu fait d’assembleur également). Dans cet article je vais donc vous partager mon apprentissage en essayant d’expliquer au mieux mes recherches/analyses/réflexions pour avancer sur ce projet !</p> <p>Les sources de ce projet sont disponibles ici : <a href="https://github.com/Elrindel/SHA1-GameBoy" target="_blank">SHA1 GameBoy</a></p> <h2 id="programmation-sur-gameboy">Programmation sur GameBoy</h2> <p>Ma première étape a été de me renseigner sur les différentes méthodes possibles de programmation sur GB.</p> <p>Il m’est vite apparu que la seule solution réellement intéressante est l’assembleur !</p> <p>On trouve d’ailleurs assez facilement un certain nombre d’articles qui traitent très bien ce sujet. Dans mon cas, je me suis arrêté sur l’article de <a href="http://furrtek.free.fr/?a=gbasm" target="_blank">Furrtek</a> qui a le mérite d’être clair et assez complet pour débuter dans le domaine.</p> <h3 id="spécifications-techniques-de-la-gameboy">Spécifications techniques de la GameBoy</h3> <p>Il existe plusieurs versions de la documentation mais globalement le contenu est toujours le même.<br /> Afin de m’assurer de ne pas perdre ce document (comme c’est le cas avec le lien fourni par Furrtek), j’ai préféré en faire une copie ici sur mon blog : <a href="specifications-gameboy" target="_blank">Spécifications GameBoy</a></p> <p>Ce document donne toutes les indications nécessaires pour utiliser l’ensemble des fonctionnalités de la GB !</p> <p>Je ne rentrerai pas dans les détails (sauf si besoin pour certains points spécifiques), des articles comme celui de Furrtek font déjà très bien le travail.</p> <p>Pour ce projet j’ai utilisé l’émulateur BGB. J’avoue ne pas avoir testé les autres étant donné que celui-ci répondait parfaitement à mes besoins.</p> <h3 id="assembleur-wla-dx">Assembleur WLA DX</h3> <p>Comme le suggère Furrtek dans son article, je vais utiliser l’assembleur <a href="https://github.com/vhelin/wla-dx" target="_blank">WLA-DX</a>.<br /> Suivez les instructions de compilations indiquées dans le <a href="https://github.com/vhelin/wla-dx/blob/master/README.md" target="_blank">readme</a> ou <a href="http://www.villehelin.com/wla.html" target="_blank">téléchargez une version déjà compilée</a>.</p> <p>Pour simplifier l’utilisation, j’ai ajouté le dossier <strong>binaries</strong> à ma variable d’environnement <strong>PATH</strong>.</p> <p>Voici un petit script que j’ai nommé <code class="highlighter-rouge">wla-gb-build</code> et qui permet de faciliter l’utilisation de <strong>WLA-DX</strong> (je l’ai ajouté dans le dossier <strong>binaries</strong>) :</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/sh</span>

<span class="nv">fileDir</span><span class="o">=</span><span class="si">$(</span><span class="nb">dirname</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span><span class="si">)</span>
<span class="nv">fileName</span><span class="o">=</span><span class="si">$(</span><span class="nb">basename</span> <span class="nt">--</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span><span class="si">)</span>
<span class="nv">fileName</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">fileName</span><span class="p">%.*</span><span class="k">}</span><span class="s2">"</span>

<span class="nb">echo</span> <span class="o">[</span>objects]&gt;<span class="s2">"</span><span class="k">${</span><span class="nv">fileDir</span><span class="k">}</span><span class="s2">/linkfile"</span>
<span class="nb">echo</span> <span class="k">${</span><span class="nv">fileDir</span><span class="k">}</span>/<span class="k">${</span><span class="nv">fileName</span><span class="k">}</span>.o&gt;&gt;<span class="s2">"</span><span class="k">${</span><span class="nv">fileDir</span><span class="k">}</span><span class="s2">/linkfile"</span>

<span class="o">[</span> <span class="nt">-e</span> <span class="s2">"</span><span class="k">${</span><span class="nv">fileDir</span><span class="k">}</span><span class="s2">/</span><span class="k">${</span><span class="nv">fileName</span><span class="k">}</span><span class="s2">.o"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">rm</span> <span class="s2">"</span><span class="k">${</span><span class="nv">fileDir</span><span class="k">}</span><span class="s2">/</span><span class="k">${</span><span class="nv">fileName</span><span class="k">}</span><span class="s2">.o"</span>

wla-gb <span class="nt">-o</span> <span class="s2">"</span><span class="k">${</span><span class="nv">fileDir</span><span class="k">}</span><span class="s2">/</span><span class="k">${</span><span class="nv">fileName</span><span class="k">}</span><span class="s2">.o"</span> <span class="nv">$1</span>
wlalink <span class="nt">-d</span> <span class="nt">-r</span> <span class="nt">-v</span> <span class="nt">-s</span> <span class="s2">"</span><span class="k">${</span><span class="nv">fileDir</span><span class="k">}</span><span class="s2">/linkfile"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">fileDir</span><span class="k">}</span><span class="s2">/</span><span class="k">${</span><span class="nv">fileName</span><span class="k">}</span><span class="s2">.gb"</span>
</code></pre></div></div> <p>Ainsi il suffit d’exécuter la commande <code class="highlighter-rouge">wla-gb-build mon_jeu.s</code> pour obtenir le fichier <code class="highlighter-rouge">mon_jeu.gb</code>.</p> <h2 id="algorithme-sha1">Algorithme SHA1</h2> <p>Maintenant que je sais comment créer et tester des programmes GB, je peux m’attaquer à la plus grosse partie, l’algorithme SHA1 !</p> <p>La solution qui me semble la plus évidente consiste à trouver le code de cet algorithme en C, ou même directement en assembleur x86, puis de voir comment je peux l’adapter avec les instructions disponibles en z80 (enfin, la version GB qui est légèrement différente d’un véritable z80).</p> <p>J’ai donc trouvé mon bonheur sur ce site : <a href="https://www.nayuki.io/page/fast-sha1-hash-implementation-in-x86-assembly" target="_blank">https://www.nayuki.io/page/fast-sha1-hash-implementation-in-x86-assembly</a></p> <p>Plus particulièrement leur implémentation en version <strong>fast</strong>.</p> <h3 id="opérations-32-bits-sur-cpu-8-bits">Opérations 32 bits sur CPU 8 bits</h3> <p>En étudiant un peu l’assembleur de la version <strong>fast</strong> je remarque, sans surprise, un certain nombre d’instructions basées sur une architecture 32 bits.</p> <p>Les instructions en question sont les suivantes :</p> <ul> <li><code class="highlighter-rouge">movl</code> Ecrit un entier 32 bits à une adresse en mémoire</li> <li><code class="highlighter-rouge">andl</code> Opération logique <strong>and</strong> entre 2 entiers 32 bits</li> <li><code class="highlighter-rouge">orl</code> Opération logique <strong>or</strong> entre 2 entiers 32 bits</li> <li><code class="highlighter-rouge">xorl</code> Opération logique <strong>xor</strong> entre 2 entiers 32 bits</li> <li><code class="highlighter-rouge">addl</code> Additionne 2 entiers 32 bits</li> <li><code class="highlighter-rouge">roll</code> Rotation des bits vers la gauche sur un entier 32 bits (les bits qui sortent re-rentrent par la droite)</li> </ul> <p>Concernant l’instruction <code class="highlighter-rouge">bswapl</code> (qui permet d’inverser l’ordre des 4 octets d’un entier 32 bits), elle n’est pas nécessaire en z80 (pour cet algorithme en tout cas), voir l’implémentation de <code class="highlighter-rouge">addl</code> ci-dessous pour plus de détails.</p> <p>Désormais il faut trouver un moyen de convertir ces instructions 32 bits pour pouvoir les utiliser sur un CPU 8 bits !</p> <p>Afin de simplifier l’utilisation, je choisis arbitrairement que le registre <strong>BC</strong> correspond à la source, et le registre <strong>HL</strong> à la destination.</p> <h4 id="instruction-movl">Instruction <code class="highlighter-rouge">movl</code></h4> <p>Cette instruction est probablement la plus simple à réaliser puisqu’il s’agit de déplacer 4 octets d’une adresse vers une autre.</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">movl:</span>                   <span class="c1">;hl=bc</span>
  <span class="nf">ld</span> <span class="nv">e</span><span class="p">,</span><span class="mi">4</span>                <span class="c1">;e = 4</span>
<span class="nl">loopmovl:</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">bc</span><span class="p">)</span>             <span class="c1">;a = (bc)</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">inc</span> <span class="nv">bc</span>                <span class="c1">;bc += 1</span>
  <span class="nf">dec</span> <span class="nv">e</span>                 <span class="c1">;e -= 1</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">loopmovl</span>        <span class="c1">;Si e != 0 : Jump loopmovl</span>
  <span class="nf">ret</span>
</code></pre></div></div> <p>La valeur pointée par le registre <strong>BC</strong> est insérée dans le registre <strong>A</strong> qui est ensuite insérée à l’adresse pointée par le registre <strong>HL</strong>.<br /> Les adresses pointées par <strong>HL</strong> et <strong>BC</strong> sont incrémentées afin de passer à l’octet suivant. Ces opérations sont répétées 4 fois.</p> <h4 id="instructions-andl-orl-xorl">Instructions <code class="highlighter-rouge">andl</code>, <code class="highlighter-rouge">orl</code>, <code class="highlighter-rouge">xorl</code></h4> <p>Le principe est très similaire à <code class="highlighter-rouge">movl</code>, il faut juste réaliser une opération supplémentaire (<code class="highlighter-rouge">and</code>, <code class="highlighter-rouge">or</code>, <code class="highlighter-rouge">xor</code>) sur chaque octet.</p> <p>Exemple pour l’instruction <code class="highlighter-rouge">and</code> :</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">andl:</span>                   <span class="c1">;hl&amp;=bc</span>
  <span class="nf">ld</span> <span class="nv">e</span><span class="p">,</span><span class="mi">4</span>                <span class="c1">;e = 4</span>
<span class="nl">loopandl:</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">bc</span><span class="p">)</span>             <span class="c1">;a = (bc)</span>
  <span class="nf">and</span> <span class="p">(</span><span class="nv">hl</span><span class="p">)</span>              <span class="c1">;a &amp;= (hl)</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">inc</span> <span class="nv">bc</span>                <span class="c1">;bc += 1</span>
  <span class="nf">dec</span> <span class="nv">e</span>                 <span class="c1">;e -= 1</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">loopandl</span>        <span class="c1">;Si e != 0 : Jump loopandl</span>
  <span class="nf">ret</span>
</code></pre></div></div> <h4 id="instruction-addl">Instruction <code class="highlighter-rouge">addl</code></h4> <p>Voilà enfin un peu de challenge !! Réaliser une addition de deux entiers 32 bits avec seulement des instructions sur 8 bits.<br /> A première vue il est légitime de penser que c’est compliqué, mais en réalité ça ne l’est pas !</p> <p>L’instruction <code class="highlighter-rouge">add</code> permet d’additionner deux entiers 8 bits, et si 8 bits ne suffisent pas pour stocker le résultat, alors il y aura une retenue qu’on peut intercepter via le flag <strong>c</strong> (Carry Flag) !</p> <p>On peut donc facilement étendre l’addition à plusieurs octets en utilisant le flag <strong>c</strong> pour vérifier si il est nécessaire d’appliquer la retenue sur l’octet suivant !</p> <p>A ce niveau il faut être cohérent sur l’ordre des octets. Le résultat ne pourra pas être le même si on va de l’octet 1 à 4 (little endian) ou de l’octet 4 à 1 (big endian). Pour simplifier et éviter d’implémenter l’instruction <code class="highlighter-rouge">bswapl</code> j’ai décidé de partir sur l’ordre big endian.</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">addl:</span>                   <span class="c1">;hl+=bc</span>
  <span class="nf">inc</span> <span class="nv">bc</span>                <span class="c1">;bc += 1</span>
  <span class="nf">inc</span> <span class="nv">bc</span>                <span class="c1">;bc += 1</span>
  <span class="nf">inc</span> <span class="nv">bc</span>                <span class="c1">;bc += 1</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">d</span><span class="p">,</span><span class="mi">5</span>                <span class="c1">;d = 5</span>
  <span class="nf">jp</span> <span class="nv">addlstart</span>          <span class="c1">;Jump addlstart</span>
<span class="nl">addlnext:</span>
  <span class="nf">pop</span> <span class="nv">de</span>                <span class="c1">;UnStack de</span>
  <span class="nf">pop</span> <span class="nv">hl</span>                <span class="c1">;UnStack hl</span>
  <span class="nf">dec</span> <span class="nv">hl</span>                <span class="c1">;hl -= 1</span>
<span class="nl">addlstart:</span>
  <span class="nf">dec</span> <span class="nv">d</span>                 <span class="c1">;d -= 1</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nv">addlend</span>          <span class="c1">;Si d == 0 : Jump addlend</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">bc</span><span class="p">)</span>             <span class="c1">;a = (bc)</span>
  <span class="nf">dec</span> <span class="nv">bc</span>                <span class="c1">;bc -= 1</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack hl</span>
  <span class="nf">push</span> <span class="nv">de</span>               <span class="c1">;Stack de</span>
  <span class="nf">add</span> <span class="p">(</span><span class="nv">hl</span><span class="p">)</span>              <span class="c1">;a += (hl)</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>             <span class="c1">;(hl) = a</span>
  <span class="nf">jr</span> <span class="nv">nc</span><span class="p">,</span><span class="nv">addlnext</span>        <span class="c1">;Si a+(hl) &lt; 256 : Jump addlnext (si pas de retenue)</span>
<span class="nl">addlnc:</span>
  <span class="nf">dec</span> <span class="nv">d</span>                 <span class="c1">;d -= 1</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nv">addlnext</span>         <span class="c1">;Si d == 0 : Jump addlnext (si on est sur le dernier octet)</span>
  <span class="nf">dec</span> <span class="nv">hl</span>                <span class="c1">;hl -= 1</span>
  <span class="nf">inc</span> <span class="p">(</span><span class="nv">hl</span><span class="p">)</span>              <span class="c1">;(hl) += 1 (on applique la retenue)</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">addlnext</span>        <span class="c1">;Si (hl) != 0 : Jump addlnext</span>
  <span class="nf">jp</span> <span class="nv">addlnc</span>             <span class="c1">;Sinon Jump addlnc (on fait suivre la retenue sur l'octet suivant)</span>
<span class="nl">addlend:</span>
  <span class="nf">ret</span>
</code></pre></div></div> <p>Pour commencer il faut ajouter 3 aux registres <strong>HL</strong> et <strong>BC</strong> afin de commencer le traitement sur les bons octets, puis je commence les additions octet par octet tout en appliquant bien la retenue aux octets suivants.</p> <p>Je sauvegarde les registres <strong>HL</strong> et <strong>DE</strong> sur la pile (Stack) afin de pouvoir procéder aux éventuels applications de retenues sans pour autant perdre le compte (puisque je dois décrémenter <strong>D</strong> et <strong>HL</strong> pour gérer correctement les retenues) puis je rétablis <strong>HL</strong> et <strong>DE</strong> pour le traitement du prochain octet (<strong>addlnext</strong>).</p> <h4 id="instruction-roll">Instruction <code class="highlighter-rouge">roll</code></h4> <p>On monte encore d’un cran en terme de challenge !! Je n’ai pas encore réussi à implémenter un <code class="highlighter-rouge">roll</code> générique et j’ai une doute sur la pertinence de le faire étant donné la complexité d’une telle opération comparé au besoin pour ce projet.</p> <p>En analysant l’algorithme SHA1 on constate que <code class="highlighter-rouge">roll</code> est utilisé seulement avec 3 décalages différents (1, 5 et 30). J’ai donc décidé de créer ces 3 <code class="highlighter-rouge">roll</code> différents sans chercher à faire une version générique.<br /> Pour cela j’ai posé sur papier chacun des 3 décalages afin de voir les correspondances des bits entre chaque octet, et ainsi pouvoir le retranscrire en assembleur.</p> <p><strong>Je suis cependant curieux/preneur de toutes solutions génériques ou de toutes optimisations de mon implémentation actuelle !</strong></p> <p>Voici le <code class="highlighter-rouge">roll5</code> en exemple :</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">roll5:</span>                  <span class="c1">;hl=roll(bc,5)</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack hl</span>
  <span class="nf">pop</span> <span class="nv">de</span>                <span class="c1">;UnStack de = hl</span>

  <span class="nf">push</span> <span class="nv">bc</span>               <span class="c1">;Stack bc</span>
  <span class="nf">pop</span> <span class="nv">hl</span>                <span class="c1">;UnStack hl = bc</span>

  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="mi">3</span>                <span class="c1">;b = 3</span>
<span class="nl">looproll5:</span>
  <span class="nf">ldi</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>            <span class="c1">;a = (hl), hl += 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">srl</span> <span class="nv">c</span>                 <span class="c1">;c &gt;&gt;= 1</span>
  <span class="nf">srl</span> <span class="nv">c</span>                 <span class="c1">;c &gt;&gt;= 1</span>
  <span class="nf">srl</span> <span class="nv">c</span>                 <span class="c1">;c &gt;&gt;= 1</span>
  <span class="nf">or</span> <span class="nv">c</span>                  <span class="c1">;a |= c</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">de</span><span class="p">),</span><span class="nv">a</span>             <span class="c1">;(de) = a</span>
  <span class="nf">inc</span> <span class="nv">de</span>                <span class="c1">;de += 1</span>
  <span class="nf">dec</span> <span class="nv">b</span>                 <span class="c1">;b -= 1</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">looproll5</span>       <span class="c1">;Si b != 0 : Jump looproll5</span>

  <span class="nf">ldd</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>            <span class="c1">;a = (hl), hl -= 1</span>
  <span class="nf">dec</span> <span class="nv">hl</span>                <span class="c1">;hl -= 1</span>
  <span class="nf">dec</span> <span class="nv">hl</span>                <span class="c1">;hl -= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a &lt;&lt;= 1</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">srl</span> <span class="nv">c</span>                 <span class="c1">;c &gt;&gt;= 1</span>
  <span class="nf">srl</span> <span class="nv">c</span>                 <span class="c1">;c &gt;&gt;= 1</span>
  <span class="nf">srl</span> <span class="nv">c</span>                 <span class="c1">;c &gt;&gt;= 1</span>
  <span class="nf">or</span> <span class="nv">c</span>                  <span class="c1">;a |= c</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">de</span><span class="p">),</span><span class="nv">a</span>             <span class="c1">;(de) = a</span>

  <span class="nf">ret</span>
</code></pre></div></div> <p>Il s’agit donc de réaliser les bons <code class="highlighter-rouge">shift</code> (décalages) sur les bons octets puis de faire un <code class="highlighter-rouge">or</code> pour fusionner les bits.</p> <p>Le principe est identique pour les 3 <code class="highlighter-rouge">roll</code> (1, 5 et 30) mais avec les bons décalages et les bonnes correspondances pour chacun.</p> <h3 id="espace-mémoire-nécessaire-variables">Espace mémoire nécessaire (variables)</h3> <p>Voici les différentes variables qui seront nécessaires au bon fonctionnement de l’algo :</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">Step</span>      <span class="nv">DB</span>            <span class="c1">;C000      : Compteur de rounds</span>
<span class="nf">StateA</span>    <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C001-C004 : SHA1 A en cours</span>
<span class="nf">StateB</span>    <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C005-C008 : SHA1 B en cours</span>
<span class="nf">StateC</span>    <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C009-C00C : SHA1 C en cours</span>
<span class="nf">StateD</span>    <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C00D-C010 : SHA1 D en cours</span>
<span class="nf">StateE</span>    <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C011-C014 : SHA1 E en cours</span>
<span class="nf">StateT</span>    <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C015-C018 : Temporaire pour les opérations sur les State</span>
<span class="nf">RollT</span>     <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C019-C01C : Temporaire pour certaines opérations </span>
<span class="nf">RoundK</span>    <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C01D-C020 : SHA1 K du round en cours</span>
<span class="nf">Block</span>     <span class="nb">DS</span> <span class="mi">64</span>         <span class="c1">;C021-C060 : SHA1 Block (message à hacher)</span>
<span class="nf">Schedule</span>  <span class="nb">DS</span> <span class="mi">64</span>         <span class="c1">;C061-C0A0 : Temporaire pour les opérations sur Block</span>
<span class="nf">InitA</span>     <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C0A1-C0A5 : Sauvegarde SHA1 A à l'initialisation</span>
<span class="nf">InitB</span>     <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C0A6-C0A9 : Sauvegarde SHA1 B à l'initialisation</span>
<span class="nf">InitC</span>     <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C0AA-C0AD : Sauvegarde SHA1 C à l'initialisation</span>
<span class="nf">InitD</span>     <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C0AE-C0B1 : Sauvegarde SHA1 D à l'initialisation</span>
<span class="nf">InitE</span>     <span class="nb">DS</span> <span class="mi">4</span>          <span class="c1">;C0B2-C0B5 : Sauvegarde SHA1 E à l'initialisation</span>
<span class="nf">Reg1</span>      <span class="nb">DS</span> <span class="mi">2</span>          <span class="c1">;C0B6-C0B7 : Registre 1</span>
<span class="nf">Reg2</span>      <span class="nb">DS</span> <span class="mi">2</span>          <span class="c1">;C0B8-C0B9 : Registre 2</span>
</code></pre></div></div> <p><strong>Total :</strong> 185 octets</p> <p>Les variables <code class="highlighter-rouge">StateA</code> à <code class="highlighter-rouge">StateE</code> contiennent le hash SHA1 en cours de calcul, le hash final sera donc dans ces variables également.<br /> Le hash correspond donc aux 20 octets de l’adresse <code class="highlighter-rouge">C001</code> à l’adresse <code class="highlighter-rouge">C014</code>.</p> <p><code class="highlighter-rouge">Reg1</code> et <code class="highlighter-rouge">Reg2</code> permettent de combler le faible nombre de registres disponibles sur la GB (seulement 3 registres 16 bits), ils servent donc de stockage d’adresse 16 bits.<br /> Ils sont nécessaires pour gérer la rotation automatique des 5 variables <code class="highlighter-rouge">State</code> à chaque round (voir le chapitre suivant).<br /> Sans eux il est possible de faire cette rotation en utilisant directement la pile (stack) mais il serait alors obligatoire de désactiver les interruptions de la GameBoy afin d’éviter d’avoir une interruption au mauvais moment qui viendrait écraser certaines données sur la pile : <a href="specifications-gameboy#interrupts" target="_blank">Voir la documentation sur les interruptions</a></p> <h3 id="initialisation-sha1">Initialisation SHA1</h3> <p>L’initialisation SHA1 consiste simplement à définir les valeurs des 5 états (<code class="highlighter-rouge">StateA</code> à <code class="highlighter-rouge">StateE</code>), il s’agit du vecteur d’initialisation du SHA1 par défaut :</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">sha1:</span>
  <span class="c1">;Init StateA = 0x67452301</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">67</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateA</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">45</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateA</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">23</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateA</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">01</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateA</span><span class="o">+</span><span class="mi">3</span><span class="p">),</span><span class="nv">a</span>

  <span class="c1">;Init StateB = 0xEFCDAB89</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">EF</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateB</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">CD</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateB</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">AB</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateB</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">89</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateB</span><span class="o">+</span><span class="mi">3</span><span class="p">),</span><span class="nv">a</span>

  <span class="c1">;Init StateC = 0x98BADCFE</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">98</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateC</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">BA</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateC</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">DC</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateC</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">FE</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateC</span><span class="o">+</span><span class="mi">3</span><span class="p">),</span><span class="nv">a</span>

  <span class="c1">;Init StateD = 0x10325476</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">10</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateD</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">32</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateD</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">54</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateD</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">76</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateD</span><span class="o">+</span><span class="mi">3</span><span class="p">),</span><span class="nv">a</span>

  <span class="c1">;Init StateE = 0xC3D2E1F0</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">C3</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateE</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">D2</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateE</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">E1</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateE</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span><span class="nv">a</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">F0</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">StateE</span><span class="o">+</span><span class="mi">3</span><span class="p">),</span><span class="nv">a</span>

<span class="nl">sha1next:</span>
  <span class="nf">xor</span> <span class="nv">a</span>                 <span class="c1">;a = 0</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">Step</span><span class="p">),</span><span class="nv">a</span>           <span class="c1">;(Step) = 0</span>

  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateA</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">InitA</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;InitA = StateA</span>

  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateB</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">InitB</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;InitB = StateB</span>

  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateC</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">InitC</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;InitC = StateC</span>

  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateD</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">InitD</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;InitD = StateD</span>

  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateE</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">InitE</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;InitE = StateE</span>
</code></pre></div></div> <p>Cet algorithme procède au calcul du hash SHA1 par blocs de <strong>64 octets</strong> (voir le chapitre sur la construction de la chaine à hacher pour plus d’informations).</p> <p>Il peut évidemment arriver qu’on ait besoin d’obtenir le hash de chaines bien plus longues que <strong>64 octets</strong>, c’est pourquoi il y a un second point de départ qui permet de ne pas réinitialiser les états du SHA1 en cours, il s’agit de <code class="highlighter-rouge">sha1next</code>.</p> <h3 id="initialisation-dun-round">Initialisation d’un round</h3> <p>A chaque round on constate deux changements, à savoir l’incrémentation du compteur de rounds (<code class="highlighter-rouge">Step</code>) ainsi qu’une rotation des arguments.<br /> Pour le round <strong>0</strong>, les arguments sont dans l’ordre <code class="highlighter-rouge">A, B, C, D, E</code>, puis au round suivant on constate une rotation : <code class="highlighter-rouge">E, A, B, C, D</code>, puis <code class="highlighter-rouge">D, E, A, B, C</code> et ainsi de suite pour les 80 rounds.</p> <p>Je commence donc par initialiser le tout premier ordre :</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateE</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack : StateE =&gt; ArgE</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateD</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack : StateD =&gt; ArgD</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateC</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack : StateC =&gt; ArgC</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateB</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack : StateB =&gt; ArgB</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateA</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack : StateA =&gt; ArgA</span>
  <span class="nf">jp</span> <span class="nv">initRound0</span>         <span class="c1">;Jump initRound0</span>
</code></pre></div></div> <p>J’utilise la pile afin de manipuler plus facilement ces valeurs. Le dernier entré est le premier sorti, c’est pour cela que je <code class="highlighter-rouge">push</code> de <code class="highlighter-rouge">StateE</code> à <code class="highlighter-rouge">StateA</code> et non l’inverse.<br /> Vu qu’il s’agit de l’ordre pour le round <strong>0</strong> je jump directement à cette étape (voir le chapitre sur le round 0 ci-dessous).</p> <p>Ensuite Il faut donc gérer la rotation des arguments pour les prochains rounds :</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">loopRound:</span>
  <span class="c1">;SP = 0</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">Reg1</span>            <span class="c1">;hl = Reg1</span>
  <span class="nf">pop</span> <span class="nv">de</span>                <span class="c1">;de = sp[0] = ArgA, sp = 2</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="nv">d</span>                <span class="c1">;a = d</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="nv">e</span>                <span class="c1">;a = e</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">pop</span> <span class="nv">de</span>                <span class="c1">;de = sp[2] = ArgB, sp = 4</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="nv">d</span>                <span class="c1">;a = d</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="nv">e</span>                <span class="c1">;a = e</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">pop</span> <span class="nv">de</span>                <span class="c1">;de = sp[4] = ArgC, sp = 6</span>
  <span class="nf">pop</span> <span class="nv">hl</span>                <span class="c1">;hl = sp[6] = ArgD, sp = 8</span>
  <span class="nf">pop</span> <span class="nv">bc</span>                <span class="c1">;bc = sp[8] = ArgE, sp = 10</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;sp = 8, sp[8] = hl = D</span>
  <span class="nf">push</span> <span class="nv">de</span>               <span class="c1">;sp = 6, sp[6] = de = C</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">Reg2</span>            <span class="c1">;hl = Reg2</span>
  <span class="nf">ld</span> <span class="nv">d</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;d = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">e</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;e = (hl)</span>
  <span class="nf">push</span> <span class="nv">de</span>               <span class="c1">;sp = 4, sp[4] = de = Reg2 = ArgB</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">Reg1</span>            <span class="c1">;hl = Reg1</span>
  <span class="nf">ld</span> <span class="nv">d</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;d = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">e</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;e = (hl)</span>
  <span class="nf">push</span> <span class="nv">de</span>               <span class="c1">;sp = 2, sp[2] = de = Reg1 = ArgA</span>
  <span class="nf">push</span> <span class="nv">bc</span>               <span class="c1">;sp = 0, sp[0] = bc = ArgE</span>

  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">Step</span><span class="p">)</span>           <span class="c1">;a = (Step)</span>
  <span class="nf">inc</span> <span class="nv">a</span>                 <span class="c1">;a += 1</span>
  <span class="nf">ld</span> <span class="p">(</span><span class="nv">Step</span><span class="p">),</span><span class="nv">a</span>           <span class="c1">;(Step) = a</span>

  <span class="nf">cp</span> <span class="nv">a</span><span class="p">,</span><span class="mi">16</span>
  <span class="nf">jr</span> <span class="nv">c</span><span class="p">,</span><span class="nv">loopRound0a</span>      <span class="c1">;Si Step &lt; 16: Jump loopRound0a</span>
  <span class="nf">cp</span> <span class="nv">a</span><span class="p">,</span><span class="mi">20</span>
  <span class="nf">jr</span> <span class="nv">c</span><span class="p">,</span><span class="nv">loopRound0b</span>      <span class="c1">;Si Step &lt; 20: Jump loopRound0b</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nv">initRound1</span>       <span class="c1">;Si Step == 20: Jump initRound1</span>
  <span class="nf">cp</span> <span class="nv">a</span><span class="p">,</span><span class="mi">40</span>
  <span class="nf">jr</span> <span class="nv">c</span><span class="p">,</span><span class="nv">loopRound1</span>       <span class="c1">;Si Step &lt; 40: Jump loopRound1</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nv">initRound2</span>       <span class="c1">;Si Step == 40: Jump initRound2</span>
  <span class="nf">cp</span> <span class="nv">a</span><span class="p">,</span><span class="mi">60</span>
  <span class="nf">jr</span> <span class="nv">c</span><span class="p">,</span><span class="nv">loopRound2</span>       <span class="c1">;Si Step &lt; 60: Jump loopRound2</span>
  <span class="nf">jr</span> <span class="nv">z</span><span class="p">,</span><span class="nv">initRound3</span>       <span class="c1">;Si Step == 60: Jump initRound3</span>
  <span class="nf">cp</span> <span class="nv">a</span><span class="p">,</span><span class="mi">80</span>
  <span class="nf">jr</span> <span class="nv">c</span><span class="p">,</span><span class="nv">loopRound3</span>       <span class="c1">;Si Step &lt; 80: Jump loopRound3</span>
  <span class="nf">jp</span> <span class="nv">loopRoundEnd</span>       <span class="c1">;Sinon Jump loopRoundEnd</span>
</code></pre></div></div> <p>Afin de simplifier les commentaires je pars du principe que <code class="highlighter-rouge">SP</code> vaut 0, ce n’est évidemment pas le cas en réalité !</p> <p>A ce niveau j’ai plusieurs possibilités pour faire la rotation.<br /> Dans un premier temps j’avais réalisé cela à base de <code class="highlighter-rouge">pop</code> et de <code class="highlighter-rouge">push</code> tout en jouant avec <code class="highlighter-rouge">SP</code> pour atteindre le bon emplacement. Mais cette solution n’était pas correcte car incompatible avec les interruptions GB !<br /> En effet, lors d’une interruption, la GameBoy va mettre en “pause” le code en cours d’exécution et faire l’équivalent d’un <code class="highlighter-rouge">call</code> vers le code de l’interruption (avec une étape en plus cependant). Cela a pour effet d’ajouter 2 adresses de retour sur la pile (pour les <code class="highlighter-rouge">ret</code> en fin d’interruption).<br /> De ce fait, si je tente de faire une rotation en me déplaçant directement dans la pile et qu’une interruption intervient en même temps, alors je verrai mes valeurs écrasées par ces adresses de retour.</p> <p>Pour éviter cela, j’ai ajouté deux variables (<code class="highlighter-rouge">Reg1</code> et <code class="highlighter-rouge">Reg2</code>) qui me servent de registre tampon en complément des 3 registres 16 bits de la GB. Ainsi je peux totalement vider la pile des 5 arguments puis la reconstruire proprement sans risquer de perdre des valeurs !</p> <p>Ensuite j’incrémente <code class="highlighter-rouge">Step</code> et je fais des simples comparaisons pour savoir quel round lancer.</p> <h3 id="round-0a-et-roundtail">Round 0a et roundtail</h3> <p>Initialisation du round <strong>0</strong> :</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">initRound0:</span>
  <span class="c1">;Init RoundK ROUND0 0x5A827999</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">RoundK</span>          <span class="c1">;hl = RoundK</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">5</span><span class="nv">A</span>              <span class="c1">;a = 0x5A</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">82</span>              <span class="c1">;a = 0x82</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">79</span>              <span class="c1">;a = 0x79</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">99</span>              <span class="c1">;a = 0x99</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
<span class="nl">loopRound0a:</span>
  <span class="nf">call</span> <span class="nv">round0a</span>
  <span class="nf">jp</span> <span class="nv">loopRound</span>
<span class="nl">loopRound0b:</span>
  <span class="nf">call</span> <span class="nv">round0b</span>
  <span class="nf">jp</span> <span class="nv">loopRound</span>
</code></pre></div></div> <p>On définit <code class="highlighter-rouge">RoundK</code> lors de l’initialisation du round <strong>0</strong> puis on appel <code class="highlighter-rouge">round0a</code> :</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">round0a:</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">Step</span><span class="p">)</span>           <span class="c1">;a = (Step)</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="mi">0</span>                <span class="c1">;b = 0</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,</span><span class="nv">a</span>                <span class="c1">;c = a</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">Bl</span><span class="nv">ock</span>           <span class="c1">;hl = Block</span>
  <span class="nf">add</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">bc</span>             <span class="c1">;hl += bc : Block[Step * 4]</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack hl</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">Schedule</span>        <span class="c1">;hl = Schedule</span>
  <span class="nf">add</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">bc</span>             <span class="c1">;hl += bc : Schedule[Step * 4]</span>
  <span class="nf">pop</span> <span class="nv">bc</span>                <span class="c1">;UnStack bc = Block[Step * 4]</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack hl</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;Schedule[Step * 4] = Block[Step * 4]</span>

  <span class="nf">pop</span> <span class="nv">bc</span>                <span class="c1">;UnStack bc = Schedule[Step * 4]</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">10</span>           <span class="c1">;hl = Stack+10 = ArgE</span>
  <span class="nf">ld</span> <span class="nv">e</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;e = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">d</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;d = (hl)</span>
  <span class="nf">push</span> <span class="nv">de</span>               <span class="c1">;Stack de</span>
  <span class="nf">pop</span> <span class="nv">hl</span>                <span class="c1">;UnStack hl = de</span>
  <span class="nf">call</span> <span class="nv">addl</span>             <span class="c1">;ArgE += Schedule[Step * 4]</span>

  <span class="nf">jp</span> <span class="nv">round0</span>
</code></pre></div></div> <p>Il n’y a pas d’instruction pour réaliser directement une multiplication sur GB, cependant, un <code class="highlighter-rouge">shift left</code> revient à multiplier par deux, je le fais donc deux fois afin de multiplier par 4.</p> <p>Pour atteindre <code class="highlighter-rouge">ArgE</code> j’utilise le registre <code class="highlighter-rouge">SP</code> sachant que j’ai construit la pile juste avant, je peux donc récupérer l’argument souhaité. Voici d’ailleurs à quoi ressemble la pile à ce moment :</p> <ul> <li><code class="highlighter-rouge">SP+0</code> = Adresse de retour</li> <li><code class="highlighter-rouge">SP+2</code> = ArgA</li> <li><code class="highlighter-rouge">SP+4</code> = ArgB</li> <li><code class="highlighter-rouge">SP+6</code> = ArgC</li> <li><code class="highlighter-rouge">SP+8</code> = ArgD</li> <li><code class="highlighter-rouge">SP+10</code> = ArgE</li> </ul> <p><code class="highlighter-rouge">round0</code> correspond à la partie commune entre <code class="highlighter-rouge">round0a</code> et <code class="highlighter-rouge">round0b</code> :</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">round0:</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">6</span>            <span class="c1">;hl = Stack+6 = ArgC</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;StateT = ArgC</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">8</span>            <span class="c1">;hl = Stack+8 = ArgD</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">xorl</span>             <span class="c1">;StateT ^= ArgD</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">4</span>            <span class="c1">;hl = Stack+4 = ArgB</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">andl</span>             <span class="c1">;StateT &amp;= ArgB</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">8</span>            <span class="c1">;hl = Stack+6 = ArgD</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">xorl</span>             <span class="c1">;StateT ^= ArgD</span>

  <span class="nf">jp</span> <span class="nv">roundtail</span>
</code></pre></div></div> <p><code class="highlighter-rouge">round0</code> étant atteint via un <code class="highlighter-rouge">jump</code>, il n’y a pas d’adresse de retour en plus sur la pile, ça ne change donc pas les accès aux arguments.<br /> <code class="highlighter-rouge">StateT</code> est utilisé comme variable temporaire pour réaliser les calculs tout au long du round.</p> <p>Je fais un <code class="highlighter-rouge">jump</code> et non un <code class="highlighter-rouge">call</code> pour atteindre <code class="highlighter-rouge">roundtail</code> car il est toujours appelé en fin de round, autant se servir du <code class="highlighter-rouge">ret</code> de <code class="highlighter-rouge">roundtail</code> et ainsi ne pas décaler la pile avec un autre <code class="highlighter-rouge">call</code> (les arguments restent donc accessibles avec la même offset sur SP).</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">roundtail:</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">4</span>            <span class="c1">;hl = Stack+4 = ArgB</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">push</span> <span class="nv">bc</span>               <span class="c1">;Stack bc</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">RollT</span>           <span class="c1">;hl = RollT</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;RollT = ArgB</span>
  <span class="nf">pop</span> <span class="nv">hl</span>                <span class="c1">;UnStack hl = ArgB</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">RollT</span>           <span class="c1">;bc = RollT</span>
  <span class="nf">call</span> <span class="nv">roll30</span>           <span class="c1">;ArgB = roll30(RollT)</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">10</span>           <span class="c1">;hl = Stack+10 = ArgE</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = ArgE</span>
  <span class="nf">push</span> <span class="nv">bc</span>               <span class="c1">;Stack bc</span>
  <span class="nf">push</span> <span class="nv">bc</span>               <span class="c1">;Stack bc</span>
  <span class="nf">pop</span> <span class="nv">hl</span>                <span class="c1">;UnStack hl = bc</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;bc = StateT</span>
  <span class="nf">call</span> <span class="nv">addl</span>             <span class="c1">;ArgE += StateT</span>

  <span class="nf">pop</span> <span class="nv">hl</span>                <span class="c1">;UnStack hl = ArgE</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">RoundK</span>          <span class="c1">;bc = RoundK</span>
  <span class="nf">call</span> <span class="nv">addl</span>             <span class="c1">;ArgE += RoundK</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">2</span>            <span class="c1">;hl = Stack+2 = ArgA</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">RollT</span>           <span class="c1">;hl = RollT</span>
  <span class="nf">call</span> <span class="nv">roll5</span>            <span class="c1">;RollT = roll5(ArgA)</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">10</span>           <span class="c1">;hl = Stack+10 = ArgE</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">push</span> <span class="nv">bc</span>               <span class="c1">;Stack bc</span>
  <span class="nf">pop</span> <span class="nv">hl</span>                <span class="c1">;UnStack hl = bc</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">RollT</span>           <span class="c1">;bc = RollT</span>
  <span class="nf">call</span> <span class="nv">addl</span>             <span class="c1">;ArgE += RollT</span>
  
  <span class="nf">ret</span>
</code></pre></div></div> <p><code class="highlighter-rouge">RollT</code> est utilisé comme variable temporaire pour réaliser les opérations <code class="highlighter-rouge">roll</code>.</p> <h3 id="round-0b-et-roundschedule">Round 0b et roundschedule</h3> <p>Les rounds <strong>0a</strong> et <strong>0b</strong> sont assez similaires et partagent la même valeur de <strong>K</strong>, ils ont donc la même initialisation ainsi qu’une partie de code en commun (voir ci-dessus pour l’initialisation du round).</p> <p>Code <code class="highlighter-rouge">round0b</code> :</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">round0b:</span>
  <span class="nf">call</span> <span class="nv">roundschedule</span>
  <span class="nf">jp</span> <span class="nv">round0</span>
</code></pre></div></div> <p>On a déjà vu <code class="highlighter-rouge">round0</code> ci-dessus puisqu’il s’agit du même code que pour <code class="highlighter-rouge">round0a</code>.</p> <p>Concernant <code class="highlighter-rouge">roundschedule</code>, il sera utile pour tous les rounds excepté <code class="highlighter-rouge">round0a</code> :</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">roundschedule:</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">Step</span><span class="p">)</span>           <span class="c1">;a = (Step)</span>
  <span class="nf">sub</span> <span class="mi">3</span>                 <span class="c1">;a -= 3</span>
  <span class="nf">and</span> <span class="mi">15</span>                <span class="c1">;a &amp;= 15</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="mi">0</span>                <span class="c1">;b = 0</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,</span><span class="nv">a</span>                <span class="c1">;c = a</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">Schedule</span>        <span class="c1">;hl = Schedule</span>
  <span class="nf">add</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">bc</span>             <span class="c1">;hl += bc : Schedule[(Step - 3) * 4]</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack hl</span>
  <span class="nf">pop</span> <span class="nv">bc</span>                <span class="c1">;UnStack bc = hl</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;StateT = Schedule[(Step - 3) * 4]</span>

  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">Step</span><span class="p">)</span>           <span class="c1">;a = (Step)</span>
  <span class="nf">sub</span> <span class="mi">8</span>                 <span class="c1">;a -= 8</span>
  <span class="nf">and</span> <span class="mi">15</span>                <span class="c1">;a &amp;= 15</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="mi">0</span>                <span class="c1">;b = 0</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,</span><span class="nv">a</span>                <span class="c1">;c = a</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">Schedule</span>        <span class="c1">;hl = Schedule</span>
  <span class="nf">add</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">bc</span>             <span class="c1">;hl += bc : Schedule[(Step - 8) * 4]</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack hl</span>
  <span class="nf">pop</span> <span class="nv">bc</span>                <span class="c1">;UnStack bc = hl</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">xorl</span>             <span class="c1">;StateT ^= Schedule[(Step - 8) * 4]</span>

  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">Step</span><span class="p">)</span>           <span class="c1">;a = (Step)</span>
  <span class="nf">sub</span> <span class="mi">14</span>                <span class="c1">;a -= 14</span>
  <span class="nf">and</span> <span class="mi">15</span>                <span class="c1">;a &amp;= 15</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="mi">0</span>                <span class="c1">;b = 0</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,</span><span class="nv">a</span>                <span class="c1">;c = a</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">Schedule</span>        <span class="c1">;hl = Schedule</span>
  <span class="nf">add</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">bc</span>             <span class="c1">;hl += bc : Schedule[(Step - 14) * 4]</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack hl</span>
  <span class="nf">pop</span> <span class="nv">bc</span>                <span class="c1">;UnStack bc = hl</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">xorl</span>             <span class="c1">;StateT ^= Schedule[(Step - 14) * 4]</span>

  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">Step</span><span class="p">)</span>           <span class="c1">;a = (Step)</span>
  <span class="nf">sub</span> <span class="mi">16</span>                <span class="c1">;a -= 16</span>
  <span class="nf">and</span> <span class="mi">15</span>                <span class="c1">;a &amp;= 15</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="mi">0</span>                <span class="c1">;b = 0</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,</span><span class="nv">a</span>                <span class="c1">;c = a</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">Schedule</span>        <span class="c1">;hl = Schedule</span>
  <span class="nf">add</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">bc</span>             <span class="c1">;hl += bc : Schedule[(Step - 16) * 4]</span>
  <span class="nf">push</span> <span class="nv">hl</span>               <span class="c1">;Stack hl</span>
  <span class="nf">pop</span> <span class="nv">bc</span>                <span class="c1">;UnStack bc = hl</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">xorl</span>             <span class="c1">;StateT ^= Schedule[(Step - 16) * 4]</span>

  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;bc = StateT</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">RollT</span>           <span class="c1">;hl = RollT</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;RollT = StateT</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">RollT</span>           <span class="c1">;bc = RollT</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">roll1</span>            <span class="c1">;StateT = roll1(RollT)</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">12</span>           <span class="c1">;hl = Stack+12 = ArgE</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">push</span> <span class="nv">bc</span>               <span class="c1">;Stack bc</span>
  <span class="nf">pop</span> <span class="nv">hl</span>                <span class="c1">;UnStack hl = bc</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;bc = StateT</span>
  <span class="nf">call</span> <span class="nv">addl</span>             <span class="c1">;ArgE += StateT</span>

  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,(</span><span class="nv">Step</span><span class="p">)</span>           <span class="c1">;a = (Step)</span>
  <span class="nf">and</span> <span class="mi">15</span>                <span class="c1">;a &amp;= 15</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">sla</span> <span class="nv">a</span>                 <span class="c1">;a *= 2</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="mi">0</span>                <span class="c1">;b = 0</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,</span><span class="nv">a</span>                <span class="c1">;c = a</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">Schedule</span>        <span class="c1">;hl = Schedule</span>
  <span class="nf">add</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">bc</span>             <span class="c1">;hl += bc : Schedule[Step * 4]</span>
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;bc = StateT</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;Schedule[Step * 4] = StateT</span>

  <span class="nf">ret</span>
</code></pre></div></div> <p>Rien de particulier à dire, le principe est similaire au reste du code qu’on a déjà vu plus haut.</p> <h3 id="round-1-et-3">Round 1 et 3</h3> <p>J’ai regroupé les rounds <strong>1</strong> et <strong>3</strong> dans le même chapitre car la seule différence entre les deux c’est la valeur de <strong>K</strong> (donc l’initialisation).</p> <p>Initialisation du round <strong>1</strong> :</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">initRound1:</span>
  <span class="c1">;Init RoundK ROUND1 0x6ED9EBA1</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">RoundK</span>          <span class="c1">;hl = RoundK</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">6</span><span class="nv">E</span>              <span class="c1">;a = 0x6E</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">D9</span>              <span class="c1">;a = 0xD9</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">EB</span>              <span class="c1">;a = 0xEB</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">A1</span>              <span class="c1">;a = 0xA1</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
<span class="nl">loopRound1:</span>
  <span class="nf">call</span> <span class="nv">round1</span>
  <span class="nf">jp</span> <span class="nv">loopRound</span>
</code></pre></div></div> <p>Initialisation du round <strong>3</strong> :</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">initRound3:</span>
  <span class="c1">;Init RoundK ROUND3 0xCA62C1D6</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">RoundK</span>          <span class="c1">;hl = RoundK</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">CA</span>              <span class="c1">;a = 0xCA</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">62</span>              <span class="c1">;a = 0x62</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">C1</span>              <span class="c1">;a = 0xC1</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="nv">D6</span>              <span class="c1">;a = 0xD6</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
<span class="nl">loopRound3:</span>
  <span class="nf">call</span> <span class="nv">round3</span>
  <span class="nf">jp</span> <span class="nv">loopRound</span>
</code></pre></div></div> <p>Code <code class="highlighter-rouge">round1</code> et <code class="highlighter-rouge">round3</code> :</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">round1:</span>
<span class="nl">round3:</span>
  <span class="nf">call</span> <span class="nv">roundschedule</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">4</span>            <span class="c1">;hl = Stack+4 = ArgB</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;StateT = ArgB</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">6</span>            <span class="c1">;hl = Stack+6 = ArgC</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">xorl</span>             <span class="c1">;StateT ^= ArgC</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">8</span>            <span class="c1">;hl = Stack+8 = ArgD</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">xorl</span>             <span class="c1">;StateT ^= ArgD</span>

  <span class="nf">jp</span> <span class="nv">roundtail</span>
</code></pre></div></div> <h3 id="round-2">Round 2</h3> <p>Et pour terminer, le round <strong>2</strong> :</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">round2:</span>
  <span class="nf">call</span> <span class="nv">roundschedule</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">6</span>            <span class="c1">;hl = Stack+6 = ArgC</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;StateT = ArgC</span>

  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;bc = StateT</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">RollT</span>           <span class="c1">;hl = RollT</span>
  <span class="nf">call</span> <span class="nv">movl</span>             <span class="c1">;RollT = StateT</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">8</span>            <span class="c1">;hl = Stack+8 = ArgD</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">push</span> <span class="nv">bc</span>               <span class="c1">;Stack bc : ArgD</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">orl</span>              <span class="c1">;StateT |= ArgD</span>

  <span class="nf">pop</span> <span class="nv">bc</span>                <span class="c1">;UnStack bc = ArgD</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">RollT</span>           <span class="c1">;hl = RollT</span>
  <span class="nf">call</span> <span class="nv">andl</span>             <span class="c1">;RollT &amp;= ArgD</span>

  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">sp</span><span class="o">+</span><span class="mi">4</span>            <span class="c1">;hl = Stack+4 = ArgB</span>
  <span class="nf">ld</span> <span class="nv">c</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;c = (hl)</span>
  <span class="nf">inc</span> <span class="nv">hl</span>                <span class="c1">;hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,(</span><span class="nv">hl</span><span class="p">)</span>             <span class="c1">;b = (hl)</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">andl</span>             <span class="c1">;StateT &amp;= ArgB</span>
  
  <span class="nf">ld</span> <span class="nv">bc</span><span class="p">,</span><span class="nv">RollT</span>           <span class="c1">;bc = RollT</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nv">StateT</span>          <span class="c1">;hl = StateT</span>
  <span class="nf">call</span> <span class="nv">orl</span>              <span class="c1">;StateT |= RollT</span>

  <span class="nf">jp</span> <span class="nv">roundtail</span>
</code></pre></div></div> <p>Ici j’utilise <code class="highlighter-rouge">RollT</code> comme variable temporaire en plus de <code class="highlighter-rouge">StateT</code>. Au final le nom de ces deux variables n’a pas réellement d’importance ;)</p> <h3 id="construction-de-la-chaine-à-hacher-blocs-sha1">Construction de la chaine à hacher (blocs SHA1)</h3> <p>Comme vaguement évoqué dans le chapitre sur l’initialisation SHA1, cet algorithme utilise des blocs de <strong>64 octets</strong>.</p> <p>Pour le moment je n’ai pas implémenté la génération des blocs, c’est donc une évolution future tout à fait envisageable !</p> <p>En attendant, afin de tester correctement le calcul du SHA1, j’ai fait un petit script python afin de générer les blocs :</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
</span>
<span class="kn">import</span> <span class="nn">getopt</span><span class="p">,</span> <span class="n">sys</span><span class="p">,</span> <span class="n">io</span>
<span class="kn">import</span> <span class="nn">binascii</span>

<span class="k">def</span> <span class="nf">usage</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"""
Usage : build-blocks.py [OPTIONS] &lt;source&gt;

Options :
-f  Source as file
-o  Output format (raw,hex,base64), default : hex
"""</span><span class="p">)</span>
    <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">output</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="nb">format</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s">"raw"</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="s">'unicode_escape'</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s">"hex"</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">binascii</span><span class="p">.</span><span class="n">b2a_hex</span><span class="p">(</span><span class="n">block</span><span class="p">).</span><span class="n">decode</span><span class="p">())</span>
    <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s">"base64"</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">binascii</span><span class="p">.</span><span class="n">b2a_base64</span><span class="p">(</span><span class="n">block</span><span class="p">).</span><span class="n">decode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">opts</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">getopt</span><span class="p">.</span><span class="n">getopt</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="s">"o:fh"</span><span class="p">,[</span><span class="s">"file"</span><span class="p">,</span> <span class="s">"output"</span><span class="p">,</span> <span class="s">"help"</span><span class="p">])</span>
    <span class="k">except</span> <span class="n">getopt</span><span class="p">.</span><span class="n">GetoptError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="n">usage</span><span class="p">()</span>
    <span class="n">source</span> <span class="o">=</span> <span class="s">' '</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">).</span><span class="n">encode</span><span class="p">()</span>
    <span class="n">isFile</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">out</span> <span class="o">=</span> <span class="s">"hex"</span>
    <span class="k">for</span> <span class="n">opt</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">(</span><span class="s">"-h"</span><span class="p">,</span> <span class="s">"--help"</span><span class="p">):</span>
            <span class="n">usage</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">(</span><span class="s">"-f"</span><span class="p">,</span> <span class="s">"--file"</span><span class="p">):</span>
            <span class="n">isFile</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">(</span><span class="s">"-o"</span><span class="p">,</span> <span class="s">"--output"</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="s">"raw"</span><span class="p">,</span> <span class="s">"hex"</span><span class="p">,</span> <span class="s">"base64"</span><span class="p">):</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">usage</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">usage</span><span class="p">()</span>

    <span class="n">reader</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">)</span> <span class="k">if</span> <span class="n">isFile</span> <span class="k">else</span> <span class="n">io</span><span class="p">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
    <span class="n">sourcelen</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">block</span> <span class="o">=</span> <span class="s">b''</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">block</span> <span class="o">=</span> <span class="n">reader</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">:</span>
            <span class="n">sourcelen</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="n">sourcelen</span> <span class="o">+=</span> <span class="mi">64</span>
        <span class="n">output</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

    <span class="n">block</span> <span class="o">+=</span> <span class="s">b'</span><span class="si">\</span><span class="se">x80</span><span class="s">'</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">57</span><span class="p">:</span>
        <span class="n">block</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">(</span><span class="mi">64</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>
        <span class="n">output</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">block</span> <span class="o">=</span> <span class="s">b''</span>
    
    <span class="n">block</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">(</span><span class="mi">57</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>
    <span class="n">blocklen</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([((</span><span class="n">sourcelen</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">])</span>
    <span class="n">sourcelen</span> <span class="o">&gt;&gt;=</span> <span class="mi">5</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span>
        <span class="n">blocklen</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">sourcelen</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">])</span>
        <span class="n">sourcelen</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span>
    <span class="n">block</span> <span class="o">+=</span> <span class="n">blocklen</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">output</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

    <span class="n">reader</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div></div> <p>Ce script permet donc de générer les blocs (1 par ligne) pour le message passé en argument (<code class="highlighter-rouge">source</code>), ou via le contenu d’un fichier en précisant l’option <code class="highlighter-rouge">-f</code>.<br /> L’option <code class="highlighter-rouge">-o</code> permet également de définir le format de sortie, à savoir :</p> <ul> <li><code class="highlighter-rouge">raw</code> : Données brutes <strong>Attention cependant aux retours à la ligne, un bloc doit faire 64 octets même si il contient des retours à la ligne</strong></li> <li><code class="highlighter-rouge">hex</code> : Données en hexadécimal</li> <li><code class="highlighter-rouge">base64</code> : Données en base64</li> </ul> <p>On peut désormais insérer ces blocs dans le code assembleur, voici un exemple pour le message <strong>test</strong> :</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">;Message : test</span>
  <span class="c1">;Init Block 1</span>
  <span class="c1">;Data (64 bytes) = test + \x80 + \x00*58 + \x20</span>
  <span class="nf">ld</span> <span class="nv">hl</span><span class="p">,</span><span class="nb">Bl</span><span class="nv">ock</span>           <span class="c1">;hl = Block</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">74</span>              <span class="c1">;a = 0x74</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">65</span>              <span class="c1">;a = 0x65</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">73</span>              <span class="c1">;a = 0x73</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">74</span>              <span class="c1">;a = 0x74</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">80</span>              <span class="c1">;a = 0x80</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">ld</span> <span class="nv">b</span><span class="p">,</span><span class="mi">58</span>               <span class="c1">;b = 58</span>
  <span class="nf">xor</span> <span class="nv">a</span>                 <span class="c1">;a = 0</span>
<span class="nl">initblock1:</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">dec</span> <span class="nv">b</span>                 <span class="c1">;b -= 1</span>
  <span class="nf">jr</span> <span class="nv">nz</span><span class="p">,</span><span class="nv">initblock1</span>      <span class="c1">;Si b &gt; 0 : Jump initblock1</span>
  <span class="nf">ld</span> <span class="nv">a</span><span class="p">,</span><span class="kc">$</span><span class="mi">20</span>              <span class="c1">;a = 0x20</span>
  <span class="nf">ldi</span> <span class="p">(</span><span class="nv">hl</span><span class="p">),</span><span class="nv">a</span>            <span class="c1">;(hl) = a, hl += 1</span>
  <span class="nf">call</span> <span class="nv">sha1</span>
</code></pre></div></div> <p>Après avoir inséré le bloc dans la variable bloc on appel <code class="highlighter-rouge">sha1</code> pour exécuter les calculs.</p> <p>Dans le cas où on a plusieurs blocs, il faut quand même appeler <code class="highlighter-rouge">sha1</code> sur le premier bloc puis appeler <code class="highlighter-rouge">sha1next</code> à la place pour les prochains blocs !</p> <h3 id="récupération-du-hash">Récupération du hash</h3> <p>Comme indiqué dans le chapitre sur l’espace mémoire nécessaire, le hash est stocké dans les variables <code class="highlighter-rouge">StateA</code> à <code class="highlighter-rouge">StateE</code>.</p> <p>Le 20 octets de ces 5 variables cumulées correspondent au hash et sont accessibles de l’adresse mémoire <code class="highlighter-rouge">C001</code> à <code class="highlighter-rouge">C014</code>.</p> <h2 id="conclusion">Conclusion</h2> <p>Ce projet a été un challenge très intéressant pour moi. J’ai pris beaucoup de plaisir à découvrir une partie des possibilités qu’offre la GameBoy.</p> <p>Il y a encore pas mal d’optimisations/évolutions possibles pour ce projet et je n’exclus pas une éventuelle seconde partie à cet article !</p> <p>Un grand merci à <a href="https://ark444.github.io/" target="_blank">entropyQueen</a> pour m’avoir motivé (sans le vouloir ^^) à me lancer dans ce projet.</p> <h2 id="sources-et-inspirations">Sources et inspirations</h2> <ul> <li><a href="https://github.com/Elrindel/SHA1-GameBoy" target="_blank">Code du projet</a></li> <li><a href="specifications-gameboy" target="_blank">Spécifications GameBoy</a></li> <li><a href="https://ark444.github.io/" target="_blank">Blog d’entropyQueen</a></li> <li><a href="http://furrtek.free.fr/?a=gbasm" target="_blank">Article de Furrtek</a></li> <li><a href="https://www.nayuki.io/page/fast-sha1-hash-implementation-in-x86-assembly" target="_blank">Source SHA1 en C et assembleur x86</a></li> </ul> </div> <div id="markdown-outline" class="col-lg-3"> </div> <div id="disqus_thread" class="pt-2 pb-4"> </div> <script> var disqus_loaded = false; function load_disqus(){ var disqus_target = document.getElementById('disqus_thread'), disqus_embed = document.createElement('script'); if(disqus_target && !disqus_loaded){ disqus_loaded = true; disqus_embed.type = 'text/javascript'; disqus_embed.async = true; disqus_embed.src = '//elrindel.disqus.com/embed.js'; document.getElementsByTagName('head')[0].appendChild(disqus_embed); } } function load_disqus_scroll(){ var currentScroll = document.scrollingElement.scrollTop; var disqus_target = document.getElementById('disqus_thread'); if(window.scrollY >= disqus_target.offsetTop-window.innerHeight-150){ load_disqus(); window.removeEventListener('scroll', load_disqus_scroll); } } window.addEventListener('scroll', load_disqus_scroll, false); </script> </div> </div> </section> <footer id="l-footer"> <div class="container"> <div class="row"> </div> </div> </footer> <script type="text/javascript" src="/assets/js/simpleLightbox.min.js"></script> <script type="text/javascript" src="/assets/js/base.js"></script> <script type="text/javascript" src="/assets/js/post.js"></script> </body> </html>
